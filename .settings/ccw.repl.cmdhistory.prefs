cmdhistory=["(ns basic-combat-ai.main-screen)" "game" "(use 'basic-combat-ai.main-screen \:reload)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(defn tt [{ecs \:ecs \:as game}]\\n  (println \\"fooka you\\"))" "game" "(use 'basic-combat-ai.main-screen \:reload)" "(basic-combat-ai.desktop-launcher/reset)" "game" "(ns basic-combat-ai.main-screen)" "game" "(ns basic-combat-ai.ecs)" "(conj [] 1)" "(defn tt [a]\\n  a)" "(\= tt (fn [a] a))" "(\= tt tt)" "(\= (fn [a] a) (fn [a] a))" "(defn add-system [{ecs \:ecs {existing-systems \:systems} \:as game} new-system]\\n  (assoc-in game [\:ecs \:systems] (conj existing-systems new-system)))" "(defn add-system [{ecs \:ecs {existing-systems \:systems} \:as game}]\\n  (assoc-in game [\:ecs \:systems] (conj existing-systems 1)))" "(defn add-system [{ecs \:ecs {existing-systems \:systems}}]\\n  (assoc-in game [\:ecs \:systems] (conj existing-systems 1)))" "(defn add-system [{ecs \:ecs {existing-systems \:systems}}]\\n  (assoc-in {} [\:ecs \:systems] (conj existing-systems 1)))" "(defn add-system [{{existing-systems \:systems} \:ecs}]\\n  (assoc-in {} [\:ecs \:systems] (conj existing-systems 1)))" "(defn add-system [{{existing-systems \:systems} \:ecs \:as game}]\\n  (assoc-in {} [\:ecs \:systems] (conj existing-systems 1)))" "(defn add-system [{{existing-systems \:systems} \:ecs \:as game} new-system]\\n  (assoc-in game [\:ecs \:systems] (conj existing-systems new-system)))" "(add-system {\:ecs {\:systems []}} tt)" "(defn update-ecs [{{entities \:entities systems \:systems} \:ecs \:as game}]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\n                                        ents entities]\\n                                   (if (empty? syss)\\n                                     ents\\n                                     (recur (rest syss) ((first syss) game))))))" "tt" "(def g {\:ecs {\:entities [] \:systems []}})" "(def tt [{{ents \:entities} \:ecs}]\\n  ents)" "(defn tt [{{ents \:entities} \:ecs}]\\n  ents)" "g" "(def g (add-system g tt))" "g" "(update-ecs g)" "(defn update-ecs [{{entities \:entities systems \:systems} \:ecs \:as game}]\\r\\n     (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                           ents entities]\\r\\n                                      (if (empty? syss)\\r\\n                                        ents\\r\\n                                        (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "tt" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n  (map (fn [e] (inc (\:id e)) ents)))" "g" "(def g (assoc-in g [\:ecs \:entities] [{\:id 0} {\:id 1} {\:id 2}]))" "g" "(update-ecs g)" "tt" "(def g (assoc-in g [\:ecs \:systems] [tt]))" "g" "(update-ecs g)" "g" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n     (doall (map (fn [e] (inc (\:id e)) ents))))" "(def g (assoc-in g [\:ecs \:systems] [tt]))" "g" "(update-ecs g)" "(tt g)" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n  (map (fn [e] (inc (\:id e)) ents)))" "(tt g)" "(map (fn [e] (inc (\:id e)) (get-in g [\:ecs \:entities])))" "(map inc [1 2 3])" "(map (fn [e] (inc (\:id e)) (get-in g [\:ecs \:entities])))" "(do (map (fn [e] (inc (\:id e)) (get-in g [\:ecs \:entities]))))" "((map (fn [e] (inc (\:id e)) (get-in g [\:ecs \:entities]))))" "(map (fn [e] (inc (\:id e))) (get-in g [\:ecs \:entities]))" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n  (map (fn [e] (inc (\:id e))) ents))" "(def g (assoc-in g [\:ecs \:systems] [tt]))" "g" "(update-ecs g)" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n     (mapv (fn [e] (assoc e \:id (inc (\:id e))) ents)))" "(def g (assoc-in g [\:ecs \:systems] [tt]))" "g" "(update-ecs g)" "(defn tt [{{ents \:entities} \:ecs}]\\r\\n        (mapv (fn [e] (assoc e \:id (inc (\:id e)))) ents))" "(def g (assoc-in g [\:ecs \:systems] [tt]))" "(update-ecs g)" "g" "(defn tt2 [{{ents \:entities} \:ecs}]\\r\\n        (mapv (fn [e] (assoc e \:id (inc (\:id e)))) ents))" "(def g (assoc-in g [\:ecs \:systems] [tt tt2]))" "g" "(update-ecs g)" "(def g (assoc-in g [\:ecs \:systems] []))" "g" "(add-system g tt)" "(into [1 2 3] [4 5 6])" "(conj [1 2 3] [4 5 6])" "(into [1 2 3] 4)" "(into [1 2 3] '(4 5 6))" "(defn add-system \\r\\n  [{{existing-systems \:systems} \:ecs \:as game} new-system]\\r\\n    (assoc-in game [\:ecs \:systems] (conj existing-systems new-system))\\r\\n  [{{existing-systems \:systems} \:ecs \:as game} new-systems]\\r\\n    (assoc-in game [\:ecs \:systems] (into existing-systems new-system)))" "(defn add-system \\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-system]\\r\\n    (assoc-in game [\:ecs \:systems] (conj existing-systems new-system)))\\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-systems]\\r\\n    (assoc-in game [\:ecs \:systems] (into existing-systems new-system))))" "(def a \\n  ([b] b)\\n  ([c d] d))" "(defn a \\n  ([b] b)\\n  ([c d] d))" "(defn add-system \\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-system]\\r\\n    (assoc-in game [\:ecs \:systems] (conj existing-systems new-system)))\\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-systems]\\r\\n    (assoc-in game [\:ecs \:systems] (into existing-systems new-system))))" "(defn add-system \\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-system]\\r\\n    (assoc-in game [\:ecs \:systems] (conj existing-systems new-system)))\\r\\n  ([{{existing-systems \:systems} \:ecs \:as game} new-systems]\\r\\n    (assoc-in game [\:ecs \:systems] (into existing-systems new-systems))))" "(defn add-system [{{existing-systems \:systems} \:ecs \:as game} new-systems]\\n  (if (vector? new-systems)\\n    (let [ass-game (partial assoc-in game [\:ecs \:systems])\\n    (assoc-in game [\:ecs \:systems] (into existing-systems new-system))\\r\\n    (assoc-in game [\:ecs \:systems] (conj existing-systems new-system))))" "(partial assoc-in game [\:ecs \:systems])" "(partial assoc-in {} [\:ecs \:systems])" "(defn add-system [{{existing-systems \:systems} \:ecs \:as game} new-systems]\\n  (let [ass-game (partial assoc-in game [\:ecs \:systems])]\\n    (if (vector? new-systems)\\n      (ass-game (into existing-systems new-system))\\r\\n      (ass-game (conj existing-systems new-system)))))" "(defn add-system [{{existing-systems \:systems} \:ecs \:as game} new-systems]\\n  (let [ass-game (partial assoc-in game [\:ecs \:systems])]\\n    (if (vector? new-systems)\\n      (ass-game (into existing-systems new-systems))\\r\\n      (ass-game (conj existing-systems new-systems)))))" "g" "(add-system g tt)" "(add-system g [tt tt2])" "(defn add-entity [{{ents \:entities} \:as game} new-entity]\\n  (assoc-in game [\:ecs \:entities] (conj ents new-entity)))" "(defn add-entity [{{ents \:entities} \:ecs \:as game} new-entity]\\n  (assoc-in game [\:ecs \:entities] (conj ents new-entity)))" "(add-entity g {\:id 99})" "g" "(def g (assoc-in g [\:ecs \:entities] []))" "(use 'basic-combat-ai.ecs \:reload)" "g" "(defn render [{{ents \:entities} \:ecs batch \:batch}]\\n  ents)" "(defn render [{{ents \:entities} \:ecs batch \:batch}]\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)\\n        other-ents (filterv \#(not (and (\:renderable %) (\:transform %))) ents)]\\n    (.begin batch)\\n    (doall \\n      (map \#(let [texture-region (\:renderable %)\\n                  x (float (get-in % [\:transform \:x]))\\n                  y (float (get-in % [\:transform \:y]))\\n                  width (float (.getWidth (.getTexture (\:renderable %))))\\n                  height (float (.getHeight (.getTexture (\:renderable %))))]\\n              (.draw texture-region x y width height)) \\n           qualifying-ents))\\n    (.end batch))\\n  ents)" "(use 'basic-combat-ai.systems \:reload)" "(use 'basic-combat-ai.main-screen \:reload)" "(basic-combat-ai.desktop-launcher/reset)" "game" "(ns basic-combat-ai.systems)" "(use 'basic-combat-ai.systems \:reload)" "(defn init [game]\\n  (ecs/add-system game render))" "(init (ecs/g))" "get" "ecs/g" "(init ecs/g)" "(ns basic-combat-ai.entities)" "(use 'basic-combat.ai.entities \:reload)" "(use 'basic-combat-ai.entities \:reload)" "(defn pistoleer [{tex-cache \:tex-cache}]\\n  (assoc {}\\n         \:transform (comps/transform 50 50 0)\\n         \:renderable (\:pistol-idle tex-cache)))" "(defn init [game]\\n  (ecs/add-entity game (pistoleer (\:tex-cache game))))" "(ns basic-combat-ai.main-screen)" "(use 'basic-combat-ai.main-screen \:reload)" "(defn init-game []\\r\\n  (let [tex-cache (init-tex-cache)]\\r\\n    (-> (assoc {}\\r\\n               \:batch (SpriteBatch.)\\r\\n               \:tex-cache tex-cache\\r\\n               \:inputs {})\\r\\n      (ecs/init-ecs)\\r\\n      (ent/init)\\n      (sys/init))))" "(def r []\\n  (use 'basic-combat-ai.main-screen \:reload)\\n  (basic-combat-ai.desktop-launcher/reset))" "(defn r []\\n  (use 'basic-combat-ai.main-screen \:reload)\\n  (basic-combat-ai.desktop-launcher/reset))" "r" "(r)" "(use 'basic-combat-ai.ecs \:reload)" "(use 'basic-combat-ai.systems \:reload)" "(use 'basic-combat-ai.desktop-launcher \:reload)" "(use 'basic-combat-ai.desktop-launcher \:reload-all)" "(ns basic-combat-ai.main-screen)" "game" "(ns basic-combat-ai.main-screen)" "game" "(basic-combat-ai.desktop-launcher/run-on-main-thread (fn [] (.findRegion (TextureAtlas. \\"s.pack\\") \\"pistol idle\\")))" "(.findRegion (TextureAtlas. \\"s.pack\\") \\"pistol idle\\")" "(use 'basic-combat-ai.main-screen \:reload)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "game" "(ns basic-combat-ai.main-screen)" "game" "(\:tex-cache game)" "(\:pistol-idle (\:tex-cache game))" "(.getWitdh (\:pistol-idle (\:tex-cache game)))" "(.getWidth (\:pistol-idle (\:tex-cache game)))" "(.getWidth (cast TextureRegion (\:pistol-idle (\:tex-cache game))))" "(cast TextureRegion (\:pistol-idle (\:tex-cache game)))" "(cast TextureRegion.class (\:pistol-idle (\:tex-cache game)))" "(.getWidth ^TextureRegion (\:pistol-idle (\:tex-cache game)))" "(.getRegionWidth (\:pistol-idle (\:tex-cache game)))" "(.getRegionHeight (\:pistol-idle (\:tex-cache game)))" "(.getWidth (.getTexture (\:pistol-idle (\:tex-cache game))))" "(.getHeight (.getTexture (\:pistol-idle (\:tex-cache game))))" "(use 'basic-combat-ai.systems \:reload)" "(reset)" "(use clojure.tools.namespace.repl)" "(require 'basic-combat-ai.desktop-launcher \:reload-all)" "(ns basic-combat-ai.main-screen)" "game" "(def r []\\n  (require 'basic-combat-ai.desktop-launcher \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(defn r []\\n  (require 'basic-combat-ai.desktop-launcher \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "r" "(defn r []\\r\\n  (doall (require 'basic-combat-ai.desktop-launcher \:reload-all)\\r\\n     (basic-combat-ai.desktop-launcher/reset)))" "r" "(defn r []\\r\\n     (require 'basic-combat-ai.desktop-launcher \:reload-all)\\r\\n     (basic-combat-ai.desktop-launcher/reset))" "(r)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "(init-game)" "(ns basic-combat-ai.main-screen)" "game" "\\r\\n        (require 'basic-combat-ai.desktop-launcher \:reload-all)\\r\\n        (basic-combat-ai.desktop-launcher/reset)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "\#'basic-combat-ai.main-screen/screen" "(ns basic-combat-ai.main-screen)" "game" "(ns basic-combat-ai.main-screen)" "game" "(\:transform (first (\:entities (\:ecs game))))" "(require '[clojure.tools.namespace.repl \:refer [refresh]])" "game" "(require 'basic-combat-ai.main-screen \:reload-all)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "(def r []\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(defn r []\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "game" "(ecs/add-system game (sys/render game))" "(r)" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rot] 45))" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 45))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] -45))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0))" "(boolean [])" "(boolean [nil])" "(some \#{nil} [nil])" "(\#{nil} nil)" "(\#{nil} \\"test\\")" "(\#{\\"test\\"} \\"test\\")" "({\:pistol-firing [{\:texture \\"0\\" \:duration 0.0} {\:texture \\"1\\" \:duration 0.0}]} \:pistol-firing)" "({\:pistol-firing [{\:texture \\"0\\" \:duration 0.0} {\:texture \\"1\\" \:duration 0.0}]} [\:pistol-firing 0])" "(keys {\:pistol-firing [{\:texture \\"0\\" \:duration 0.0} {\:texture \\"1\\" \:duration 0.0}]})" "(key {\:pistol-firing [{\:texture \\"0\\" \:duration 0.0} {\:texture \\"1\\" \:duration 0.0}]})" "(key \\"tesT\\" )" "(defn animation [frames loop?]\\r\\n  \\"frames sample\: {\:pistol-fire [{\:texture abc \:duration 0.1} {\:texture def \:duration 1.3}]\\r\\n                   \:pistol-idle [{\:texture aaa \:duration 0.5}]}\\"\\r\\n  (assoc {}\\r\\n         \:current-frame -1\\r\\n         \:current-duration 0.0\\r\\n         \:loop? loop?\\r\\n         \:frames frames))" "(defn animation [frames loop?]\\r\\n  \\"frames sample\: {\:pistol-fire [{\:texture abc \:duration 0.1} {\:texture def \:duration 1.3}]\\r\\n                   \:pistol-idle [{\:texture aaa \:duration 0.5}]}\\"\\n  {\:pre [(map? frames) \\n         (map \\n           (fn [k] (map \\n                     (fn [f] (and (\:texture f) (\:duration f))) \\n                     (k frames))) \\n           (keys frames))\\n         ]}\\r\\n  (assoc {}\\r\\n         \:current-frame -1\\r\\n         \:current-duration 0.0\\r\\n         \:loop? loop?\\r\\n         \:frames frames))" "(let [frames {\:pistol-fire [{\:texture abc \:duration 0.1} {\:texture def \:duration 1.3}]\\r\\n              \:pistol-idle [{\:texture aaa \:duration 0.5}]}]\\n  (map \\r\\n    (fn [k] (map \\r\\n              (fn [f] (and (\:texture f) (\:duration f))) \\r\\n              (k frames))) \\r\\n    (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\n                            {\:texture \\"def\\" \:duration 1.3}]\\r\\n              \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\n  (map \\r\\n    (fn [k] (map \\r\\n              (fn [f] (and (\:texture f) (\:duration f))) \\r\\n              (k frames))) \\r\\n    (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\n                            {\:texture \\"def\\" \:duration 1.3}]\\r\\n              \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\n  (map \\r\\n    (fn [k] (k frames))\\r\\n    (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                               {\:texture \\"def\\" \:duration 1.3}]\\r\\n                 \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n     (map \\r\\n       (fn [k] (map \\r\\n                 (fn [fs] \\n                   (map \\n                     (fn [f] (and (\:texture f) (\:duration f))) \\n                     fs))\\n                 (k frames)))\\n       (keys frames)))" "(boolean '(((nil nil) (nil nil)) ((nil nil))))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (map \\r\\n                        (fn [f] f) \\r\\n                        fs))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      fs)\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:texture fs) (\:duration fs)))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      fs)\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (\:texture fs))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:texture fs) true))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:duration fs) true))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:duration fs) (\:texture fs)))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:duration fs)))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(and (\:duration {\:duration 0.5}))" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:duration fs) (\:texture fs)))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(vals ((\\"abc\\" \\"def\\") (\\"aaa\\")))" "(vals '((\\"abc\\" \\"def\\") (\\"aaa\\")))" "(identity x)" "(identity 1)" "(into [] [1 2 [3 4]])" "(let [frames {\:pistol-fire [{\:texture \\"abc\\" \:duration 0.1} \\r\\n                                  {\:texture \\"def\\" \:duration 1.3}]\\r\\n                    \:pistol-idle [{\:texture \\"aaa\\" \:duration 0.5}]}]\\r\\n        (map \\r\\n          (fn [k] (map \\r\\n                    (fn [fs] \\r\\n                      (and (\:duration fs) (\:texture fs)))\\r\\n                    (k frames)))\\r\\n          (keys frames)))" "(ns basic-combat-ai.components)" "(frame \\"butt sex\\" 0.4)" "(partition 2 [\\"one\\" 1 \\"two\\" 2 \\"three\\" 3])" "(partition 2 [\:pistol-fire (frame \\"t1\\" 0.1) (frame \\"t2\\" 1.5)])" "(partition 2 [1])" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (partition 2 args))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (vector (partition 2 args)))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (partition 2 args))" "(conj {\:hi \\"1\\"} {\:test \\"test\\"})" "(conj {\:hi \\"1\\"} {\:hi \\"test\\"})" "(merge {\:hi \\"1\\"} {\:hi \\"test\\"})" "(merge {\:hi \\"1\\"} {\:test \\"test\\"})" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (partition 2 args)))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (doall (partition 2 args))))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (partition 2 args)))" "(let [args [\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5)]]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (partition 2 args)))" "(let [args '(\:pistol-fire ['(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (partition 2 args)))" "(let [args '(\:pistol-fire [\#(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (second name-frame)})\\n         (partition 2 args)))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (eval (second name-frame))})\\n         (partition 2 args)))" "'((+ 1 2))" "[(+ 1 2)]" "(let [args (eval '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n             \:pistol-stunna (frame \\"5\\" 5)))]\\r\\n  (map (fn [name-frame]\\r\\n         {(first name-frame) (eval (second name-frame))})\\r\\n         (partition 2 args)))" "(let [args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n             \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\n             \:pistol-stunna (frame \\"5\\" 5))]\\n  (map (fn [name-frame]\\n         {(first name-frame) (eval (second name-frame))})\\n         (partition 2 args)))" "(eval '(+ 1 2))" "(let [literal-args '(\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n                     \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n                     \:pistol-stunna (frame \\"5\\" 5))\\n      args (eval literal-args)]\\r\\n  (map (fn [name-frame]\\r\\n         {(first name-frame) (second name-frame)})\\r\\n         (partition 2 args)))" "(let [args [\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n                     \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n                     \:pistol-stunna (frame \\"5\\" 5)]]\\r\\n  (map (fn [name-frame]\\r\\n         {(first name-frame) (second name-frame)})\\r\\n         (partition 2 args)))" "(let [args [\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n                     \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n                     \:pistol-stunna (frame \\"5\\" 5)]\\n      mapped (map (fn [name-frame]\\r\\n                    {(first name-frame) (second name-frame)})\\r\\n                  (partition 2 args))]\\n  \\r\\n  )" "(let [args [\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n                     \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n                     \:pistol-stunna (frame \\"5\\" 5)]\\n      mapped (map (fn [name-frame]\\r\\n                    {(first name-frame) (second name-frame)})\\r\\n                  (partition 2 args))]\\n  (reduce conj mapped))" "(let [args [\:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\r\\n                     \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]             \\r\\n                     \:pistol-stunna (frame \\"5\\" 5)]\\n      mapped (map (fn [name-frame]\\r\\n                    {(first name-frame) (second name-frame)})\\r\\n                  (partition 2 args))]\\n  (vector (reduce conj mapped)))" "(defn frames [& args]\\n  (let [mapped (map (fn [name-frame]\\r\\n                      {(first name-frame) (second name-frame)})\\r\\n                    (partition 2 args))]\\r\\n  (vector (reduce conj mapped))))" "(frames \:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)])" "(defn frames [& args]\\r\\n     (let [mapped (map (fn [name-frame]\\r\\n                         {(first name-frame) (second name-frame)})\\r\\n                       (partition 2 args))]\\r\\n     (reduce conj mapped)))" "(frames \:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)])" "(frames \:pistol-fire [(frame \\"1\\" 1) (frame \\"2\\" 2)]\\n        \:pistol-gunna [(frame \\"3\\" 3) (frame \\"4\\" 4)]\\n        \:pistol-stunna (frame \\"5\\" 5))" "(defn frames [& args]\\r\\n        (let [mapped (map (fn [name-frame]\\r\\n                            {(first name-frame) (let [second-item (second name-frame)]\\n                                                  (if (vector? second-item) second-item (vector second-item)))})\\r\\n                          (partition 2 args))]\\r\\n        (reduce conj mapped)))" "(use 'basic-combat-ai.components \:reload)" "(ns basic-combat-ai.systems)" "(ns basic-combat-ai.main-screen)" "game" "(\:tex-cache game)" "(keys (\:tex-cache game))" "game" "(\:entities (\:ecs game))" "(assoc-in game [\:ecs \:entities 0 \:animation] (animation nil true))" "(assoc-in game [\:ecs \:entities 0] \:animation)" "game" "(get-in game [\:ecs \:entities 0])" "(require [basic-combat-ai.components \:as comps])" "game" "(require [basic-combat-ai.components \:as comps])" "(use 'basic-combat-ai.components \:reload)" "(require '[basic-combat-ai.components \:as comps])" "game" "(nth [\\"a\\" \\"b\\" \\"c\\"] 2)" "(use clojure.repl)" "(use 'clojure.repl)" "(source assoc)" "(source animation)" "(source frame)" "(use 'basic-combat-ai.components \:reload)" "(source animation)" "(let [tex-cache (\:tex-cache game)]\\r\\n  (assoc-in game [\:ecs \:entities 0 \:animation] (animation (frames \:fire-pistol [(frame (\:fire-pistol00 tex-cache) 0.1)\\r\\n                                                                                (frame (\:fire-pistol01 tex-cache) 0.1)\\r\\n                                                                                (frame (\:fire-pistol02 tex-cache) 0.1)]\\r\\n                                                                               false\\r\\n                                                                  \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1)\\r\\n                                                                               true))))" "(update-game\! \#(let [tex-cache (\:tex-cache %)]\\r\\n  (assoc-in game [\:ecs \:entities 0 \:animation] (animation (frames \:fire-pistol [(frame (\:fire-pistol00 tex-cache) 0.1)\\r\\n                                                                                (frame (\:fire-pistol01 tex-cache) 0.1)\\r\\n                                                                                (frame (\:fire-pistol02 tex-cache) 0.1)]\\r\\n                                                                               false\\r\\n                                                                  \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1)\\r\\n                                                                               true)))))" "(filter zero? [0 1 2 3])" "(filter (complement zero?) [0 1 2 3])" "(filter (complement \#(zero?)) [0 1 2 3])" "(filter (complement \#(\= 0 %)) [0 1 2 3])" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter (not \#(and (\:state %) (\:animation %)) ents))]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))))" "game" "(get-in game [\:ecs \:entities])" "(get-in game [\:ecs \:entities 0])" "(keys (get-in game [\:ecs \:entities 0]))" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter (not \#(and (\:state %) (\:animation %)) ents))]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))))" "(keys (get-in game [\:ecs \:entities 0 \:state]))" "(get-in game [\:ecs \:entities 0 \:state])" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))))" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))\\n    (conj qualifying-ents rest-ents)))" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))\\n    (into qualifying-ents rest-ents)))" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))\\n    (into [] qualifying-ents rest-ents)))" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filter \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filter \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))\\n    (vector (into qualifying-ents rest-ents))))" "(pistoleer-state->animation-state game)" "(defn pistoleer-state->animation-state [{{ents \:entities} \:ecs}]\\n  (let [qualifying-ents (filterv \#(and (\:state %) (\:animation %)) ents)\\n        rest-ents (filterv \#(not (and (\:state %) (\:animation %))) ents)]\\n    (map (fn [e]\\n           (cond \\n             (\= (\:state e) \:idle) \\n             (assoc-in e [\:animation \:current-animation] \:pistol-idle))))\\n    (into qualifying-ents rest-ents)))" "(pistoleer-state->animation-state game)" "game" "(get-in game [\:ecs \:entities 0 \:animation])" "(keys (get-in game [\:ecs \:entities 0 \:animation 0]))" "(get-in game [\:ecs \:entities 0 \:animation 0])" "(get-in game [\:ecs \:entities 0 \:animation])" "(keys (get-in game [\:ecs \:entities 0 \:animation]))" "(keys (get-in game [\:ecs \:entities 0 \:animation \:frames]))" "game" "(use 'basic-combat-ai.components \:reload)" "(animation (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                   \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                 (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                 (frame (\:pistol-idle tex-cache) 0.1)] false))" "(let [tex-cache (\:tex-cache game)]\\n  (animation (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                   \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                 (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                 (frame (\:pistol-idle tex-cache) 0.1)] false)))" "(source animation)" "(let [tex-cache (\:tex-cache game)]\\n  (animation (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                   \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                 (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                 (frame (\:pistol-idle tex-cache) 0.1)] false)))" "(frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                   \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                 (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                 (frame (\:pistol-idle tex-cache) 0.1)] false)" "(let [tex-cache (\:tex-cache game)]\\n  (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                   \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                 (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                 (frame (\:pistol-idle tex-cache) 0.1)] false))" "(defn frames [& args]\\r\\n\\t\\"name of frames, frames, loop?\\r\\n\\t ex.\\r\\n\\t \:name1 [f f f] true \:name2 [f f] false \:name 3 f true\\"\\r\\n (let [mapped (map (fn [name-frame]\\r\\n                     {(first name-frame) \\r\\n                      {\:frame-duration (let [second-item (second name-frame)]\\r\\n\\t                                       (if (vector? second-item) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                         second-item \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                         (vector second-item)))\\r\\n                       \:loop? (nth name-frame 2)}})\\r\\n                   (partition 3 args))]\\r\\n (reduce conj mapped)))" "(ns basic-combat-ai.components)" "(defn frames [& args]\\r\\n\\t\\"name of frames, frames, loop?\\r\\n\\t ex.\\r\\n\\t \:name1 [f f f] true \:name2 [f f] false \:name 3 f true\\"\\r\\n (let [mapped (map (fn [name-frame]\\r\\n                     {(first name-frame) \\r\\n                      {\:frame-duration (let [second-item (second name-frame)]\\r\\n\\t                                       (if (vector? second-item) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                         second-item \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t                         (vector second-item)))\\r\\n                       \:loop? (nth name-frame 2)}})\\r\\n                   (partition 3 args))]\\r\\n (reduce conj mapped)))" "(let [tex-cache (\:tex-cache game)]\\r\\n     (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                      \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                    (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                    (frame (\:pistol-idle tex-cache) 0.1)] false))" "(ns basic-combat-ai.main-screen)" "(let [tex-cache (\:tex-cache game)]\\r\\n     (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                      \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                    (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                    (frame (\:pistol-idle tex-cache) 0.1)] false))" "(keys (let [tex-cache (\:tex-cache game)]\\r\\n     (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                      \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                    (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                    (frame (\:pistol-idle tex-cache) 0.1)] false)))" "(keys (\:fire-pistol(let [tex-cache (\:tex-cache game)]\\r\\n     (frames \:pistol-idle (frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                      \:fire-pistol [(frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                    (frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                    (frame (\:pistol-idle tex-cache) 0.1)] false))))" "(let [ents (get-in game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:animation %) ents)\\n      delta 0.05]\\n  (map (fn [e] \\n         (if-not (get-in e [\:animation \:current-animation])\\n           e\\n           (let [current-duration (get-in e [\:animation \:current-duration])\\n                 current-frame (get-in e [\:animation \:current-frame])\\n                 current-animation (get-in e [\:animation \:current-animation])\\n                 current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n             (cond\\n               (> current-duration 0)\\n               (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n               (and (neg? current-duration) (< current-frame (count current-frames)))\\n               (-> e \\n                 (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                 (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n               ))))))" "(let [ents (get-in game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:animation %) ents)\\n      delta 0.05]\\n  (map (fn [e] \\n         (if-not (get-in e [\:animation \:current-animation])\\n           e\\n           (let [current-duration (get-in e [\:animation \:current-duration])\\n                 current-frame (get-in e [\:animation \:current-frame])\\n                 current-animation (get-in e [\:animation \:current-animation])\\n                 current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n             (cond\\n               (> current-duration 0)\\n               (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n               (and (neg? current-duration) (< current-frame (count current-frames)))\\n               (-> e \\n                 (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                 (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n               ))))\\n       ents))" "game" "(use 'basic-combat-ai.components \:reload)" "(use 'basic-combat-ai.entities \:reload)" "game" "(require 'basic-combat-ai.main-screen \:reload-all)" "(require 'basic-combat-ai.components \:reload-all)" "(require 'basic-combat-ai.entities \:reload-all)" "(require 'basic-combat-ai.main-screen \:reload-all)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "(get-in game [\:ecs \:entites 0 \:animation])" "(get-in game [\:ecs \:entites 0])" "(get-in game [\:ecs \:entites])" "game" "(\:ecs game)" "(get-in game [\:ecs \:entities])" "(get-in game [\:ecs \:entities 0 \:animation])" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation])\\n  (keys))" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation])\\n  (\:pistol-fire))" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation]))" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation])\\n  (keys))" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation])\\n  (\:fire-pistol))" "(-> \\n  (get-in game [\:ecs \:entities 0 \:animation])\\n  )" "(-> \\n  (get-in game [\:ecs \:entities 0])\\n  )" "(-> \\n  (get-in game [\:ecs \:entities 0])\\n  (keys))" "(require 'basic-combat-ai.main-screen \:reload-all)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "(let [ents (get-in game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:animation %) ents)\\n      delta 0.05]\\n  (map (fn [e] \\n         (if-not (get-in e [\:animation \:current-animation])\\n           e\\n           (let [current-duration (get-in e [\:animation \:current-duration])\\n                 current-frame (get-in e [\:animation \:current-frame])\\n                 current-animation (get-in e [\:animation \:current-animation])\\n                 current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n             (cond\\n               (> current-duration 0)\\n               (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n               (and (neg? current-duration) (< current-frame (count current-frames)))\\n               (-> e \\n                 (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                 (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n               ))))))" "(let [ents (get-in game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:animation %) ents)\\n      delta 0.05]\\n  (map (fn [e] \\n         (if-not (get-in e [\:animation \:current-animation])\\n           e\\n           (let [current-duration (get-in e [\:animation \:current-duration])\\n                 current-frame (get-in e [\:animation \:current-frame])\\n                 current-animation (get-in e [\:animation \:current-animation])\\n                 current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n             (cond\\n               (> current-duration 0)\\n               (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n               (and (neg? current-duration) (< current-frame (count current-frames)))\\n               (-> e \\n                 (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                 (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n               ))))\\n       ents))" "(defn animate [{{\:entities entities} \:ecs delta \:delta \:as game}]\\n  (let [qualifying-ents (filter \#(\:animation %) ents)\\n        rest-ents (filter \#(not (\:animation %)) ents)]  \\n    (map (fn [e] \\n           (if-not (get-in e [\:animation \:current-animation])\\n             e\\n             (let [current-duration (get-in e [\:animation \:current-duration])\\n                   current-frame (get-in e [\:animation \:current-frame])\\n                   current-animation (get-in e [\:animation \:current-animation])\\n                   current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n               (cond\\n                 (> current-duration 0)\\n                 (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n                 (and (neg? current-duration) (< current-frame (count current-frames)))\\n                 (-> e \\n                   (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                   (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n                 ))))\\n         qualifying-ents)))" "(defn animate [{{entities \:entities} \:ecs delta \:delta \:as game}]\\n  (let [qualifying-ents (filter \#(\:animation %) ents)\\n        rest-ents (filter \#(not (\:animation %)) ents)]  \\n    (map (fn [e] \\n           (if-not (get-in e [\:animation \:current-animation])\\n             e\\n             (let [current-duration (get-in e [\:animation \:current-duration])\\n                   current-frame (get-in e [\:animation \:current-frame])\\n                   current-animation (get-in e [\:animation \:current-animation])\\n                   current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n               (cond\\n                 (> current-duration 0)\\n                 (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n                 (and (neg? current-duration) (< current-frame (count current-frames)))\\n                 (-> e \\n                   (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                   (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n                 ))))\\n         qualifying-ents)))" "(defn animate [{{ents \:entities} \:ecs delta \:delta \:as game}]\\n  (let [qualifying-ents (filter \#(\:animation %) ents)\\n        rest-ents (filter \#(not (\:animation %)) ents)]  \\n    (map (fn [e] \\n           (if-not (get-in e [\:animation \:current-animation])\\n             e\\n             (let [current-duration (get-in e [\:animation \:current-duration])\\n                   current-frame (get-in e [\:animation \:current-frame])\\n                   current-animation (get-in e [\:animation \:current-animation])\\n                   current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n               (cond\\n                 (> current-duration 0)\\n                 (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\n               \\n                 (and (neg? current-duration) (< current-frame (count current-frames)))\\n                 (-> e \\n                   (assoc-in [\:animation \:current-frame] (inc current-frame))\\n                   (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\n                 ))))\\n         qualifying-ents)))" "(ns basic-combat-ai.systems)" "(def g {\:ecs {\:entities []} \:delta 0.1})" "g" "(def g {\:ecs {\:entities [{}\\n                         ]} \:delta 0.1})" "(animate g)" "(def g {\:ecs {\:entities [{\:transform {\:x 0.0 \:y 1.0}}\\n                         ]} \:delta 0.1})" "(animate g)" "g" "(get-in {} [\:test])" "(def g {\:ecs {\:entities [{\:animation {\:current-animation nil}\\n                          }\\n                         ]} \:delta 0.1})" "(animate g)" "(def g {\:ecs {\:entities [(pistoleer nil)\\n                         ]} \:delta 0.1})" "(ns basic-combat-ai.main-screen)" "game" "(pistoleer nil)" "(ent/pistoleer nil)" "(use 'clojure.test)" "(defn animate [{{ents \:entities} \:ecs delta \:delta \:as game}]\\r\\n     (let [qualifying-ents (filterv \#(\:animation %) ents)\\r\\n           rest-ents (filterv \#(not (\:animation %)) ents)\\n           modified-ents (mapv (fn [e] \\r\\n                                (if-not (get-in e [\:animation \:current-animation])\\r\\n                                  e\\r\\n                                  (let [current-duration (get-in e [\:animation \:current-duration])\\r\\n                                        current-frame (get-in e [\:animation \:current-frame])\\r\\n                                        current-animation (get-in e [\:animation \:current-animation])\\r\\n                                        current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\r\\n                                    (cond\\r\\n                                      (> current-duration 0)\\r\\n                                      (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\r\\n                                      \\r\\n                                      (and (neg? current-duration) (< current-frame (count current-frames)))\\r\\n                                      (-> e \\r\\n                                        (assoc-in [\:animation \:current-frame] (inc current-frame))\\r\\n                                        (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\r\\n                                      ))))\\r\\n                              qualifying-ents)]\\n       (into modified-ents rest-ents)))" "game" "(keys (get-in [\:ecs \:entities 0]))" "(keys (get-in game [\:ecs \:entities 0]))" "(keys (get-in game [\:ecs \:entities 0 \:animation]))" "(let [p (ent/pistoleer game)])" "(let [p (ent/pistoleer game)]\\n  p)" "(let [p (ent/pistoleer game)]\\n  (animate {\:ecs {entities [p]}}))" "(let [p (ent/pistoleer game)]\\n  (animate {\:ecs {\:entities [p]}}))" "(let [p (ent/pistoleer game)]\\n  (\= p (animate {\:ecs {\:entities [p]}})))" "(let [p (ent/pistoleer game)]\\n  (diff p (animate {\:ecs {\:entities [p]}})))" "(use 'clojure.data)" "(let [p (ent/pistoleer game)]\\n  (diff p (animate {\:ecs {\:entities [p]}})))" "(let [p (ent/pistoleer game)]\\n  (diff p p))" "(let [p (ent/pistoleer game)]\\n  (diff p (animate {\:ecs {\:entities [p]}})))" "(let [p (ent/pistoleer game)]\\n  (animate {\:ecs {\:entities [p]}}))" "(let [p (ent/pistoleer game)]\\n  (diff [p] (animate {\:ecs {\:entities [p]}})))" "(let [p (ent/pistoleer game)]\\n  (diff p \\n        (first (animate {\:ecs {\:entities [p]}}))))" "(deftest no-current-animation\\n  (let [p (ent/pistoleer game)]\\n    (\= p \\n       (first (animate {\:ecs {\:entities [p]}})))))" "(use 'clojure.test)" "(run-tests)" "(deftest no-current-animation\\n  (let [p (ent/pistoleer game)]\\n    (is (\= p \\n           (first (animate {\:ecs {\:entities [p]}}))))))" "(run-tests)" "(deftest no-current-animation\\n  \\"\\"\\n  (let [p (ent/pistoleer game)]\\n    (is (\= p \\n           (first (animate {\:ecs {\:entities [p]}}))))))" "(run-tests)" "(deftest no-current-animation\\n  \\"\\"\\n  (let [p (ent/pistoleer game)]\\n    (is (not\= p \\n           (first (animate {\:ecs {\:entities [p]}}))))))" "(run-tests)" "(deftest no-current-animation\\n  \\"no changes should occur if an entity does not have a current animation\\"\\n  (let [p (ent/pistoleer game)]\\n    (is (\= p \\n           (first (animate {\:ecs {\:entities [p]}}))))))" "(let [p (assoc-in (ent/pistoleer game) [\:animation \:current-animation] \:pistol-idle)]\\r\\n    (first (animate {\:ecs {\:entities [p]}})))" "(let [p (assoc-in (ent/pistoleer game) [\:animation \:current-animation] \:pistol-idle)]\\r\\n    (first (animate {\:ecs {\:entities [p]}}))\\n    p)" "(defn animate [{{ents \:entities} \:ecs delta \:delta \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:animation %) ents)\\r\\n           rest-ents (filter \#(not (\:animation %)) ents)]  \\r\\n       (map (fn [e] \\r\\n              (if-not (get-in e [\:animation \:current-animation])\\r\\n                e\\r\\n                (let [current-duration (get-in e [\:animation \:current-duration])\\r\\n                      current-frame (get-in e [\:animation \:current-frame])\\r\\n                      current-animation (get-in e [\:animation \:current-animation])\\r\\n                      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\r\\n                  (cond\\r\\n                    (neg? current-frame)\\r\\n                    (-> e \\r\\n                      (assoc-in [\:animation \:current-frame] 0)\\r\\n                      (assoc-in [\:animation \:current-duration] (get-in e [\:animation \:frames current-animation \:frame-duration 0 \:duration]) \\r\\n                    \\r\\n                    (> current-duration 0)\\r\\n                    (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\r\\n                  \\r\\n                    (and (neg? current-duration) (< current-frame (count current-frames)))\\r\\n                    (-> e \\r\\n                      (assoc-in [\:animation \:current-frame] (inc current-frame))\\r\\n                      (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\r\\n                    ))))\\r\\n            qualifying-ents)))" "(defn animate [{{ents \:entities} \:ecs delta \:delta \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:animation %) ents)\\r\\n           rest-ents (filter \#(not (\:animation %)) ents)]  \\r\\n       (map (fn [e] \\r\\n              (if-not (get-in e [\:animation \:current-animation])\\r\\n                e\\r\\n                (let [current-duration (get-in e [\:animation \:current-duration])\\r\\n                      current-frame (get-in e [\:animation \:current-frame])\\r\\n                      current-animation (get-in e [\:animation \:current-animation])\\r\\n                      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\r\\n                  (cond\\r\\n                    (neg? current-frame)\\r\\n                    (-> e \\r\\n                      (assoc-in [\:animation \:current-frame] 0)\\r\\n                      (assoc-in [\:animation \:current-duration] (get-in e [\:animation \:frames current-animation \:frame-duration 0 \:duration])))\\r\\n                    \\r\\n                    (> current-duration 0)\\r\\n                    (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\r\\n                  \\r\\n                    (and (neg? current-duration) (< current-frame (count current-frames)))\\r\\n                    (-> e \\r\\n                      (assoc-in [\:animation \:current-frame] (inc current-frame))\\r\\n                      (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame)))))\\r\\n                    ))))\\r\\n            qualifying-ents)))" "(let [p (assoc-in (ent/pistoleer game) [\:animation \:current-animation] \:pistol-idle)]\\r\\n    (first (animate {\:ecs {\:entities [p]}}))\\n    p)" "(let [p (assoc-in (ent/pistoleer game) [\:animation \:current-animation] \:pistol-idle)]\\r\\n    (first (animate {\:ecs {\:entities [p]}})))" "(ns basic-combat-ai.main-screen)" "game" "(get-in game [\:ecs \:entities 0 \:animation \:frames \:pistol-idle])" "(get-in game [\:ecs \:entities 0 \:animation \:current-frame])" "(get-in game [\:ecs \:entities 0 \:animation \:current-frames])" "(get-in game [\:ecs \:entities 0 \:animation \:frames])" "(get-in game [\:ecs \:entities 0 \:animation \:frames \:pistol-idle])" "(get-in game [\:ecs \:entities 0 \:animation \:frames \:pistol-idle \:frame-duration])" "(get-in game [\:ecs \:entities 0 \:animation \:frames \:pistol-idle])" "(get-in game [\:ecs \:entities 0 \:animation])" "(get-in game [\:ecs \:entities 0 \:animation \:current-frame])" "(get-in game [\:ecs \:entities 0 \:animation \:frames \:pistol-idle \:loop?])" "(ns basic-combat-ai.systems-test)" "(use 'clojure.test)" "(run-tests)" "(run-all-tests)" "(run-test)" "(use 'clojure.test)" "(run-tests)" "(ns core-test)" "(use 'clojure.test)" "(run-test)" "(run-tests)" "(in-ns systems-test)" "(in-ns 'basic-combat-ai.systems-test)" "(run-tests)" "(run-tests 'basic-combat-ai.systems-test)" "(use 'basic-combat-ai.systems-test \:reload-all)" "(use 'basic-combat-ai.systems \:reload)" "(use 'basic-combat-ai.systems-test \:reload-all)" "(use 'basic-combat-ai.systems-test \:reload)" "(use 'basic-combat-ai.systems-test \:reload-all)" "(run-tests 'basic-combat-ai.systems-test)" "(use 'clojure.repl)" "(source run-tests)" "(deftest no-current-animation\\r\\n     \\"no changes should occur if an entity does not have a current animation\\"\\r\\n     (let [p (ent/pistoleer nil)]\\r\\n       (is (\= p \\r\\n              (first (animate {\:ecs {\:entities [p]}}))))))" "(run-tests 'basic-combat-ai.systems_test)" "(ns 'basic-combat-ai.systems)" "(ns basic-combat-ai.systems)" "(ns basic-combat-ai.systems_test)" "(ent/pistoleer nil)" "\\n  (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate p))" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs \:entities [p]}))" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs {\:entities [p]}}))" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs {\:entities []}\\n            }))" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs {\:entities [nil]}\\n            }))" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs {\:entities [p]}\\n            }))" "(use clojure.stacktrace)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(let [p (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)]\\n  (animate {\:ecs {\:entities [p]}\\n            }))" "(print-stack-trace *e)" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  )" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  [current-duration current-frame-num current-animation current-frames])" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (set-current-frame-num e 0))" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (assoc-in [\:animation \:current-duration] (\:duration (first (current-frames)))))" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (assoc-in e [\:animation \:current-duration] (\:duration (first (current-frames)))))" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (assoc-in e [\:animation \:current-duration] (\:duration (first current-frames))))" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])\\n      fake-game {\:ecs {\:entities [e]}}]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (animate fake-game))" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])\\n      fake-game {\:ecs {\:entities [e]}}]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (animate fake-game))" "(let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\n      current-duration (get-in e [\:animation \:current-duration])\\r\\n      current-frame-num (get-in e [\:animation \:current-frame])\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])\\n      fake-game {\:ecs {\:entities [e]}}\\n      animated-e (first (animate fake-game))]\\n  [current-duration current-frame-num current-animation current-frames]\\n  (and (zero? (get-in animated-e [\:animation \:current-frame])) \\n       (\=\= (get-in animated-e [\:animation \:current-duration]) (\:duration (first current-frames)))))" "(deftest start-the-animation\\n  \\"Given an animation that has not been started, well uh, START IT.\\"\\n  (let [e (assoc-in (ent/pistoleer nil) [\:animation \:current-animation] \:pistol-idle)\\r\\n      current-animation (get-in e [\:animation \:current-animation])\\r\\n      current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])\\n        mock-game {\:ecs {\:entities [e]}}\\n        animated-e (first (animate mock-game))]\\n    (is (and (zero? (get-in animated-e [\:animation \:current-frame])) \\n             (\=\= (get-in animated-e [\:animation \:current-duration]) (\:duration (first current-frames)))))))" "(run-tests)" "(deftest continue-running-animation\\n  \\"If an animation is running and still has duration left, subtract delta from the duration\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:pistol-idle)\\n            (assoc-in [\:animation \:current-frame] 0)\\n            (assoc-in [\:animation \:current-duration] 1))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.01}\\n        animated-e (first (animate mock-game))]\\n    (is (\= (get-in animated-e [\:animation \:current-duration]) 0.9))))" "(run-tests)" "(deftest continue-running-animation\\n  \\"If an animation is running and still has duration left, subtract delta from the duration\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:pistol-idle)\\n            (assoc-in [\:animation \:current-frame] 0)\\n            (assoc-in [\:animation \:current-duration] 1))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (\= (get-in animated-e [\:animation \:current-duration]) 0.9))))" "(run-tests)" "(deftest set-to-next-frame\\n  \\"If the duration has run out and there are more frames in the animation, then update renderable and set the current frame/duration.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc-in [\:animation \:current-frame] 0)\\n            (assoc-in [\:animation \:current-duration] -0.1))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (\= 1 (get-in animated-e [\:animation \:current-frame]))\\n        (pos? (get-in animated-e [\:animation \:current-duration])))))" "(run-tests)" "(deftest loop-when-last-frame-done\\n  \\"If an animation has finished running the last frame and it supposed to loop, start back at the first frame.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc-in [\:animation \:current-frame] 2)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (zero? (get-in animated-e [\:animation \:current-frame])))\\n    (is (pos? (get-in animated-e [\:animation \:current-duration])))\\n    ))" "(run-tests)" "(deftest loop-when-last-frame-done\\n  \\"If an animation has finished running the last frame and it supposed to loop, start back at the first frame.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc-in [\:animation \:current-frame] 2)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (zero? (get-in animated-e [\:animation \:current-frame])))\\n    \\n    ))" "(run-tests)" "(deftest loop-when-last-frame-done\\n  \\"If an animation has finished running the last frame and it supposed to loop, start back at the first frame.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc-in [\:animation \:current-frame] 2)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    animated-e\\n    ))" "(run-tests)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems \:reload)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc \:renderable \\"\\")\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(use 'basic-combat-ai.systems_test \:reload-all)" "(let [e (-> (ent/pistoleer nil)\\n          (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n          (assoc \:renderable \\"\\")\\n          (assoc-in [\:animation \:current-frame] 2)\\n          (assoc-in [\:animation \:current-duration] -1.0))\\n      mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n      animated-e (first (animate mock-game))]\\n  animated-e\\n  )" "(deftest loop-when-last-frame-done\\n  \\"If an animation has finished running the last frame and it supposed to loop, start back at the first frame.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc \:renderable \\"\\")\\n            (assoc-in [\:animation \:frames \:fire-pistol \:loop?] true)\\n            (assoc-in [\:animation \:current-frame] 2)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (zero? (get-in animated-e [\:animation \:current-frame])))\\n    (is (pos? (get-in animated-e [\:animation \:current-duration])))\\n    ))" "(run-tests)" "(let [e (-> (ent/pistoleer nil)\\r\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n            (assoc \:renderable \\"\\")\\r\\n            (assoc-in [\:animation \:frames \:fire-pistol \:loop?] true)\\r\\n            (assoc-in [\:animation \:current-frame] 2)\\r\\n            (assoc-in [\:animation \:current-duration] -1.0))\\r\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\r\\n        animated-e (first (animate mock-game))]\\n  e)" "(use 'clojure.repl)" "(source set-to-next-frame)" "set-to-next-frame" "(deftest set-to-next-frame\\n  \\"When a frame has finished running but there are still more frames in the animation, set shit to the next frame.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc \:renderable \\"\\")\\n            (assoc-in [\:animation \:current-frame] 0)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        mock-game {\:ecs {\:entities [e]} \:delta 0.1}\\n        animated-e (first (animate mock-game))]\\n    (is (\= 1 (get-in animated-e [\:animation \:current-frame])))\\n    (is (pos? (get-in animated-e [\:animation \:current-duration])))\\n    ))" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(deftest return-vector-of-all-entities\\n  \\"All entities, whether they were modified or not, are returned.\\"\\n  (let [e (-> (ent/pistoleer nil)\\n            (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n            (assoc \:renderable \\"\\")\\n            (assoc-in [\:animation \:current-frame] 0)\\n            (assoc-in [\:animation \:current-duration] -1.0))\\n        not-qualified-e {}\\n        mock-game {\:ecs {\:entities [e not-qualified-e]} \:delta 0.1}\\n        entities (animate mock-game)]\\n    (is (\= 2 (count entities)))))" "(run-tests)" "(some \#({\:hi \\"hi\\"} [{\:hi \\"hi\\"}]))" "(some \#{\:hi \\"hi\\"} [{\:hi \\"hi\\"}])" "(some \#{{\:hi \\"hi\\"}} [{\:hi \\"hi\\"}])" "(some \#{{\:hi \\"hi\\"}} [{}])" "(some \#{{\:hi \\"hi\\"} {\:a \\"a\\"}} [{\:hi \\"hi\\"} {\:a \\"a\\"}])" "(every? \#{{\:hi \\"hi\\"} {\:a \\"a\\"}} [{\:hi \\"hi\\"} {\:a \\"a\\"}])" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(use 'basic-combat-ai.systems_test \:reload-all)" "(run-tests)" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "(ns 'basic-combat-ai.main-screen)" "(ns basic-combat-ai.main-screen)" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:fire-pistol))" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:fire-pistol))" "(ns basic-combat-ai.tile-map)" "(use 'basic-combat-ai.tile-map \:reload)" "(ns basic-combat-ai.main-screen)" "(use 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "game" "(tile-map/create-grid 3 3 (\:tex-cache game))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 10 10 (\:tex-cache game))))" "(keys game)" "(defn r []\\n  (use 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "r" "(r)" "(\:tile-map game)" "game" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 10 10 (\:tex-cache game))))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 10 10 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 30 30 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 20 20 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 22 20 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 24 20 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 25 20 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 25 19 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 25 18 (\:tex-cache game))))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 25 19 (\:tex-cache game))))" "(update-game\! \#(-> game \\n                 (assoc-in game [\:ecs \:entities 0 \:transform \:x 0])\\n                 (assoc-in game [\:ecs \:entities 0 \:transform \:y 0])))" "(update-game\! \#(-> % \\n                 (assoc-in [\:ecs \:entities 0 \:transform \:x 0])\\n                 (assoc-in [\:ecs \:entities 0 \:transform \:y 0])))" "(update-game\! \#(-> % \\n                 (assoc-in [\:ecs \:entities 0 \:transform \:x] 0)\\n                 (assoc-in [\:ecs \:entities 0 \:transform \:y] 0)))" "(defn r []\\n  (use 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(r)" "fps" "last-fps" "(update-game\! \#(-> % \\n                 (assoc-in [\:ecs \:entities 0 \:transform \:x] 0)\\n                 (assoc-in [\:ecs \:entities 0 \:transform \:y] 0)))" "(update-game\! \#(assoc % \:tile-map (tile-map/create-grid 25 19 (\:tex-cache game))))" "last-fps" "(r)" "(count (get-in game [\:ecs \:entities]))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "(count (get-in game [\:ecs \:entities]))" "(r)" "time" "(time)" "(r)" "(to-array [1 2 3])" "(floats (to-array [1 2 3]))" "(floats 1)" "(floats (float 1.0))" "(into-array Float [1 2 3])" "(into-array Float [1.0])" "(into-array Float [(float 1.0)])" "(float-array [1 2 3])" "(type (float-array [1 2 3]))" "(class (float-array [1 2 3]))" "(count (float-array [1 2 3]))" "(ns basic-combat-ai.math-utils)" "(convex-polygon-intersect?)" "(r)" "(use 'basic-combat-ai.math-utils \:reload)" "(convex-polygon-intersect?)" "(ns basic-combat-ai.main-screen)" ";final double deltaY \= (p1.y - p2.y);\\r\\n;    final double deltaX \= (p2.x - p1.x);\\r\\n;    final double result \= Math.toDegrees(Math.atan2(deltaY, deltaX));" "(defn angle-of [p1 p2]  \\n  (Math/atan2 (- (second p1) (second p2))\\n              (- (first p1) (first p2))))" "(angle-of [0 0] [32 32])" "(defn angle-of [p1 p2]  \\n  (Math/toDegrees \\n    (Math/atan2 (- (second p1) (second p2))\\n                (- (first p1) (first p2)))))" "(angle-of [0 0] [32 32])" "(- 360 135)" "(* 45 3)" "(* 45 4)" "(* 45 5)" "(angle-of [32 32] [0 0])" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p2) (second p1))\\r\\n        delta-x (- (first p2) (first p1))\\r\\n        radians (Math/atan2 delta-y delta-x)]\\r\\n     (Math/toDegrees radians)))" "(angle-of [32 32] [0 0])" "(angle-of [0 0] [32 32])" "(360 - 135)" "(- 360 135)" "(- -135 360)" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p2) (second p1))\\r\\n        delta-x (- (first p2) (first p1))\\r\\n        radians (Math/atan2 delta-y delta-x)]\\r\\n     (Math/toDegrees radians)))" "(angle-of [0 0] [32 32])" "(angle-of [32 32] [0 0])" "(defn- bound-to-360 [angle]\\r\\n  (if (neg? angle)\\r\\n    (+ 360 angle)\\r\\n    angle))" "(bound-to-360 -135)" "(ns basic-combat-ai.main-screen)" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation]" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p2) (second p1))\\r\\n        delta-x (- (first p2) (first p1))\\r\\n        radians (Math/atan2 delta-y delta-x)\\r\\n        degrees (Math/toDegrees radians)\\r\\n        bound-0-360 (if (neg? angle) (+ 360 angle) angle)]\\r\\n     bound-0-360))" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p2) (second p1))\\r\\n        delta-x (- (first p2) (first p1))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees)]\\r\\n     bound-0-360))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] (angle-of p1 p2))))" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p1) (second p2))\\r\\n        delta-x (- (first p1) (first p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees)]\\r\\n     bound-0-360))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] (angle-of p1 p2))))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0)))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 45)))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 45)))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 45)))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] (angle-of p1 p2))))" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\n                     p1 [(\:x (\:transform (first ents)))\\n                         (\:y (\:transform (first ents)))]\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]]\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] (angle-of p1 p2))\\n                 (println (angle-of p1 p2))\\n                 ))" "(get-in game [\:ecs \:entities])" "game" "(basic-combat-ai.desktop-launcher/reset)" "(let [ents (get-in game [\:ecs \:entities])\\r\\n      p1 [(\:x (\:transform (first ents)))\\r\\n          (\:y (\:transform (first ents)))]\\r\\n      p2 [(\:x (\:transform (second ents)))\\r\\n          (\:y (\:transform (second ents)))]\\n      angle (angle-of p1 p2)]\\r\\n  ;(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] angle)\\r\\n  angle)" "(let [ents (get-in game [\:ecs \:entities])\\r\\n      p1 [(\:x (\:transform (first ents)))\\r\\n          (\:y (\:transform (first ents)))]\\r\\n      p2 [(\:x (\:transform (second ents)))\\r\\n          (\:y (\:transform (second ents)))]\\n      angle (angle-of p2 p1)]\\r\\n  ;(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] angle)\\r\\n  angle)" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p2) (second p1))\\r\\n        delta-x (- (first p2) (first p1))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees)]\\r\\n     bound-0-360))" "(let [ents (get-in game [\:ecs \:entities])\\r\\n      p1 [(\:x (\:transform (first ents)))\\r\\n          (\:y (\:transform (first ents)))]\\r\\n      p2 [(\:x (\:transform (second ents)))\\r\\n          (\:y (\:transform (second ents)))]\\n      angle (angle-of p2 p1)]\\r\\n  ;(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] angle)\\r\\n  angle)" "(defn angle-of [p1 p2]\\r\\n  (let [delta-y (- (second p1) (second p2))\\r\\n        delta-x (- (first p1) (first p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees)]\\r\\n     bound-0-360))" "(let [ents (get-in game [\:ecs \:entities])\\r\\n      p1 [(\:x (\:transform (first ents)))\\r\\n          (\:y (\:transform (first ents)))]\\r\\n      p2 [(\:x (\:transform (second ents)))\\r\\n          (\:y (\:transform (second ents)))]\\n      angle (angle-of p2 p1)]\\r\\n  ;(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] angle)\\r\\n  angle)" "(update-game\! \#(let [ents (get-in % [\:ecs \:entities])\\r\\n                     p1 [(\:x (\:transform (first ents)))\\r\\n                         (\:y (\:transform (first ents)))]\\r\\n                     p2 [(\:x (\:transform (second ents)))\\r\\n                         (\:y (\:transform (second ents)))]\\n                     angle (angle-of p2 p1)]\\r\\n                 (assoc-in % [\:ecs \:entities 0 \:transform \:rotation] angle)))" "(get-in game [\:ecs \:entities])" "(keys (get-in game [\:ecs \:entities]))" "(get-in game [\:ecs \:entities])" "(keys (first (get-in game [\:ecs \:entities])))" "(map \#(\:id %) (get-in game [\:ecs \:entities]))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(ns basic-combat-ai.components)" "(require 'basic-combat-ai.main-screen \:reload-all)" "(collider 1 2 3 4 [0])" "(collider \\"Hu\\" 1 2 3 4 [0])" "(require 'basic-combat-ai.main-screen \:reload-all)" "(collider \\"Hu\\" 1 2 3 4 [0])" "(ns basic-combat-ai.main-screen)" "(ns basic-combat-ai.behavior-tree)"]
eclipse.preferences.version=1
