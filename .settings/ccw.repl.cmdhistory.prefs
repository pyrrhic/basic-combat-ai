cmdhistory=["(use 'clojure.repl)" "(source bt/->Selector)" "(-> (bt/->Selector. \:fresh [] [(FindPath. \:fresh [])] 0))" "(bt/->Selector. \:fresh [] [(FindPath. \:fresh [])] 0)" "(bt/Selector. \:fresh [] [(FindPath. \:fresh [])] 0)" "(bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\n  (bt/update-node (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) e main-screen/game))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" " (let [start-tile (tile-map/get-tile (\:x (\:transform main-ent)) (\:y (\:transform main-ent)) (\:tile-map game))\\r\\n          target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) (\:tile-map game))\\r\\n          path (astar/calc-path start-tile target-tile (\:tile-map game))])" "(let [main-ent (get-in main-screen/game [\:ecs \:entities 0])\\n      game main-screen/game\\n      start-tile (tile-map/get-tile (\:x (\:transform main-ent)) (\:y (\:transform main-ent)) (\:tile-map game))\\r\\n      target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) (\:tile-map game))\\r\\n      path (astar/calc-path start-tile target-tile (\:tile-map game))])" "(let [main-ent (get-in main-screen/game [\:ecs \:entities 0])\\n      game main-screen/game\\n      start-tile (tile-map/get-tile (\:x (\:transform main-ent)) (\:y (\:transform main-ent)) (\:tile-map game))\\r\\n      target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) (\:tile-map game))\\r\\n      path (astar/calc-path start-tile target-tile (\:tile-map game))]\\n  path)" "(let [main-ent (get-in main-screen/game [\:ecs \:entities 0])\\n      game main-screen/game\\n      start-tile (tile-map/get-tile (\:x (\:transform main-ent)) (\:y (\:transform main-ent)) (\:tile-map game))\\r\\n      target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) (\:tile-map game))\\r\\n      path (astar/calc-path start-tile target-tile (\:tile-map game))]\\n  (type path))" "(let [main-ent (get-in main-screen/game [\:ecs \:entities 0])\\r\\n      game main-screen/game\\r\\n      start-tile (tile-map/get-tile (\:x (\:transform main-ent)) (\:y (\:transform main-ent)) (\:tile-map game))\\r\\n      target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) (\:tile-map game))\\r\\n      path (astar/calc-path start-tile target-tile (\:tile-map game))]\\r\\n  (seq? path))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" "(dissoc {\:t1 \:t2} \:t1)" "(dissoc {\:t1 \:t2})" "(dissoc {\:t1 \:t2} \:t2)" "(dissoc {\:a 1 \:b 2} \:a)" "(dissoc {\:a 1 \:b 2} \:a \:b)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" "(pos? 0)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\r\\n       (bt/update-node e main-screen/game)\\r\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n              (bt/update-node e main-screen/game)))" "(ns basic-combat-ai.behavior-tree)" "(update-ents [] [])" "(update-ents [{\:id 1}] [])" "(update-ents [{\:id 1}] [{\:id 2}])" "(update-ents [{\:id 1} {\:id 3}] [{\:id 2}])" "(update-ents [{\:id 2 \:hi \\"test\\"} {\:id 3}] [{\:id 2}])" "(update-ents [{\:id 2} {\:id 3}] [{\:id 2 \:hi \\"test\\"}])" "(ns basic-combat-ai.enemy-ai)" "(use 'clojure.repl)" "(doc assoc-in)" "(source assoc-in)" "(defrecord FollowPath [status return-ents]\\r\\n  bt/NodeBehavior\\r\\n  (bt/start [node main-ent game]\\r\\n    (assoc node \:status \:running))\\r\\n  (bt/run [node main-ent game]\\r\\n    (let [current-node (nth (get-in main-ent [\:path \:a-path]) (get-in main-ent [\:path \:curr-path-idx]))\\r\\n          updated-entity (-> main-ent \\r\\n                           (assoc-in [\:transform \:x] (\:x current-node))\\n                           (assoc-in [\:transform \:y] (\:y current-node)))]\\n      (assoc node\\n             \:return-ents [updated-entity]))))" "(ancestors FollowPath)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(keys (let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n             (bt/update-node e main-screen/game)\\n             (bt/update-node e main-screen/game)\\n             (bt/update-node e main-screen/game)\\n             (bt/update-node e main-screen/game)\\n             )))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(get-in main-screen/game [\:ecs \:entities \:path \:curr-path-idx])" "(require 'basic-combat-ai.main-screen \:reload-all)" "main-screen/game" "(basic-combat-ai.desktop-launcher/reset)" "main-screen/game" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       ))" "(comps/path nil)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(print-stack-trace *e)" "(main-screen/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 3 3)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       \\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       ))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       (bt/update-node e main-screen/game)\\n       \\n       ))" "(get-in (let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n       \\n               )) [\:children])" "(get-in (let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n       \\n               )) [\:children 1])" "(get-in (let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n     (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n       (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n               (bt/update-node e main-screen/game)\\n       \\n               )) [\:return-ents])" "(bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0)" "(get-in (let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n          (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n            (bt/update-node e main-screen/game))))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n    (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" "(let [e (get-in main-screen/game [\:ecs \:entities 0])]\\r\\n  (-> (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0) \\r\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)\\n    (bt/update-node e main-screen/game)))" "(defn simulate [root-node main-entity game]\\n  (let [updated-ent-list (bt/update-ents (get-in game [\:ecs \:entities]) (\:return-ents (bt/update-node root-node e main-screen/game)))]\\n    (get-in (main-screen/update-game\! \#(assoc-in % [\:ecs \:entities] updated-ent-list)) [\:ecs \:entities])\\n))" "(def root-node (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0))" "(main-screen/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree] (bt/->Selector \:fresh [] [(FindPath. \:fresh []) (FollowPath. \:fresh [])] 0)))" "(source bt/update-node)" "(let [updated-node (bt/update-node (get-in main-screen/game [\:ecs \:entities 0 \:behavior-tree \:tree])\\n                                   (get-in main-screen/game [\:ecs \:entities 0])\\n                                   main-screen.game)\\n      updated-entity (first (\:return-ents updated-node))]\\n  (main-screen/update-game\! \#(assoc-in % [\:ecs \:entities 0] updated-entity)))" "(let [updated-node (bt/update-node (get-in main-screen/game [\:ecs \:entities 0 \:behavior-tree \:tree])\\n                                   (get-in main-screen/game [\:ecs \:entities 0])\\n                                   main-screen/game)\\n      updated-entity (first (\:return-ents updated-node))]\\n  (main-screen/update-game\! \#(assoc-in % [\:ecs \:entities 0] updated-entity)))" "(ns basic-combat-ai.systems)" "(tick-behavior-tree {\:ecs {\:entities [{\:id 1 \:behavior-tree nil} {\:id 2 \:behavior-tree nil} {\:id 3}]}})" "\#(\:behavior-tree %)" "(filter-ents [{\:id 1 \:behavior-tree nil} {\:id 2 \:behavior-tree nil} {\:id 3}] \#(\:behavior-tree %))" "(filter-ents [{\:id 1 \:behavior-tree []} {\:id 2 \:behavior-tree []} {\:id 3}] \#(\:behavior-tree %))" "(tick-behavior-tree {\:ecs {\:entities [{\:id 1 \:behavior-tree nil} {\:id 2 \:behavior-tree nil} {\:id 3}]}})" "(tick-behavior-tree {\:ecs {\:entities [{\:id 1 \:behavior-tree []} {\:id 2 \:behavior-tree []} {\:id 3}]}})" "(use 'clojure.repl)" "(source bt/Selector)" "(source bt/->Selector)" "(bt/->Selector \:fresh [] [(enemy-ai/->HasMoveTo \:fresh [])\\n                          (enemy-ai/->FindPath \:fresh [])\\n                          (enemy-ai/->FollowPath \:fresh [])] 0)" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "(tick-behavior-tree {\:ecs {\:entities [{\:id 1} {\:id 2}]}})" "(require '[basic-combat-ai.main-screen \:as \:ms])" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick-behavior-tree {\:ecs {\:entities (get-in ms/game [\:ecs \:entities\:])}})" "(tick-behavior-tree {\:ecs {\:entities (get-in ms/game [\:ecs \:entities])}})" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(let [main-ent (get-in ms/game [\:ecs \:entitites 0])\\n      game ms/game]\\n  (bt/update-node (\:behavior-tree main-ent) main-ent (assoc-in game [\:ecs \:entities] all-ents)))" "(let [main-ent (get-in ms/game [\:ecs \:entitites 0])]\\n  (bt/update-node (\:behavior-tree main-ent) main-ent ms/game))" "(\:behavior-tree (get-in ms/game [\:ecs \:entities 0]))" "(bt/update-node (\:behavior-tree (get-in ms/game [\:ecs \:entities 0]) (get-in ms/game [\:ecs \:entities 0]) ms/game))" "(bt/update-node (\:behavior-tree (get-in ms/game [\:ecs \:entities 0])) (get-in ms/game [\:ecs \:entities 0]) ms/game)" "(tick-behavior-tree {\:ecs {\:entities (get-in ms/game [\:ecs \:entities])}})" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n)" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n)" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n)" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(\:tree (\:behavior-tree main-ent)))" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nq-ents)" "(let [q-ents (get-in ms/game [\:ecs \:entities 0])\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nmain-ent)" "(let [q-ents (into [] (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n)" "(let [q-ents (into [] (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nmain-ent)" "(let [q-ents (into [] (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nq-ents)" "(let [q-ents (into [] (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(first q-ents))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(first q-ents))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      ;updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nmain-ent)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)]\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nmain-ent)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nmain-ent)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))]\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n;      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n;      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n;      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nupdated-root)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(update-main-ent-bt updated-root))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(get-main-ent root-node))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(get-main-ent updated-root))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nudpated-root)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\nupdated-root)" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(assoc-in main-ent [\:behavior-tree \:tree] updated-root))" "(let [q-ents (vector (get-in ms/game [\:ecs \:entities 0]))\\n      all-ents (get-in ms/game [\:ecs \:entities])\\n      game ms/game\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) all-ents)\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))\\n(bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))" "(do \\n  (require 'basic-combat-ai \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(require 'basic-combat-ai.main-screen \:as ms)" "(require '[basic-combat-ai.main-screen \:as ms])" "ms/game" "(assoc-in ms/game [\:ecs \:entities 0 \:move-to] (comps/move-to 3 3))" ";(assoc-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree] )" "(require '[basic-combat-ai.behavior-tree \:as bt])" "(require '[basic-combat-ai.enemy-ai \:as enemy-ai])" "(assoc-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree] (comps/behavior-tree (bt/->Selector \:fresh [] [(enemy-ai/->HasMoveTo \:fresh [])\\r\\n                                                                                                         (enemy-ai/->FindPath \:fresh [])\\r\\n                                                                                                         (enemy-ai/->FollowPath \:fresh [])] 0)))" "(get-in ms/game [\:ecs \:entities])" "(assoc-in ms/game [\:ecs \:entities] (vector (get-in ms/game [\:ecs \:entities 0])))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (vector (get-in % [\:ecs \:entities 0]))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 3 3)))" "(ms/update-game\! \#(assoc-in % \\n                            [\:ecs \:entities 0 \:behavior-tree \:tree] \\n                            (comps/behavior-tree (bt/->Selector \:fresh [] [(enemy-ai/->HasMoveTo \:fresh [])\\r\\n                                                                           (enemy-ai/->FindPath \:fresh [])\\r\\n                                                                           (enemy-ai/->FollowPath \:fresh [])] 0))))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(dissoc % [\:ecs \:entities 1]))" "(update-game\! \#(assoc % [\:ecs \:entities] (vector (get-in % [\:ecs \:entities 0]))))" "(get-in game [\:ecs \:entities])" "(first (get-in game [\:ecs \:entities]))" "(second (get-in game [\:ecs \:entities]))" "(vector (get-in game1 [\:ecs \:entities 0]))" "(vector (get-in game [\:ecs \:entities 0]))" "(update-game\! \#(assoc % [\:ecs \:entities] (vector (get-in % [\:ecs \:entities 0]))))" "(let [g (update-game\! \#(assoc % [\:ecs \:entities] (vector (get-in % [\:ecs \:entities 0]))))\\n      ]\\n  (get-in g [\:ecs \:entities]))" "(update-game\! \#(assoc-in % [\:ecs \:entities 1] {\:id 123}))" "(assoc {} [\:a \:b \:c] a)" "(assoc {} [\:a \:b \:c] 1)" "(get-in game [\:ecs \:entities 0])" "(require '[basic-combat-ai.components \:as comps]\\n         '[basic-combat-ai.enemy-ai \:as enemy-ai]\\n         '[basic-combat-ai.behavior-tree \:as bt])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 3 3)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0 \:status] \:fresh))" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0 \:status])" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children])" "game" "(update-game\! \#(dissoc % [\:ecs \:entities]))" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 0 \:behavior-tree])" "(get-in game [\:ecs \:entities 0])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:status] \:fresh))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 3 \:y 3}))" "(let [main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  )\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  )" "(require '[basic-combat-ai.behavior-tree \:as bt])" "(let [main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  )" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  )" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  updated-root)" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (-> updated-root\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (-> updated-root\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    ))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (-> updated-root\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    ))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (-> updated-root\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    ))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (-> updated-root\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n    ))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (first (\:return-ents has-path))\\n  \\n  \\n  ))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    has-path\\n    ;(bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))\\n))" "(do\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "game" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (first (\:return-ents (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))))\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n  (let [has-path (-> updated-root\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\n                   )]\\n    (bt/update-node has-path\\n                    (first (\:return-ents (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))))\\n                    (assoc-in game [\:ecs \:entities] all-ents))\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [has-path (-> updated-root\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                   )]\\r\\n    (bt/update-node has-path\\r\\n                    (first (\:return-ents (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))))\\r\\n                    (assoc-in game [\:ecs \:entities] all-ents))\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [has-path (-> updated-root\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                   (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                   )]\\r\\n    (bt/update-node has-path (first (\:return-ents has-path)) (assoc-in game [\:ecs \:entities] all-ents))\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\r\\n    e-has-path\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\r\\n    root-has-path\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\r\\n    (\:return-ents root-has-path)\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\n    root-has-path\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\n    (bt/update-node root-has-path e-has-path game)\\r\\n))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  (let [root-has-path (-> updated-root\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;has path\\r\\n                        (bt/update-node main-ent (assoc-in game [\:ecs \:entities] all-ents)) ;set the follow to running\\r\\n                        )\\n        e-has-path (first (\:return-ents root-has-path))]\\n    (let [r (bt/update-node root-has-path e-has-path game)\\n          e (first (\:return-ents r))]\\n      (bt/update-node r e game))\\r\\n))" "(sys/tick-behavior-tree game)" "(update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %)))" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(get-in game [\:ecs \:entities])" "(keys (get-in game [\:ecs \:entities]))" "(count (get-in game [\:ecs \:entities]))" "(do\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n  update-main-ent-bt)" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n (update-main-ent-bt updated-root))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n (clear-return-ents updated-root))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n updated-root)" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n (assoc-in main-ent [\:behavior-tree \:tree] updated-root))" "(let [all-ents (get-in game [\:ecs \:entities])\\r\\n      main-ent (get-in game [\:ecs \:entities 0])\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\r\\n (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(do\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "game" "(sys/tick-behavior-tree game)" "(get-in (sys/tick-behavior-tree game) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "(count (sys/tick-behavior-tree game))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))])\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))])\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\nupdated-root)\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n(bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n(bt/update-ents all-ents []))\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n(assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root)))\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n(update-main-ent-bt updated-root))\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(let [q-ents (get-in game [\:ecs \:entities])\\n      all-ents (get-in game [\:ecs \:entities])\\n      main-ent (first q-ents)\\r\\n      updated-root (bt/update-node (\:tree (\:behavior-tree main-ent)) main-ent (assoc-in game [\:ecs \:entities] all-ents))\\r\\n      ;nothing in the nodes will put the BT back into the main-ent, because no node knows if it's the root, so we do it here.\\r\\n      ;also this is a function because we don't know if there are any return ents yet.\\r\\n      clear-return-ents (fn [root-node] (assoc root-node \:return-ents []))\\r\\n      get-main-ent (fn [root-node] (first (\:return-ents root-node)))\\r\\n      update-main-ent-bt (fn [root-node] (assoc-in (get-main-ent root-node) [\:behavior-tree \:tree] (clear-return-ents root-node)))]\\n(bt/update-ents all-ents [(update-main-ent-bt updated-root)]))\\n\\r\\n  ;for later--\\r\\n  ;if root comes back with success or fail, reset the whole tree then go through the tree.\\r\\n  ;if root comes back with running, go through the tree as if it were fresh. if land on an action node that is fresh, then need to cancel the old list of running nodes.\\r\\n;  (if (empty? (\:return-ents updated-root))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents [(assoc-in main-ent [\:behavior-tree \:tree] updated-root)]))\\r\\n;    (recur (rest q-ents) (bt/update-ents all-ents (assoc-in updated-root [\:return-ents 0] (update-main-ent-bt updated-root))))))" "(do\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(get-in game [\:ecs \:entities])" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(sys/tick-behavior-tree game)" "(count (sys/tick-behavior-tree game))" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities])" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn r []\\n  (do \\n    (require 'basic-combat-ai.main-screen \:reload-all)\\n    (basic-combat-ai.desktop-launcher/reset)))" "r" "(r)" "(nth [] 1)" "(nth [] 1 1)" "(nth [] 1 nil)" "(r)" "(defn e [game]\\n  (get-in game [\:ecs \:entities 0]))" "(e)" "(e ms/game)" "(require '[basic-combat-ai.systems \:as sys])" "(sys/tick-behavior-tree ms/game)" "(get-in (ms/update-game\! \#(sys/tick-behavior-tree %)) [\:ecs \:entities 0])" "(require '[basic-combat-ai.systems \:as sys])" "(defn r []\\r\\n  (do \\r\\n    (require 'basic-combat-ai.main-screen \:reload-all)\\r\\n    (basic-combat-ai.desktop-launcher/reset)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(sys/tick-behavior-tree ms/game)" "(ms/update-game\! \#(sys/tick-behavior-tree %))" "(app)" "(ns basic-combat-ai.main-screen)" "(defn r []\\r\\n     (do \\r\\n       (require 'basic-combat-ai.main-screen \:reload-all)\\r\\n       (basic-combat-ai.desktop-launcher/reset)))" "(r)" "(update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %)))" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0])" "(count (get-in game [\:ecs \:entities]))" "(\:transform (get-in game [\:ecs \:entities 0]))" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree])" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2])" "(sys/tick-behavior-tree game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(keys (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children])" "(get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:status])" "(\:status (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0]))" "(\:status (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 1]))" "(\:status (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2]))" "(\:status (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 3]))" "(ns basic-combat-ai.behavior-tree)" "(require '[basic-combat-ai.main-screen \:as ms])" "(selector-success? (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children]))" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children])" "(count (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children]))" "(selector-success? [(dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0]) \:children \:return-ents)\\n                    (dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 1]) \:children \:return-ents)\\n                    (dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2]) \:children \:return-ents)])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [(dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0]) \:children \:return-ents)\\r\\n                       (dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 1]) \:children \:return-ents)\\r\\n                       (dissoc (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2]) \:children \:return-ents)])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %)) \\r\\n              (\= \:success (\:status %1)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) \\r\\n              (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) (\= \:success (\:status %2)))\\r\\n          {\:status \:success}\\r\\n          [{\:status \:success} {\:status \:success}])" "(apply \:status [{\:status \:success} {\:status \:success} {\:status \:success}])" "(apply '\:status [{\:status \:success} {\:status \:success} {\:status \:success}])" "(apply \#(\:status %) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(map \#(\= \:success (\:status %)) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(ns basic-combat-ai.main-screen)" "(r)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0])" "(r)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0])" "and" "a" "game" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree])" "(sys/tick-behavior-tree game)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree])" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree \:status])" "(r)" "(get-in (update-game\! \#(assoc-in % [\:ecs \:entities] (sys/tick-behavior-tree %))) [\:ecs \:entities 0 \:behavior-tree \:tree \:status])" "(r)" "(defn face-towards [curr-x curr-y target-x target-y]\\n  (math-utils/angle-of [(* curr-x 32) (* curr-y 32)] [(* target-x 32) (* target-y 32)]))" "(face-towards 0 0 3 3 )" "(face-towards 0 0 3 3)" "(face-towards 3 3 0 0)" "(require 'basic-combat-ai.enemy-ai \:reload-all)" "(face-towards 3 3 0 0)" "(use clojure.repl)" "(use 'clojure.repl)" "(source math-utils/angle-of)" "(defn create-entity []\\n  (let [random-id (rand-int 0 1000000)]\\n    {\:id random-id}))" "(repeatedly create-entity)" "(defn create-entity []\\n  (let [random-id (rand-int 1000000)]\\n    {\:id random-id}))" "(repeatedly create-entity)" "(let [ents (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents] (if (\= id (\:id (first ents))) (first-ents) (recur (rest ents)))))]\\n  (find-ent 5))" "(let [ents (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents ents] (if (\= id (\:id (first ents))) (first-ents) (recur (rest ents)))))]\\n  (find-ent 5))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] (if (\= id (\:id (first ents))) (first ents) (recur (rest ents)))))]\\n  (find-ent 5))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))]\\n  (find-ent 5))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (nth 9999999))]\\n  (find-ent some-id))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (nth es 9999999))]\\n  (find-ent some-id))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (nth es 999999))]\\n  (find-ent some-id))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n]\\n  (nth es 999999))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n]\\n  (count es))" "(let [es (vector (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n]\\n  es)" "(rand-int 0 1000000)" "(rand-int 1000000)" "(rand-int 10)" "(rand-int 100)" "(let [es (into [] (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n]\\n  (count es))" "(let [es (into [] (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n]\\n  (time (count es)))" "(let [es (into [] (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (find-ent some-id))" "(let [es (into [] (repeatedly 1000000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(let [es (into [] (doall (repeatedly 1000000 create-entity)))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (find-ent some-id))" "(let [es (into [] (doall (repeatedly 1000000 create-entity)))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(let [es (into [] (doall (repeatedly 100000 create-entity)))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(let [es (into [] (repeatedly 100000 create-entity))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (if (\= id (\:id (first ents))) \\n                              (first ents) \\n                              (recur (rest ents))))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(let [es (into [] (doall (repeatedly 100000 create-entity)))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (recur (rest ents)))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(let [es (into [] (doall (repeatedly 10000 create-entity)))\\n      find-ent (fn [id] (loop [ents es] \\n                          (if (empty? ents)\\n                            \\"not found.\\"\\n                            (recur (rest ents)))))\\n      some-id (\:id (last es))]\\n  (time (find-ent some-id)))" "(ns basic-combat-ai.main-screen)" "fps" "last-fps" "(ns basic-combat-ai.desktop-launcher)" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (reset))" "(ns basic-combat-ai.main-screen)" "last-fps" "game" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "game" "(ns basic-combat-ai.main-screen)" "game" "(ns basic-combat-ai.main-screen)" "game" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "game" "(LwjglApplicationConfiguration.)" "(.foregroundFPS (LwjglApplicationConfiguration.) 100)" "(doto (LwjglApplicationConfiguration.)\\n  (set\! (.foregroundFPS) 100))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "last-fps" "(ns basic-combat-ai.desktop-launcher)" "game" "(use 'clojure.repl)" "(source vector)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc-in game [\:ecs \:entities] (loop [g game\\r\\n                                                      counter 1000]\\r\\n                                                 (if (zero? counter)\\r\\n                                                   g\\r\\n                                                   (recur (ecs/add-entity g (pistoleer g 0 0))\\r\\n                                                          (dec counter))))))" "(update-game\! \#(assoc-in game [\:ecs \:entities] (loop [g game\\r\\n                                                      counter 1000]\\r\\n                                                 (if (zero? counter)\\r\\n                                                   g\\r\\n                                                   (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                          (dec counter))))))" "(update-game\! \#(assoc-in % [\:ecs \:entities] (loop [g %\\r\\n                                                   counter 1000]\\r\\n                                              (if (zero? counter)\\r\\n                                                g\\r\\n                                                (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                       (dec counter))))))" "(count (get-in game [\:ecs \:entities]))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc-in % [\:ecs \:entities] (get-in (loop [g %\\r\\n                                                           counter 1000]\\r\\n                                                      (if (zero? counter)\\r\\n                                                        g\\r\\n                                                        (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                               (dec counter)))) [\:ecs \:entities])))" "(update-game\! \#(assoc-in % [\:ecs \:entities] (get-in (loop [g %\\r\\n                                                           counter 100000]\\r\\n                                                      (if (zero? counter)\\r\\n                                                        g\\r\\n                                                        (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                               (dec counter)))) [\:ecs \:entities])))" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc-in % [\:ecs \:entities] (get-in (loop [g %\\r\\n                                                           counter 100000]\\r\\n                                                      (if (zero? counter)\\r\\n                                                        g\\r\\n                                                        (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                               (dec counter)))) [\:ecs \:entities])))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities] (get-in (loop [g %\\r\\n                                                           counter 100000]\\r\\n                                                      (if (zero? counter)\\r\\n                                                        g\\r\\n                                                        (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                               (dec counter)))) [\:ecs \:entities])))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities] (get-in (loop [g %\\r\\n                                                           counter 100000]\\r\\n                                                      (if (zero? counter)\\r\\n                                                        g\\r\\n                                                        (recur (ecs/add-entity g (ent/pistoleer g 0 0))\\r\\n                                                               (dec counter)))) [\:ecs \:entities])))" "(update-game\! \#((ecs/add-entity % (ent/pistoleer % 0 0))))" "(update-game\! \#(ecs/add-entity % (ent/pistoleer % 0 0)))" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc-in % [\:ecs \:entities] []))" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(ecs/add-entity % (ent/pistoleer % 0 0)))" "(count (get-in game [\:ecs \:entities]))" "(do\\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(get-in game [\:ecs \:entities 0])" "(defn clear-return-ents [node]\\n  (if (empty? (\:children node))\\n    (assoc node \:return-ents [])\\n    (assoc node \:children (mapv clear-return-ents (\:children node)))))" "(clear-return-ents (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(use 'clojure.repl)" "(doc protocol?)" "(source protocol?)" "(satisfies? (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(require '[basic-combat-ai.behavior-tree \:as bt])" "(satisfies? bt/NodeBehavior (get-in game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(basic-combat-ai.desktop-launcher/reset)" "(do (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "game" "(count (get-in game [\:ecs \:entities]))" "(get-in game [\:ecs \:entities 0])" "(do (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(keys (get-in game [\:ecs \:entities 0]))" "(require '[basic-combat-ai.main-screen \:as ms])" "(bt/reset-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(empty? nil)" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])" "(source bt/reset-tree)" "(use 'clojure.repl)" "(source bt/reset-tree)" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 0])" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 1])" "(bt/reset-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(bt/reset (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(bt/reset-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (basic-combat-ai.desktop-launcher/reset))" "(get-in game [\:ecs \:entities])" "(get-in game [\:ecs \:entities 0])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 0}))" "game" "(require '[basic-combat-ai.astar \:as astar])" "(require '[basic-combat-ai.tile-map \:as tile-map])" "(def e (get-in game [\:ecs \:entities 0]))" "e" "(seq? nil)" "(seq? [])" "(seq [])" "(seq nil)" "(def e (filter \#(complement nil? %) (get-in game [\:ecs \:entities])))" "e" "(def e (filter (complement nil?) (get-in game [\:ecs \:entities])))" "e" "(def e (filter (\:move-to) (get-in game [\:ecs \:entities])))" "(def e (filter \#(\:move-to %) (get-in game [\:ecs \:entities])))" "e" "(e)" "e" "(\:transform e)" "e" "(def e (first e))" "e" "(\:transform e)" "(tile-map/get-tile 96 96 (\:tile-map game))" "(\:tile-map game)" "(source tile-map/get-tile)" "(do \\n  (require 'basic-combat-ai.main-screen \:reload-all)\\n  (reset))" "(do \\r\\n     (require 'basic-combat-ai.main-screen \:reload-all)\\r\\n     (reset))" "(require 'basic-combat-ai.main-screen \:reload-all)" "(require 'basic-combat-ai.behavior-tree \:reload-all)\\n(require 'basic-combat-ai.enemy-ai \:reload-all)\\n(require 'basic-combat-ai.main-screen \:reload-all)" "(require 'basic-combat-ai.enemy-ai \:reload)" "(require 'basic-combat-ai.enemy-ai \:reload-all)" "(do \\n  (require 'basic-combat-ai.behavior-tree \:reload)\\n  (require 'basic-combat-ai.enemy-ai \:reload))" "(do \\n  (require 'basic-combat-ai.enemy-ai \:reload))" "(do \\n  (require 'basic-combat-ai.enemy-ai \:reload)\\n  (require 'basic-combat-ai.behavior-tree \:reload))" "(clojure.tools.namespace.repl/refresh)" "(require '[clojure.tools.namespace.repl \:refer [refresh]])" "(refresh)" "(clojure.tools.namespace.repl/refresh)" "(refresh)" "(clojure.tools.namespace.repl/refresh)" "(reset)" "(ns basic-combat-ai.main-screen)" "game" "(basic-combat-ai.desktop-launcher/reset)" "game" "(clojure.tools.namespace.repl/refresh)" "clojure.tools.namespace.repl" "(require clojure.tools.namespace.repl)" "(use '[clojure.tools.namespace.repl \:only (refresh)])" "(refresh)" "game" "(refresh)" "(use '[clojure.tools.namespace.repl \:only (refresh)])" "(refresh)" "(reset)" "(refresh)" "(app)" "(use '[clojure.tools.namespace.repl \:only (refresh)])" "(refresh)" "(app)" "(refresh)" "(use '[clojure.tools.namespace.repl \:only (refresh)])" "(refresh)" "(do \\n  (use '[clojure.tools.namespace.repl \:only (refresh)])\\n  (refresh))" "(reset)" "(app)" "(basic-combat-ai.main-screen/game)" "basic-combat-ai.main-screen/game" "(\:camera basic-combat-ai.main-screen/game)" "(.update (\:camera basic-combat-ai.main-screen/game))" "(.viewportWidth (\:camera basic-combat-ai.main-screen/game))" "(.viewportHeight (\:camera basic-combat-ai.main-screen/game))" "(.update (\:camera basic-combat-ai.main-screen/game))" "(do \\n  (use '[clojure.tools.namespace.repl \:only (refresh)])\\n  (refresh)\\n  (reset))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities] []))" "game" "\\n  (use '[clojure.tools.namespace.repl \:only (refresh)])" "\\n  (use clojure.tools.namespace.repl)" "\\n  (use 'clojure.tools.namespace.repl)" "(app)" "(clojure.tools.namespace.repl/refresh)" "(require '[clojure.tools.namespace.repl \:as repl-tools])" "(repl-tools/disable-reload\! basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! 'basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! [basic-combat-ai.desktop-launcher])" "(repl-tools/disable-reload\! '[basic-combat-ai.desktop-launcher])" "(use 'clojure.repl)" "(source repl-tools/disable-reload\!)" "(repl-tools/refresh)" "(repl-tools/disable-reload\! basic-combat-ai.desktop-launcher)" "(require '[clojure.tools.namespace.repl \:as repl-tools])" "(repl-tools/disable-reload\! basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! 'basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! \:basic-combat-ai.desktop-launcher)" "*ns*" "(repl-tools/disable-reload\! *ns*)" "(repl-tools/disable-reload\! (ns basic-combat-ai.desktop-launcher))" "all-ns" "(all-ns)" "(repl-tools/disable-reload\! (namespace basic-combat-ai.desktop-launcher))" "(repl-tools/disable-reload\! (namespace \\"basic-combat-ai.desktop-launcher\\"))" "(namespace \\"basic-combat-ai.desktop-launcher\\")" "(namespace 'basic-combat-ai.desktop-launcher)" "(namespace 'basic-combat-ai.main-screen)" "(ns-name 'basic-combat-ai.desktop-launcher)" "(ns-map 'basic-combat-ai.desktop-launcher)" "(dir 'basic-combat-ai.desktop-launcher)" "(dir basic-combat-ai.desktop-launcher)" "(clojure.tools.namespace.repl/refresh)" "(find-ns basic-combat-ai.desktop-launcher)" "(find-ns 'basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! (find-ns basic-combat-ai.desktop-launcher))" "(repl-tools/disable-reload\! (find-ns 'basic-combat-ai.desktop-launcher))" "(repl-tools/disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(repl-tools/disable-reload\! (find-ns 'basic-combat-ai.mygame))" "(find-ns 'basic-combat-ai.MyGame)" "(find-ns basic-combat-ai.MyGame)" "(ns basic-combat-ai.MyGame)" "(find-ns basic-combat-ai.MyGame)" "(find-ns 'basic-combat-ai.MyGame)" "(repl-tools/disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(repl-tools/refresh)" "(ns basic-combat-ai.desktop-launcher)" "(repl-tools/disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(repl-tools/refresh)" "(reset)" "(basic-combat-ai.main-screen/game)" "basic-combat-ai.main-screen/game" "(.update (\:camera basic-combat-ai.main-screen/game))" "(do\\n  (.viewportWidth (\:camera basic-combat-ai.main-screen/game) 100)\\n  (.update (\:camera basic-combat-ai.main-screen/game)))" "(do\\n  (.viewportWidth (\:camera basic-combat-ai.main-screen/game) (float 100))\\n  (.update (\:camera basic-combat-ai.main-screen/game)))" "(ns basic-combat-ai.main-screen)" "(do\\r\\n  (.viewportWidth (\:camera basic-combat-ai.main-screen/game) (float 100))\\r\\n  (.update (\:camera basic-combat-ai.main-screen/game)))" "(do\\r\\n  (.-viewportWidth (\:camera basic-combat-ai.main-screen/game) (float 100))\\r\\n  (.update (\:camera basic-combat-ai.main-screen/game)))" "(do\\r\\n  (.viewportWidth (\:camera basic-combat-ai.main-screen/game) (float 100))\\r\\n  (.update (\:camera basic-combat-ai.main-screen/game)))" "(.viewportWidth (\:camera basic-combat-ai.main-screen/game))" "(.viewportHeight (\:camera basic-combat-ai.main-screen/game))" "gane'" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities] []))" "(get-in game [\:ecs])" "(ns basic-combat-ai.desktop-launcher)" "(reset)" "(use 'clojure.tools.namespace.repl)" "(disable-reload\! (find-ns 'basic-combat-ai.desktop-launcher))" "(disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(basic-combat-ai.main-screen/update-game\! \#(assoc-in basic-combat-ai.main-screen/game [\:ecs \:entities] []))" "(basic-combat-ai.main-screen/update-game\! \#(assoc-in % [\:ecs \:entities] []))" "game" "main-screen" "main-screen/screen" "(.getScreen game)" "(refresh)" "(reset)" "game" "(.getScreen game)" "(refresh)" "(reset)" "(refresh)" "(reset)" "(refresh)" "(reset)" "(refresh)" "(reset)" "(println \\"HEY\\")" "(refresh)" "(reset)" "main-screen" "(require basic-combat-ai.main-screen \:reload)" "(require 'basic-combat-ai.main-screen \:reload)" "(reset)" "(require 'basic-combat-ai.desktop-launcher \:reload)" "(app)" "(use 'clojure.tools.namespace.repl)" "game" "(refresh)" "game" "(app)" "(use 'clojure.tools.namespace.repl)" "(refresh)" "(app)" "game" "(use 'clojure.tools.namespace.repl)" "(disable-reload\! *ns*)" "(disable-reload\! 'basic-combat-ai.MyGame)" "(disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(refresh)" "(reset)" "(refresh)" "(reset)" "(refresh)" "(reset)" "(require 'basic-combat-ai.main-screen \:reload-all)" "(reset)" "(app)" "(require 'basic-combat-ai.main-screen \:reload-all)" "game" "(app)" "basic-combat-ai.MyGame/game" "(use 'clojure.tools.namespace.repl)" "(disable-reload\! (find-ns basic-combat-ai.MyGame))" "(disable-reload\! (find-ns 'basic-combat-ai.MyGame))" "(refresh)" "basic-combat-ai.MyGame/game" "(reset)" "(refresh)" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns basic-combat-ai.MyGame))\\n  (refresh))" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\n  (refresh))" "(reset)" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\n  (refresh))" "(reset)" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\n  (refresh))" "(reset)" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\n  (refresh))" "(do \\n  (use 'clojure.tools.namespace.repl)\\n  (disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\n  (refresh-all))" "(app)" "basic-combat-ai.main-screen/game" "(loop [g (\:tile-map basic-combat-ai.main-screen/game)]\\r\\n\\t (if (\= (count g) 0)\\r\\n\\t   nil\\r\\n\\t   (do\\r\\n\\t     (doall (map \\r\\n               (fn [tile]\\r\\n                 (let [{x \:grid-x, y \:grid-y, t \:texture} tile\\r\\n                       tile-size 32\\r\\n                       grid->world-coord (fn [n] (float (* n tile-size)))]\\r\\n                   (println (grid->world-coord x) (grid->world-coord y))))\\r\\n               (first g)))\\r\\n\\t     (recur (rest g)))))" "(get-in game [\:ecs \:entities 0])" "(aoo)" "(app)" "(require 'basic-combat-ai.main-screen \:as ms)" "(require '[basic-combat-ai.main-screen \:as ms])" "(require '[basic-combat-ai.components \:as comps])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 0)))" "(refresh)" "(app)" "(refresh)" "(clojure.tools.namespace.repl/refresh)" "basic-combat-ai.MyGame/game" "(require 'basic-combat-ai.main-screen \:reload-all)" "(require 'basic-combat-ai.main-screen \:reload)" "(refresh)" "(require 'basic-combat-ai.main-screen \:reload-all)" "(refresh)" "(do \\r\\n\\t (clojure.tools.namespace.repl/disable-reload\! (find-ns 'basic-combat-ai.MyGame))\\r\\n\\t (clojure.tools.namespace.repl/refresh-all))" "(load \\"basic_combat_ai\\")" "(app)" "(clojure.tools.namespace.repl/refresh)" "(app)" "(refresh)" "(app)" "(refresh)" "(require 'main-screen \:reload)" "(require 'basic-combat-ai.main-screen \:reload)" "(refresh)" "(def n [basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.MyGame basic-combat-ai.desktop-launcher])" "(def n '[basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.MyGame basic-combat-ai.desktop-launcher])" "n" "(refresh)" "(def n '[basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.desktop-launcher)\\r\\n\:error-while-loading basic-combat-ai.desktop-launcher])" "(def n '[basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.desktop-launcher])" "(symbol basic)" "(require (first n) \:reload)" "(defn rere [all-n]\\r\\n  (loop [n all-n]\\r\\n    (if (empty? all-n)\\r\\n      nil\\r\\n      (require (first n) \:reload)\\n      (recur (rest n)))))" "(defn rere [all-n]\\r\\n  (loop [n all-n]\\r\\n    (if (empty? all-n)\\r\\n      nil\\r\\n      (do\\n        (require (first n) \:reload)\\n        (recur (rest n))))))" "(rere n)" "n" "(def n '[basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.desktop-launcher])" "(defn rere [all-n]\\r\\n     (loop [n all-n]\\r\\n       (if (empty? all-n)\\r\\n         nil\\r\\n         (do\\r\\n           (require (first n) \:reload)\\r\\n           (recur (rest n))))))" "(rere)" "(rere n)" "(require 'basic-combat-ai.desktop-launcher \:reload)" "(def n '[basic-combat-ai.ecs basic-combat-ai.behavior-tree basic-combat-ai.components basic-combat-ai.tile-map basic-combat-ai.math-utils basic-combat-ai.astar basic-combat-ai.enemy-ai basic-combat-ai.entities basic-combat-ai.systems basic-combat-ai.main-screen basic-combat-ai.desktop-launcher])" "(defn rere [all-n]\\r\\n     (loop [n all-n]\\r\\n       (if (empty? all-n)\\r\\n         nil\\r\\n         (do\\r\\n           (require (first n) \:reload)\\r\\n           (recur (rest n))))))" "(rere n)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(require basic-combat-ai.CreateGame \:reload)" "(require 'basic-combat-ai.CreateGame \:reload)" "(require 'basic-combat-ai.MyGame \:reload)" "(rere n)" "(require 'basic-combat-ai.desktop-launcher \:reload)" "(defn rere [all-n]\\r\\n        (loop [n all-n]\\r\\n          (if (empty? all-n)\\r\\n            all-n\\r\\n            (do\\r\\n              (require (first n) \:reload)\\r\\n              (recur (rest n))))))" "(rere n)" "n" "(rere (first n))" "(rere [(first n)])" "(require (first n) \:reload)" "(loop [nn n]\\r\\n  (if (empty? all-n)\\r\\n    all-n\\r\\n    (do\\r\\n      (require (first nn) \:reload)\\r\\n      (recur (rest nn)))))" "(loop [nn n]\\r\\n  (if (empty? nn)\\r\\n    n\\r\\n    (do\\r\\n      (require (first nn) \:reload)\\r\\n      (recur (rest nn)))))" "(loop [nn n]\\r\\n  (if (empty? nn)\\r\\n    nil\\r\\n    (do\\n      (println \\"reloading \\" (first nn))\\r\\n      (require (first nn) \:reload)\\r\\n      (recur (rest nn)))))" "(defn a []\\n  (loop [nn n]\\r\\n  (if (empty? nn)\\r\\n    nil\\r\\n    (do\\n        (println \\"reloading \\" (first nn))\\r\\n      (require (first nn) \:reload)\\r\\n      (recur (rest nn))))))" "(a)" "(defn rere [n]\\n  (loop [nn n]\\r\\n  (if (empty? nn)\\r\\n    nil\\r\\n    (do\\n        (println \\"reloading \\" (first nn))\\r\\n      (require (first nn) \:reload)\\r\\n      (recur (rest nn))))))" "(rere n)" "n" "(refresh)" "(refresh n)" "(app)" "(ns 'basic-combat-ai.main-screen)" "(ns basic-combat-ai.main-screen)" "game" "(require '[basic-combat-ai.components \:as comps])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 0)))" "(defn refresh [namespaces]\\r\\n (loop [nn namespaces]\\r\\n   (if (empty? nn)\\r\\n   nil\\r\\n   (do\\r\\n     (println \\"reloading \\" (first nn))\\r\\n     (require (first nn) \:reload)\\r\\n     (recur (rest nn))))))" "(refresh '[basic-combat-ai.ecs\\r\\n\\t\\t\\t\\tbasic-combat-ai.behavior-tree\\r\\n\\t\\t\\t\\tbasic-combat-ai.components\\r\\n\\t\\t\\t\\tbasic-combat-ai.tile-map\\r\\n\\t\\t\\t\\tbasic-combat-ai.math-utils\\r\\n\\t\\t\\t\\tbasic-combat-ai.astar\\r\\n\\t\\t\\t\\tbasic-combat-ai.enemy-ai\\r\\n\\t\\t\\t\\tbasic-combat-ai.entities\\r\\n\\t\\t\\t\\tbasic-combat-ai.systems\\r\\n\\t\\t\\t\\tbasic-combat-ai.main-screen\\r\\n\\t\\t\\t\\tbasic-combat-ai.desktop-launcher])" "(update-game\! \#(assoc-in % [\:ecs \:entities 1 \:move-to] (comps/move-to 0 0)))" "(app)" "(ns 'basic-combat-ai.main-screen)" "(ns basic-combat-ai.main-screen)" "(.totalRenderCalls SpriteBatch)" "(\:batch game)" "(.totalRenderCalls (\:batch game))" "(app)" "(get-in game [\:ecs \:systems])" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:systems])" "(update-game\! \#(assoc-in % [\:ecs \:systems] (disj (get-in game [\:ecs \:systems]) 2)))" "(update-game\! \#(assoc-in % [\:ecs \:systems] (dissoc (get-in game [\:ecs \:systems]) 2)))" "(assoc [] 0 \\"hu\\")" "(dissoc [\\"hu\\"] 0 )" "(assoc [\\"t\\"] 0 \\"hu\\")" "(def get-ent-pos [id ents*]\\n  (loop [ents ents*\\n         idx 0]\\n    (if (\= id (\:id (first ents)))\\n      idx\\n      (recur (rest ents) (inc idx)))))" "(defn get-ent-pos [id ents*]\\n  (loop [ents ents*\\n         idx 0]\\n    (if (\= id (\:id (first ents)))\\n      idx\\n      (recur (rest ents) (inc idx)))))" "(get-ent-pos 1 (get-in game [\:ecs \:entities]))" "(get-ent-pos 2 (get-in game [\:ecs \:entities]))" "(get-ent-pos 3 (get-in game [\:ecs \:entities]))" "(get-ent-pos 4 (get-in game [\:ecs \:entities]))" "(get-ent-pos 900 (get-in game [\:ecs \:entities]))" "(time (get-ent-pos 900 (get-in game [\:ecs \:entities])))" "(get-ent-pos 900 (get-in game [\:ecs \:entities]))" "(get-ent-pos 2 (get-in game [\:ecs \:entities]))" "(get-ent-pos 1 (get-in game [\:ecs \:entities]))" "(get-ent-pos 901 (get-in game [\:ecs \:entities]))" "(defn replace-ent [idx replacement-ent ents]\\n  (assoc ents idx replacement-ent))" "(assoc [\\"a\\" \\"b\\" \\"c\\"] 0 \\"h\\")" "(def n '[basic-combat-ai.ecs\\r\\n\\t\\t\\t\\tbasic-combat-ai.behavior-tree\\r\\n\\t\\t\\t\\tbasic-combat-ai.components\\r\\n\\t\\t\\t\\tbasic-combat-ai.tile-map\\r\\n\\t\\t\\t\\tbasic-combat-ai.math-utils\\r\\n\\t\\t\\t\\tbasic-combat-ai.astar\\r\\n\\t\\t\\t\\tbasic-combat-ai.enemy-ai\\r\\n\\t\\t\\t\\tbasic-combat-ai.entities\\r\\n\\t\\t\\t\\tbasic-combat-ai.systems\\r\\n\\t\\t\\t\\tbasic-combat-ai.main-screen\\r\\n\\t\\t\\t\\tbasic-combat-ai.desktop-launcher])" "(defn refresh [namespaces]\\r\\n (loop [nn namespaces]\\r\\n   (if (empty? nn)\\r\\n   nil\\r\\n   (do\\r\\n     (println \\"reloading \\" (first nn))\\r\\n     (require (first nn) \:reload)\\r\\n     (recur (rest nn))))))" "(refresh n)" "(basic-combat-ai.desktop-launcher/reset)" "(use clojure.repl)" "(use 'clojure.repl)" "(source get-in)" "(source get)" "(source assoc-in)" "(app)" "(use 'clojure.repl)" "(source comps/collider)" "(defn refresh [namespaces]\\r\\n (loop [nn namespaces]\\r\\n   (if (empty? nn)\\r\\n   nil\\r\\n   (do\\r\\n     (println \\"reloading \\" (first nn))\\r\\n     (require (first nn) \:reload)\\r\\n     (recur (rest nn))))))" "(def n '[basic-combat-ai.ecs\\r\\n\\t\\t\\t\\tbasic-combat-ai.behavior-tree\\r\\n\\t\\t\\t\\tbasic-combat-ai.components\\r\\n\\t\\t\\t\\tbasic-combat-ai.tile-map\\r\\n\\t\\t\\t\\tbasic-combat-ai.math-utils\\r\\n\\t\\t\\t\\tbasic-combat-ai.astar\\r\\n\\t\\t\\t\\tbasic-combat-ai.enemy-ai\\r\\n\\t\\t\\t\\tbasic-combat-ai.entities\\r\\n\\t\\t\\t\\tbasic-combat-ai.systems\\r\\n\\t\\t\\t\\tbasic-combat-ai.main-screen\\r\\n\\t\\t\\t\\tbasic-combat-ai.desktop-launcher])" "(refresh n)" "(comps/box-collider 0 0 32 32)" "(app)" "(refresh n)" "(app)" "(refresh n)" "(ns basic-combat-ai.main-screen)" "game" "(reset)" "(ns basic-combat-ai.main-screen)" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 1 \:move-to] {\:x 0 \:y 0}))" "(\=\= 1.00 1.00)" "(\= 1.00 1.00)" "(\= 1.00 1)" "(\=\= 1.00 1)" "(\=\= 1.01 1)" "(source assoc-in)" "(use 'clojure.repl)" "(source assoc-in)" "(defn rotator [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#((and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %))))\\n        modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rotate-by) (+ rotate-by rot-speed) (- rotate-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(defn rotator [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#((and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %))))\\n        modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (clojure.math.numeric-tower/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rotate-by) (+ rotate-by rot-speed) (- rotate-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(require 'clojure.math.numeric-tower)" "(defn rotator [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#((and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %))))\\n        modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rotate-by) (+ rotate-by rot-speed) (- rotate-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(defn rotator [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#((and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %))))\\n        modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(rotator {\:ecs \:entities [{\:id 1\\n                           \:transform {\:rotation 0}\\n                           \:move-speed {\:rotation-speed 10}\\n                           \:rotate-by 20\\n                           } \\n                          {\:id 2}]})" "{\:ecs \:entities [{\:id 1\\n                  \:transform {\:rotation 0}\\n                  \:move-speed {\:rotation-speed 10}\\n                  \:rotate-by 20} \\n                 {\:id 2}\\n                 ]}" "(rotator {\:ecs {\:entities [{\:id 1\\n                            \:transform {\:rotation 0}\\n                            \:move-speed {\:rotation-speed 10}\\n                            \:rotate-by 20} \\n                           {\:id 2}\\n                           ]}})" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#((and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %))))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                             (\:movespeed %)\\r\\n                                                             (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  modified-ents)" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  qualifying-ents)" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (filter-ents ents \#(and (\:rotate-by %) \\r\\n                          (\:movespeed %)\\r\\n                          (\:transform %))))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]]\\n  (and (\:rotate-by (first ents)) \\r\\n       (\:movespeed (first ents))\\r\\n       (\:transform (first ents))))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:move-speed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]]\\n  (\:rotate-by (first ents)))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  modified-ents)" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (-> q-ent \\r\\n                                  (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                  (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))\\n                          qualifying-ents)]\\n  modified-ents)" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n                                (-> q-ent \\r\\n                                  (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                  )))\\n                          qualifying-ents)]\\n  modified-ents)" "\\n      (let [ents [{\:id 1\\r\\n                   \:transform {\:rotation 0}\\r\\n                   \:movespeed {\:rotation-speed 10}\\r\\n                   \:rotate-by 20} \\r\\n                  {\:id 2}]\\n            q-ent (first ents)\\n            rot (\:rotation (\:transform q-ent))\\r\\n            rot-by (\:rotate-by q-ent)\\r\\n            rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n        (-> q-ent \\r\\n          (update-in [\:transform \:rotation] \#(+ % rot-speed)))\\n        )" "\\n      (let [ents [{\:id 1\\r\\n                   \:transform {\:rotation 0}\\r\\n                   \:movespeed {\:rotation-speed 10}\\r\\n                   \:rotate-by 20} \\r\\n                  {\:id 2}]\\n            q-ent (first ents)\\n            rot (\:rotation (\:transform q-ent))\\r\\n            rot-by (\:rotate-by q-ent)\\r\\n            rot-speed (\:rotation-speed (\:move-speed q-ent))]\\r\\n        \\n        )" "\\n      (let [ents [{\:id 1\\r\\n                   \:transform {\:rotation 0}\\r\\n                   \:movespeed {\:rotation-speed 10}\\r\\n                   \:rotate-by 20} \\r\\n                  {\:id 2}]\\n            q-ent (first ents)\\n            rot (\:rotation (\:transform q-ent))\\r\\n            rot-by (\:rotate-by q-ent)\\r\\n            rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n        (-> q-ent \\r\\n          (update-in [\:transform \:rotation] \#(+ % rot-speed)))\\n        )" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  modified-ents)" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by -20} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 1} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                (if (\=\= rot rot-by)\\r\\n                                  (dissoc q-ent \:rotate-by)\\r\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(let [ents [{\:id 1\\r\\n             \:transform {\:rotation 0}\\r\\n             \:movespeed {\:rotation-speed 10}\\r\\n             \:rotate-by 1} \\r\\n            {\:id 2}]\\n      [qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                          (\:movespeed %)\\r\\n                                                          (\:transform %)))\\n      modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                  ;if the rotation speed is > than the rotation, don't overshoot.\\n                                  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                    (-> q-ent\\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                      (dissoc \:rotate-by))\\r\\n                                    (-> q-ent \\r\\n                                      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed)))))))\\r\\n                            qualifying-ents)]\\n  (into modified-ents rest-ents))" "(defn rotate [{{ents \:entities} \:ecs}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                            (\:movespeed %)\\r\\n                                                            (\:transform %)))\\n        modified-ents (mapv (fn [q-ent]\\r\\n                              (let [rot (\:rotation (\:transform q-ent))\\r\\n                                    rot-by (\:rotate-by q-ent)\\r\\n                                    rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                ;if the rotation speed is > than the rotation, don't overshoot.\\n                                (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                  (-> q-ent\\r\\n                                    (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                    (dissoc \:rotate-by))\\r\\n                                  (-> q-ent \\r\\n                                    (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                    (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed)))))))\\r\\n                            qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(conj [] 1)" "(conj [1] 1)" "(conj [1] 2)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [ss] (conj ss (defn rotate [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n                                       rot-by (\:rotate-by q-ent)\\r\\n                                       rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                   ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n                                   (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                     (-> q-ent\\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                       (dissoc \:rotate-by))\\r\\n                                     (-> q-ent \\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                       (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed)))))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))))))" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [ss] (conj ss (fn [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n                                       rot-by (\:rotate-by q-ent)\\r\\n                                       rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                   ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n                                   (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                     (-> q-ent\\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                       (dissoc \:rotate-by))\\r\\n                                     (-> q-ent \\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                       (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed)))))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))))))" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:systems] (fn [ss] (conj ss (fn [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n                                       rot-by (\:rotate-by q-ent)\\r\\n                                       rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n                                   ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n                                          (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n                                     (-> q-ent\\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n                                       (dissoc \:rotate-by))\\r\\n                                     (-> q-ent \\r\\n                                       (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n                                       (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed)))))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents))))))))" "(get-in ms/game [\:ecs \:systems])" "(dissoc [1 2 3] 0)" "(pop [1 2 3] 0)" "(pop [1 2 3])" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:systems] (fn [ss] (pop ss)))))" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:systems] (fn [ss] (conj ss rotate)))))" "(get-in ms/game [\:ecs \:systems])" "(ns basic-combat-ai.main-screen)" "(update-game\! (fn [g] (update-in g [\:ecs \:entities 0] \#(assoc % \\n                                                              \:movespeed {\:rotation-speed 1}))))" "(get-in game [\:ecs \:entities 0])" "(update-game\! (fn [g] (update-in g [\:ecs \:entities 0] \#(assoc % \\n                                                              \:rotate-by 90))))" "(get-in game [\:ecs \:entities])" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 1])" "(update-game\! (fn [g] (update-in g [\:ecs \:entities 1]) (fn [e] (assoc e \:movespeed {\:rotation-speed 1}))))" "(update-game\! (fn [g] (update-in g [\:ecs \:entities 1] (fn [e] (assoc e \:movespeed {\:rotation-speed 1})))))" "(update-game\! (fn [g] (update-in g [\:ecs \:entities] (fn [ents] (conj ents (ecs/add-entity g (pistoleer g 1 1)))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:entities] (fn [ents] (conj ents (ecs/add-entity g (pistoleer g 1 1)))))))" "(get-in ms/g [\:ecs \:entities])" "(get-in ms/game [\:ecs \:entities])" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x y1 \:y width1 \:width height1 \:height} r1\\n        {x2 \:x y2 \:y width2 \:width height2 \:height} r2]\\n    x1))" "(rectangle-overlap? {\:x 5})" "(rectangle-overlap? {\:x 5} {})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    x1))" "(rectangle-overlap? {\:x 5} {})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) r2))))" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width1) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) r2))))" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 32 \:y 32 \:width 32 \:height 32})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width1) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) y2))))" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 32 \:y 32 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 64 \:y 64 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 0 \:y 0 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 0 \:y 0 \:width 64 \:height 64})" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))]\\n  (map (fn [e]\\n         (if (is-same-ent? main-ent e)\\n           nil\\n           (if (math-utils/rectangle-overlap? main-e-collider (\:self-collider e))\\n             e\\n             nil)))\\n       ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))]\\n  (map (fn [e]\\n         (if (is-same-ent? main-ent e)\\n           nil\\n           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\n                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\n                            \:width (\:width main-e-collider)\\n                            \:height (\:height main-e-collider)}\\n                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\n                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\n                         \:width (\:width (\:self-collider e))\\n                         \:height (\:height (\:self-collider e))}]\\n             (if (math-utils/rectangle-overlap? main-rect e-rect)\\n               e\\n               nil)))) \\n       ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (remove nil? ents-in-fov-nils)]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vector (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(count [])" "(use 'clojure.repl)" "(source empty?)" "(source seq)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  main-ent)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(defn- ents-in-fov [main-ent ents]\\n  (let [main-e-collider (\:fov-collider main-ent)\\n        main-e-transform (\:transform main-ent)\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n        local->world-coord (fn [collider transform]\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\n    (vec (remove nil? ents-in-fov-nils))))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 0]) (get-in ms/game [\:ecs \:entities]))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (vec (remove nil? ents-in-fov-nils))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    local->world-coord))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (local->world-coord main-e-collider main-e-transform) ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils ))" "(use 'clojure.stacktrace)" "(use clojure.stacktrace)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils ))" "(print-stack-trace *e)" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents) ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (local->world-coord (\:self-collider e) e)\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      \\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      e\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (\:self-collider e)\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      e\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (local->world-coord (\:self-collider e) e)\\n    )))" "(defn- ents-in-fov [main-ent ents]\\n  (let [main-e-collider (\:fov-collider main-ent)\\n        main-e-transform (\:transform main-ent)\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n        local->world-coord (fn [collider transform]\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\n                                        e-rect (local->world-coord (\:self-collider e) (\:transform e))]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\n    (vec (remove nil? ents-in-fov-nils))))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 0]) (get-in ms/game [\:ecs \:entities]))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 1]) (get-in ms/game [\:ecs \:entities]))" "(app)" "\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\"\\n(let [x0 1, y0 1\\n      x1 6, y1 2\\n      dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? curr-n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))))))" "\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\"\\n(let [x0 1, y0 1\\n      x1 6, y1 2\\n      dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))))))" "(defn raytrace [x0 y0 x1 y1]\\n\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\nReturns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\n(let [dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y])))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(require '[basic-combat-ai.tile-map \:as tile-map])" "(reset)" "(raytrace 0 0 6 2)" "(time (raytrace 0 0 6 2))" "(\:tile-map (ms/game))" "(\:tile-map ms/game)" "(nth (\:tile-map ms/game) 0)" "(nth (nth (\:tile-map ms/game) 0) 0)" "(get-in (\:tile-map ms/game) [0 0])" "(assoc-in (\:tile-map ms/game) [0 0 \:texture] nil)" "(let [positions (raytrace 0 0 6 2)\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\n  (ms/update-game\! \#(assoc % \:tile-map (update-tile 0 0))))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:tex-cache ms/game)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     wall-texture)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     positions)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     update-tile)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (ms/update-game\! \#(assoc % \:tile-map (update-tile 0 0))))" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      floor-texture (\:floor (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     floor-texture)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      floor-texture (\:floor (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n  (loop [posis positions]\\n    (if (empty? posis)\\n      nil\\n      (do\\n        (let [tile-pos (nth posis 0)\\n              x (nth tile-pos 0)\\n              y (nth tile-pos 1)]\\n        (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\n        (recur (rest posis)))))))" "(defn raytrace [x0 y0 x1 y1]\\r\\n   \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n   Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n   (let [dx (Math/abs (- x1 x0))\\r\\n         dy (Math/abs (- y1 y0))\\r\\n         x-inc (if (> x1 x0) 1 -1)\\r\\n         y-inc (if (> y1 y0) 1 -1)]\\r\\n     (loop [x x0\\r\\n            y y0\\r\\n            n (+ 1 dx dy)\\r\\n            err (- dx dy) \\r\\n            result []]\\r\\n       (if (zero? n)\\r\\n         result\\r\\n         (cond \\r\\n           (pos? err) (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\r\\n           (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))\\n           \:else (recur (+ x x-inc) (+ y y-inc) (dec n) (+ err dx) (conj result [x y])))))))" "(ns basic-combat-ai.desktop-launcher/reset)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.math-utils)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 2 6 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     positions)" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              \:else (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y])))))))" "(let [positions (raytrace 0 0 2 6)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              )))))" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              \:else (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y])))))))" "(let [positions (raytrace 0 5 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (<\= n 0)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (- n 2) (+ err dx2) (conj result [x y]))\\n              )))))" "(let [positions (raytrace 0 5 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (<\= n 0)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (- n 2) (- (+ err dx2) dy2) (conj result [x y]))\\n              )))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)"]
eclipse.preferences.version=1
