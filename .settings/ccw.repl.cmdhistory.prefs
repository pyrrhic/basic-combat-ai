cmdhistory=["(\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                   \:1\\n                   (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                   (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (bt/make-return-map (assoc node \:status \:success)\\r\\n                          (assoc-in entities [main-ent-id \:combat-target] ents-los-checked)\\r\\n                          curr-tile-map))))" "(\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                   \:1\\n                   (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                   (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-checked)))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (los? main-ent e curr-tile-map))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (los? main-ent (first (vals (dissoc entities main-ent-id))) curr-tile-map))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (los? main-ent e curr-tile-map))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (los? main-ent (first (vals (dissoc entities main-ent-id))) curr-tile-map))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (vals (dissoc entities main-ent-id))) curr-tile-map))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (vals (dissoc entities main-ent-id)))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (first (vals (dissoc entities main-ent-id))))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (los? main-ent (first (vals (dissoc entities main-ent-id))) curr-tile-map))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (let [ent1 main-ent\\n            ent2 (first (vals (dissoc entities main-ent-id)))\\n            tile-locs (math-utils/raytrace (\:x (\:transform ent1)) (\:y (\:transform ent1))\\r\\n                                           (\:x (\:transform ent2)) (\:y (\:transform ent2)))\\r\\n            are-tiles-passable? (map \\r\\n                                  (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                                  tile-locs)\\r\\n            have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n        have-los?)\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (let [ent1 main-ent\\n            ent2 (first (vals (dissoc entities main-ent-id)))\\n            tile-locs (math-utils/raytrace (\:x (\:transform ent1)) (\:y (\:transform ent1))\\r\\n                                           (\:x (\:transform ent2)) (\:y (\:transform ent2)))\\r\\n            are-tiles-passable? (map \\r\\n                                  (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                                  tile-locs)\\r\\n            have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n        are-tiles-passable?)\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (let [ent1 main-ent\\n            ent2 (first (vals (dissoc entities main-ent-id)))\\n            tile-locs (math-utils/raytrace (\:x (\:transform ent1)) (\:y (\:transform ent1))\\r\\n                                           (\:x (\:transform ent2)) (\:y (\:transform ent2)))\\r\\n            are-tiles-passable? (map \\r\\n                                  (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                                  tile-locs)\\r\\n            have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n        tile-locs)\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defn- los? [ent1 ent2 curr-tile-map] \\r\\n  (let [grid-x1 (tile-map/world-coord->grid (\:x (\:transform ent1)))\\n        grid-y1 (tile-map/world-coord->grid (\:y (\:transform ent1)))\\n        grid-x2 (tile-map/world-coord->grid (\:x (\:transform ent2)))\\n        grid-y2 (tile-map/world-coord->grid (\:y (\:transform ent2)))\\n        tile-locs (math-utils/raytrace grid-x1 grid-y1\\r\\n                                       grid-x2 grid-y2)\\r\\n        are-tiles-passable? (map \\r\\n                              (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                              tile-locs)\\r\\n        have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n    have-los?))" "(\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                   \:1\\n                   (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                   (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (let [ent1 main-ent\\n            ent2 (first (vals (dissoc entities main-ent-id)))\\n            tile-locs (math-utils/raytrace (\:x (\:transform ent1)) (\:y (\:transform ent1))\\r\\n                                           (\:x (\:transform ent2)) (\:y (\:transform ent2)))\\r\\n            are-tiles-passable? (map \\r\\n                                  (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                                  tile-locs)\\r\\n            have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n        tile-locs)\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-checked\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:1\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (bt/make-return-map (assoc node \:status \:success)\\r\\n                          (assoc-in entities [main-ent-id \:combat-target] (keyword (str closest-ent)))\\r\\n                          curr-tile-map))))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (bt/make-return-map (assoc node \:status \:success)\\r\\n                          (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str closest-ent)))\\r\\n                          curr-tile-map))))" "(ns basic-combat-ai.desktop-launcher)" "(app)" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "ms/game" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 1 \:y 1}}}\\n          (\:tile-map ms/game)))" "(Math/abs -1)" "\\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 1 \:y 1}}}\\n          (\:tile-map ms/game))" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 1 \:y 1}}}\\n          (\:tile-map ms/game)))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 1 \:y 1}}}\\n          (\:tile-map ms/game)))" "(los? {\:id 1 \:transform {\:x 0 \:y 0}} {\:id 2 \:transform {\:x 1 \:y 1}} (\:tile-map ms/game))" "(defn- los? [ent1 ent2 curr-tile-map] \\r\\n  (let [grid-x1 (tile-map/world-coord->grid (\:x (\:transform ent1)))\\r\\n        grid-y1 (tile-map/world-coord->grid (\:y (\:transform ent1)))\\r\\n        grid-x2 (tile-map/world-coord->grid (\:x (\:transform ent2)))\\r\\n        grid-y2 (tile-map/world-coord->grid (\:y (\:transform ent2)))\\r\\n;        tile-locs (math-utils/raytrace grid-x1 grid-y1\\r\\n;                                       grid-x2 grid-y2)\\r\\n;        are-tiles-passable? (map \\r\\n;                              (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n;                              tile-locs)\\r\\n;        have-los? (reduce \#(and %1 %2) are-tiles-passable?)\\n        ]\\r\\n    grid-x1))" "(los? {\:id 1 \:transform {\:x 0 \:y 0}} {\:id 2 \:transform {\:x 1 \:y 1}} (\:tile-map ms/game))" "(defn- los? [ent1 ent2 curr-tile-map] \\r\\n  (let [grid-x1 (tile-map/world-coord->grid (\:x (\:transform ent1)))\\r\\n        grid-y1 (tile-map/world-coord->grid (\:y (\:transform ent1)))\\r\\n        grid-x2 (tile-map/world-coord->grid (\:x (\:transform ent2)))\\r\\n        grid-y2 (tile-map/world-coord->grid (\:y (\:transform ent2)))\\r\\n;        tile-locs (math-utils/raytrace grid-x1 grid-y1\\r\\n;                                       grid-x2 grid-y2)\\r\\n;        are-tiles-passable? (map \\r\\n;                              (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n;                              tile-locs)\\r\\n;        have-los? (reduce \#(and %1 %2) are-tiles-passable?)\\n        ]\\r\\n    grid-y1))" "(los? {\:id 1 \:transform {\:x 0 \:y 0}} {\:id 2 \:transform {\:x 1 \:y 1}} (\:tile-map ms/game))" "(defn- los? [ent1 ent2 curr-tile-map] \\r\\n  (let [grid-x1 (tile-map/world-coord->grid (\:x (\:transform ent1)))\\r\\n        grid-y1 (tile-map/world-coord->grid (\:y (\:transform ent1)))\\r\\n        grid-x2 (tile-map/world-coord->grid (\:x (\:transform ent2)))\\r\\n        grid-y2 (tile-map/world-coord->grid (\:y (\:transform ent2)))\\r\\n;        tile-locs (math-utils/raytrace grid-x1 grid-y1\\r\\n;                                       grid-x2 grid-y2)\\r\\n;        are-tiles-passable? (map \\r\\n;                              (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n;                              tile-locs)\\r\\n;        have-los? (reduce \#(and %1 %2) are-tiles-passable?)\\n        ]\\r\\n    grid-x2))" "(los? {\:id 1 \:transform {\:x 0 \:y 0}} {\:id 2 \:transform {\:x 1 \:y 1}} (\:tile-map ms/game))" "(defn- los? [ent1 ent2 curr-tile-map] \\r\\n  (let [grid-x1 (tile-map/world-coord->grid (\:x (\:transform ent1)))\\r\\n        grid-y1 (tile-map/world-coord->grid (\:y (\:transform ent1)))\\r\\n        grid-x2 (tile-map/world-coord->grid (\:x (\:transform ent2)))\\r\\n        grid-y2 (tile-map/world-coord->grid (\:y (\:transform ent2)))\\r\\n        tile-locs (math-utils/raytrace grid-x1 grid-y1\\r\\n                                       grid-x2 grid-y2)\\r\\n        are-tiles-passable? (map \\r\\n                              (fn [t-loc] (\:passable (tile-map/get-tile (first t-loc) (second t-loc) curr-tile-map)))\\r\\n                              tile-locs)\\r\\n        have-los? (reduce \#(and %1 %2) are-tiles-passable?)]\\r\\n    have-los?))" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 32 \:y 32}}}\\n          (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (bt/make-return-map (assoc node \:status \:success)\\r\\n                          (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                          curr-tile-map))))" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 32 \:y 32}}}\\n          (\:tile-map ms/game)))" "(bt/run (->EngageCombatTarget \:fresh)\\n        \:1\\n        (\:entities (bt/run (->LocateACombatTarget \:fresh) \:1 {\:1 {\:id 1 \:transform {\:x 0 \:y 0}} \:2 {\:id 2 \:transform {\:x 32 \:y 32}}} (\:tile-map ms/game)))\\n        (\:tile-map ms/game))" "(\:entities (bt/run (->EngageCombatTarget \:fresh)\\n                   \:1\\n                   (\:entities (bt/run (->LocateACombatTarget \:fresh) \:1 {\:1 {\:id 1 \:transform {\:x 0 \:y 0}} \:2 {\:id 2 \:transform {\:x 32 \:y 32}}} (\:tile-map ms/game)))\\n                   (\:tile-map ms/game)))" "(\:entities \\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:1\\r\\n          {\:1 {\:id 1 \:transform {\:x 0 \:y 0}}\\r\\n           \:2 {\:id 2 \:transform {\:x 32 \:y 32}}}\\n          (\:tile-map ms/game)))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick-behavior-tree ms/game)" "(ms/update-game\! \#(tick-behavior-tree %))" "(app)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(ns basic-combat-ai.systems)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       ;get \:combat-target\\r\\n       ;if not facing it, rotate towards it and return running\\r\\n       ;else los check on it\\r\\n       ;if los on it, fire and return success\\r\\n       ;else failure, no los on it.\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (assoc-in entities [main-ent-id \:animation \:current-animation] \:fire-pistol) ;somehow, fire?\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(ns basic-combat-ai.systems)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(keys (get-in ms/game [\:ecs \:entities 0]))" "(tick-behavior-tree ms/game)" "(keys (first (tick-behavior-tree ms/game)))" "(first (tick-behavior-tree ms/game))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick-behavior-tree ms/game)" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick-behavior-tree ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(defrecord Selector [status curr-child-idx children]\\r\\n  ;it works like a logical OR\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))]\\r\\n      (cond\\r\\n        (\= \:running updated-child-status) \\r\\n          (make-return-map (assoc selector-with-updated-children \:status \:running)\\r\\n                           updated-child-ents\\r\\n                           updated-child-map)\\n        (\= \:success updated-child-status)\\n          (make-return-map (assoc selector-with-updated-children \:status \:success)\\r\\n                           updated-child-ents\\r\\n                           updated-child-map)\\r\\n        (not\= current-child-idx (dec (count (\:children node))))\\r\\n          (tick-updated-selector)\\r\\n        \:else ;not running, not success, is last child.\\r\\n          (make-return-map (assoc selector-with-updated-children \:status \:failure)\\r\\n                           updated-child-ents\\r\\n                           updated-child-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 0])" "(ns basic-combat-ai.components)" "(defn hit-points [e hp]\\n  (assoc e \:hit-points hp))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.components \:as comps])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       ;get \:combat-target\\r\\n       ;if not facing it, rotate towards it and return running\\r\\n       ;else los check on it\\r\\n       ;if los on it, fire and return success\\r\\n       ;else failure, no los on it.\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (-> entities\\r\\n                                   (assoc-in [main-ent-id \:animation \:current-animation] \:fire-pistol)\\r\\n                                   (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp 10))))\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       ;get \:combat-target\\r\\n       ;if not facing it, rotate towards it and return running\\r\\n       ;else los check on it\\r\\n       ;if los on it, fire and return success\\r\\n       ;else failure, no los on it.\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (-> entities\\r\\n                                   (assoc-in [main-ent-id \:animation \:current-animation] \:fire-pistol)\\n                                   (dissoc main-ent-id \:combat-target-id)\\r\\n                                   (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp 10))))\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(ns basic-combat-ai.main-screen)" "game" "(get-in game [\:ecs \:entities])" "(get-in game [\:ecs \:entities 0])" "(app)" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(keys (get-in ms/game [\:ecs \:entities 0]))" "(update {\:1 {\:id 1 \:combat-target-id \:2}} \:1 dissoc \:combat-target-id)" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (-> entities\\r\\n                                   (assoc-in [main-ent-id \:animation \:current-animation] \:fire-pistol)\\r\\n                                   (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp 10)))\\r\\n                                   (update main-ent-id dissoc \:combat-target-id))\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(ns basic-combat-ai.systems)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(keys (get-in ms/game [\:ecs \:entities 0]))" "(tick-behavior-tree ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e]\\r\\n               (if (<\= (\:hit-points e) 0)\\r\\n                 true\\r\\n                 false))]\\r\\n    (loop [q-ents qualifying-ents\\r\\n           ents-map (ent-vec->map ents)]\\r\\n      (if (empty? q-ents)\\r\\n        (vals q-ents)\\n        (recur \\n          (rest q-ents)\\n          (let [e (first q-ents)]\\n            (if (die? e) (dissoc ents-map (keyword (str (\:id e)))) ents-map)))))))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (tick-behavior-tree %)))" "(get-in ms/game [\:ecs \:entities 0])" "(death ms/game)" "(vals {})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e]\\r\\n               (if (<\= (\:hit-points e) 0)\\r\\n                 true\\r\\n                 false))]\\r\\n    (loop [q-ents qualifying-ents\\r\\n           ents-map (ent-vec->map ents)]\\r\\n      (if (empty? q-ents)\\r\\n        (into rest-ents (vals q-ents))\\r\\n        (recur \\r\\n          (rest q-ents)\\r\\n          (let [e (first q-ents)]\\r\\n            (if (die? e) (dissoc ents-map (keyword (str (\:id e)))) ents-map)))))))" "(death ms/game)" "(app)" "(reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100000)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ns basic-combat-ai.components)" "(defn projectile-weapon [ent cooldown damage max-ammo current-ammo reload-speed]\\n  (assoc ent\\n         \:projectile-weapon {\:cooldown cooldown\\n                             \:damage damage\\n                             \:max-ammo max-ammo\\n                             \:current-ammo current-ammo\\n                             \:reload-speed reload-speed}))" "(projectile-weapon {\:id 1} 0.5 10 9 9 5)" "(ns basic-combat-ai.entities)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (projectile-weapon 0.8 10 9 9 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon 0.8 10 9 9 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(pistoleer {} 0 0)" "(ns basic-combat-ai.enemy-ai)" ";check cooldown" ";check ammo" ";check distance" ";distance should probably be done on LOS" ";make distance check just flat for now, keep it simple." ";constant, i mean." ";make sure the target is still valid." ";like, they're alive, not just los on them." ";alive meaning they exist" ";nah check alive too, no overkilling" ";1) cooldown" "(defn projectile-weapon [ent cooldown curr-cooldown damage max-ammo current-ammo reload-speed]\\r\\n  (assoc ent\\r\\n         \:projectile-weapon {\:cooldown cooldown\\r\\n                             \:curr-cooldown curr-cooldown\\r\\n                             \:damage damage\\r\\n                             \:max-ammo max-ammo\\r\\n                             \:current-ammo current-ammo\\r\\n                             \:reload-speed reload-speed}))" "(defn projectile-weapon [ent & {\:keys [cooldown curr-cooldown damage max-ammo current-ammo reload-speed]}]\\r\\n  (assoc ent\\r\\n         \:projectile-weapon {\:cooldown cooldown\\r\\n                             \:curr-cooldown curr-cooldown\\r\\n                             \:damage damage\\r\\n                             \:max-ammo max-ammo\\r\\n                             \:current-ammo current-ammo\\r\\n                             \:reload-speed reload-speed}))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\n                             \:curr-cooldown 0.0 \\n                             \:damage 10 \\n                             \:max-ammo 9 \\n                             \:current-ammo 9 \\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    ;(comps/projectile-weapon \:cooldown 0.8 \\n;                             \:curr-cooldown 0.0 \\n;                             \:damage 10 \\n;                             \:max-ammo 9 \\n;                             \:current-ammo 9 \\n;                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\n                             \:curr-cooldown 0.0 \\n                             \:damage 10 \\n                             \:max-ammo 9 \\n                             \:current-ammo 9 \\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn can-fire? [{p-weapon \:projectile-weapon}]\\r\\n  (let [cd (\:cooldown p-weapon)\\r\\n        curr-cd (\:curr-cooldown p-weapon)]\\r\\n    (if (<\= cd 0)\\r\\n      true\\r\\n      false)))" "(defn- can-fire? [{p-weapon \:projectile-weapon}]\\r\\n  (let [cd (\:cooldown p-weapon)\\r\\n        curr-cd (\:curr-cooldown p-weapon)]\\r\\n    (if (<\= cd 0)\\r\\n      true\\r\\n      false)))" "(can-fire? {\:projectile-weapon {\:cooldown 1.0, \:curr-cooldown 0.0}})" "(defn- can-fire? [{p-weapon \:projectile-weapon}]\\r\\n  (let [cd (\:cooldown p-weapon)\\r\\n        curr-cd (\:curr-cooldown p-weapon)]\\r\\n    (if (<\= curr-cd 0)\\r\\n      true\\r\\n      false)))" "(can-fire? {\:projectile-weapon {\:cooldown 1.0, \:curr-cooldown 0.0}})" "(defn- can-fire? [{p-weapon \:projectile-weapon}]\\r\\n  (if (<\= (\:curr-cooldown p-weapon) 0)\\r\\n    true\\r\\n    false))" "(can-fire? {\:projectile-weapon {\:curr-cooldown 0.0}})" "(defn fire [main-ent-id entities]\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\"\\n  (let [main-ent (main-ent-id entities)\\n        updated-main-ent (-> main-ent\\n                           (assoc-in [\:animation \:current-animation] \:fire-pistol)\\n                           (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\n                           (update main-ent-id dissoc \:combat-target-id))\\n        updated-entities (-> entities\\n                           (assoc main-ent-id updated-main-ent)\\n                           (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent))))))]\\n    updated-entities))" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (-> entities\\r\\n                                   (assoc-in [main-ent-id \:animation \:current-animation] \:fire-pistol)\\r\\n                                   ;(update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp 10)))\\r\\n                                   (update main-ent-id dissoc \:combat-target-id))\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree \\r\\n                       (bt/->Selector \:fresh 0 \\r\\n                                      [(bt/->Sequence \:fresh 0\\r\\n                                                      [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                       (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                       (bt/->Sequence \:fresh 0 \\r\\n                                                      [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                       (enemy-ai/->FindPath \:fresh)\\r\\n                                                       (enemy-ai/->FollowPath \:fresh)])]))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(projectile-weapon {})" "(projectile-weapon {}\\n                   \:cooldown 0.8 \\r\\n                   \:curr-cooldown 0.0 \\r\\n                   \:damage 10 \\r\\n                   \:max-ammo 9 \\r\\n                   \:current-ammo 9 \\r\\n                   \:reload-speed 5)" "(projectile-weapon {}\\n                   {\:cooldown 0.8 \\r\\n                   \:curr-cooldown 0.0 \\r\\n                   \:damage 10 \\r\\n                   \:max-ammo 9 \\r\\n                   \:current-ammo 9 \\r\\n                   \:reload-speed 5})" "(projectile-weapon {}\\n                   [\:cooldown 0.8 \\r\\n                   \:curr-cooldown 0.0 \\r\\n                   \:damage 10 \\r\\n                   \:max-ammo 9 \\r\\n                   \:current-ammo 9 \\r\\n                   \:reload-speed 5])" "(defn make-coffee [name amount water\\r\\n                   & {\:keys [milk sugar cinnamon]\\r\\n                      \:or {milk 0 sugar 0 cinnamon 0}}]\\r\\n  ;; definition goes here\\r\\n  )" "(make-coffee \\"Royale Coffee\\" 15 100\\r\\n             \:milk 10\\r\\n             \:cinnamon 3)" "(defn projectile-weapon [ent \\n                         & {\:keys [cooldown]}]\\r\\n  nil)" "(projectile-weapon {} \:cooldown 1)" "(defn projectile-weapon [ent & {\:keys [cooldown curr-cooldown damage max-ammo current-ammo reload-speed]}]\\r\\n  (assoc ent\\r\\n         \:projectile-weapon {\:cooldown cooldown\\r\\n                             \:curr-cooldown curr-cooldown\\r\\n                             \:damage damage\\r\\n                             \:max-ammo max-ammo\\r\\n                             \:current-ammo current-ammo\\r\\n                             \:reload-speed reload-speed}))" "(projectile-weapon {}\\n                   \:cooldown 0.8 \\r\\n                   \:curr-cooldown 0.0 \\r\\n                   \:damage 10 \\r\\n                   \:max-ammo 9 \\r\\n                   \:current-ammo 9 \\r\\n                   \:reload-speed 5)" "(app)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    ;(ecs/add-system death)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(sys/death game)" "(defn die [e]\\r\\n  (if (<\= (\:hit-points e) 0)\\r\\n    true\\r\\n    false))" "(die (get-in game [\:ecs \:entities 0]))" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e]\\r\\n               (if (<\= (\:hit-points e) 0)\\r\\n                 true\\r\\n                 false))]\\r\\n    (loop [q-ents qualifying-ents\\r\\n           ents-map (ent-vec->map ents)]\\r\\n      (if (empty? q-ents)\\r\\n        (into rest-ents (vals ents-map))\\r\\n        (recur \\r\\n          (rest q-ents)\\r\\n          (let [e (first q-ents)]\\r\\n            (if (die? e) (dissoc ents-map (keyword (str (\:id e)))) ents-map)))))))" "(death game)" "(require '[basic-combat-ai.main-screen \:as ms])" "(death ms/game)" "(vals [])" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(defn target-alive? [target-id entities]\\n  (boolean (target-id entities)))" "(defn fire [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (update main-ent-id dissoc \:combat-target-id))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent))))))]\\r\\n      updated-entities)\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (update main-ent-id dissoc \:combat-target-id))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent))))))]\\r\\n      updated-entities)\\r\\n    entities))\\r\\n\\r\\n(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n           (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (fire-weapon main-ent-id entities)\\r\\n                                 curr-tile-map)\\r\\n           \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 entities\\r\\n                                 curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(defn projectile-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\n  (let [[qualifying-ents rest-ents] (filter-ents entities \#(\:projectile-weapon %))\\n        tick-cooldown (fn [e]\\n                        (if (pos? (\:curr-cooldown (\:projectile-weapon e)))\\n                          (update-in e [\:projectile-weapon \:curr-cooldown] (fn [ccd] (- ccd delta)))\\n                          e))\\n        modified-ents (map tick-cooldown qualifying-ents)]\\n    (into rest-ents modified-ents)))" "(defn projectile-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:projectile-weapon %))\\n        tick-cooldown (fn [e]\\n                        (if (pos? (\:curr-cooldown (\:projectile-weapon e)))\\n                          (update-in e [\:projectile-weapon \:curr-cooldown] (fn [ccd] (- ccd delta)))\\n                          e))\\n        modified-ents (map tick-cooldown qualifying-ents)]\\n    (into rest-ents modified-ents)))" "(get-in ms/game [\:ecs \:entities])" "(projectile-weapon-cooldown ms/game)" "(defn projectile-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:projectile-weapon %))\\n        tick-cooldown (fn [e]\\n                        (if (pos? (\:curr-cooldown (\:projectile-weapon e)))\\n                          (update-in e [\:projectile-weapon \:curr-cooldown] (fn [ccd] (math-utils/round-to-decimal (- ccd delta) 1)))\\n                          e))\\n        modified-ents (map tick-cooldown qualifying-ents)]\\n    (into rest-ents modified-ents)))" "(<\= 0 0.0)" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:systems])" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(projectile-weapon-cooldown ms/game)" "(defn projectile-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:projectile-weapon %))\\r\\n        tick-cooldown (fn [e]\\r\\n                        (if (pos? (\:curr-cooldown (\:projectile-weapon e)))\\r\\n                          (update-in e [\:projectile-weapon \:curr-cooldown] (fn [ccd] (math-utils/round-to-decimal (- ccd delta) 2)))\\r\\n                          e))\\r\\n        modified-ents (map tick-cooldown qualifying-ents)]\\r\\n    (into rest-ents modified-ents)))" "(projectile-weapon-cooldown ms/game)" "(defn projectile-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:projectile-weapon %))\\r\\n        tick-cooldown (fn [e]\\r\\n                        (if (pos? (\:curr-cooldown (\:projectile-weapon e)))\\r\\n                          (update-in e [\:projectile-weapon \:curr-cooldown] (fn [ccd] (math-utils/round-to-decimal (- ccd delta) 3)))\\r\\n                          e))\\r\\n        modified-ents (map tick-cooldown qualifying-ents)]\\r\\n    (into rest-ents modified-ents)))" "(projectile-weapon-cooldown ms/game)" "(basic-combat-ai.desktop-launcher/reset)" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             target-ent ((\:combat-target-id main-ent) entities)\\r\\n             angle-to-face-target (-> \\r\\n                                    (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                    (math-utils/round-to-decimal 1))]\\r\\n         (cond\\r\\n           (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (if ((\:combat-target-id main-ent) entities)             \\n               (bt/make-return-map node\\r\\n                                   (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                   curr-tile-map)\\n               (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                   (update entities main-ent-id (fn [main-ent] (dissoc main-ent \:combat-target)))\\r\\n                                   curr-tile-map))\\r\\n             (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (fire-weapon main-ent-id entities)\\r\\n                                 curr-tile-map)\\r\\n             \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 (update entities main-ent-id (fn [main-ent] (dissoc main-ent \:combat-target)))\\r\\n                                 curr-tile-map)))))" "(app)" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(app)" "(\:hi {})" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(let [updated-ent (-> (get-in [\:ecs \:entities 0])\\n                    (assoc-in [\:behavior-tree \:tree \:status] \:running)\\n                    (assoc-in [\:behavior-tree \:tree \:children 1 \:status] \:running))]\\n  (bt/tick (get-in updated-ent [\:behavior-tree \:tree])))" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [updated-ent (-> (get-in ms/game [\:ecs \:entities 0])\\r\\n                    (assoc-in [\:behavior-tree \:tree \:status] \:running)\\r\\n                    (assoc-in [\:behavior-tree \:tree \:children 1 \:status] \:running))]\\r\\n  (bt/tick (get-in updated-ent [\:behavior-tree \:tree])))" "(let [updated-ent (-> (get-in ms/game [\:ecs \:entities 0])\\r\\n                    (assoc-in [\:behavior-tree \:tree \:status] \:running)\\r\\n                    (assoc-in [\:behavior-tree \:tree \:children 1 \:status] \:running))]\\r\\n  (bt/tick (get-in updated-ent [\:behavior-tree \:tree])\\n           \\n           ))" "(get-in ms/game [\:ecs \:entities 0])" "(app)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(update-game\! \#(pistoleer % 0 0))" "(ms/update-game\! \#(pistoleer % 0 0))" "(app)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(pistoleer ms/game 0 0)" "(ecs/add-entity ms/game (pistoleer ms/game 0 0))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entites 0 \:behavior-tree \:tree])" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])" "(\= (->TestLeaf \:fresh 0) (->TestLeaf \:fresh 0))" "(\= (->TestLeaf \:fresh 0) (->TestLeaf \:fresh 1))" "(defn make-node [node]\\n  (assoc node \:id 1))" "(make-node (->TestLeaf \:fresh 0))" "(def node-id-counter (atom 0N))" "(defn get-new-id []\\r\\n  (swap\! node-id-counter inc)\\r\\n  @entity-id-counter)" "(defn get-new-id []\\r\\n  (swap\! node-id-counter inc)\\r\\n  @node-id-counter)" "(get-new-id)" "(defn add-id [node]\\n  (assoc node \:id (get-new-id)))" "(defn add-ids-to-tree [node]\\n  (if-not (\:children node)\\n    (assoc node \:id (get-new-id))\\n    (assoc node \:children (mapv add-ids-to-tree (\:children node)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (if-not (\:children node)\\n    (assoc node \:id (get-new-id))\\n    (assoc (assoc node \:id (get-new-id)) \:children (mapv add-ids-to-tree (\:children node)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (let [children (\:children node)\\n        node-with-id (assoc node \:id (get-new-id))]\\r\\n    (if-not children\\r\\n      node-with-id\\r\\n      (assoc node-with-id \:children (mapv add-ids-to-tree children)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (\:id (pop composites))\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (\:id (pop composites))\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(defn add-ids-to-tree [node]\\n  (let [children (\:children node)\\n        node-with-id (assoc node \:id (get-new-id))]\\r\\n    (if-not children\\r\\n      node-with-id\\r\\n      (assoc node-with-id \:children (mapv add-ids-to-tree children)))))" "(get-id-of-running-composite (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (pop composites)\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(pop [1 2 3])" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (peek composites)\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(let [tree-with-ids (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n      running-comp (get-id-of-running-composite tree-with-ids)]\\n  [tree-with-ids running-comp])" "(ns basic-combat-ai.systems)" "(app)" "(ns basic-combat-ai.entities)" "(bt/add-ids-to-tree (comps/behavior-tree \\r\\n                      (bt/->Selector \:fresh 0 \\r\\n                                     [(bt/->Sequence \:fresh 0\\r\\n                                                     [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                      (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                      (bt/->Sequence \:fresh 0 \\r\\n                                                     [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                      (enemy-ai/->FindPath \:fresh)\\r\\n                                                      (enemy-ai/->FollowPath \:fresh)])])))" "(ns basic-combat-ai.entities)" "(bt/add-ids-to-tree \\n  (\:tree (comps/behavior-tree \\r\\n           (bt/->Selector \:fresh 0 \\r\\n                          [(bt/->Sequence \:fresh 0\\r\\n                                          [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                           (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                           (bt/->Sequence \:fresh 0 \\r\\n                                          [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                           (enemy-ai/->FindPath \:fresh)\\r\\n                                           (enemy-ai/->FollowPath \:fresh)])]))))" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (\:tree)\\r\\n                       (bt/add-ids-to-tree) \\r\\n                       )" "(ns basic-combat-ai.systems)" "(app)" "(ns basic-combat-ai.entities)" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#((bt/add-ids-to-tree))))" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#((bt/add-ids-to-tree %))))" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#(bt/add-ids-to-tree %)))" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(ns basic-combat-ai.entities)" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       )" "(pistoleer nil 0 0)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(pistoleer nil 0 0)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite root-node)\\r\\n                                   canceled-tick-data (-> (bt/cancel root-node) ;cancel then resets            \\r\\n                                                        (bt/tick ent-id ents-m t-map))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick root-node ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data (-> (bt/cancel checked-bt) ;cancel then resets            \\r\\n                                                        (bt/tick ent-id ents-m t-map))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(app)" "(ns basic-combat-ai.behavior-tree)" "(defrecord Sequence [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child)))\\n  NodeCancel\\n  (cancel [node main-ent-id entities tile-map]\\n    nil))" "(defrecord Sequence [status curr-child-idx children]\\n  NodeCancel\\r\\n  (cancel [node main-ent-id entities tile-map]\\r\\n    nil)\\n  \\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" ";only one leaf can be running at a time, so cancel just that guy." ";if no children and running, assume it's the only one" ";if it implements cancel, call it, and return it's results." "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node and returns it's results (results are same format as run).\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map node ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node and returns it's results (results are same format as run).\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map node ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])])" "(defrecord TestLeaf [status work-counter]\\n  NodeCancel \\n  (cancel [node main-ent-id entities tile-map]\\n    (make-return-map nil ;node is irrelevant\\n                     (assoc-in entities [main-ent-id \:canceled] true)\\n                     tile-map))\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    nil)\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (if (\= (\:work-counter node) 1)\\r\\n      {\:node (assoc node \:status \:success) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map}\\r\\n      {\:node (assoc node \:work-counter (inc (\:work-counter node))) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map})))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:fresh 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:running 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(rest [])" "(into (rest []) [1 2 3])" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(defn cancel-running-leaf [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(app)" "(ns basic-combat-ai.behavior-tree)" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:fresh 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:running 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(ns basic-combat-ai.behavior-tree)" "(ns basic-combat-ai.systems)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    ))" "(app)" "(ns basic-combat-ai.god-mode\\r\\n  (\:require [basic-combat-ai.ecs \:as ecs]\\r\\n            [basic-combat-ai.entities \:as ents]\\r\\n            [basic-combat-ai.systems \:as sys]\\r\\n            [basic-combat-ai.components \:as comps]\\r\\n            [basic-combat-ai.behavior-tree \:as bt]\\r\\n            [basic-combat-ai.main-screen \:as ms]\\r\\n            [basic-combat-ai.math-utils \:as math-utils]\\r\\n            [basic-combat-ai.tile-map \:as tile-map]))" "(defn add-pistoleer [x y]\\n  (ms/update-game\! \#(ecs/add-entity % (ents/pistoleer % x y))))" "(add-pistoleer 1 1)" "(app)" "(ecs/add-entity ms/game (ents/pistoleer ms/game x y))" "(app)" "(ns basic-combat-ai.god-mode\\r\\n  (\:require [basic-combat-ai.ecs \:as ecs]\\r\\n            [basic-combat-ai.components \:as comps]\\r\\n            [basic-combat-ai.behavior-tree \:as bt]\\r\\n            [basic-combat-ai.math-utils \:as math-utils]\\r\\n            [basic-combat-ai.tile-map \:as tile-map]))\\r\\n\\r\\n(defn add-pistoleer [x y]\\r\\n  (ms/update-game\! \#(ecs/add-entity % (ents/pistoleer % x y))))" "(get-in game [\:ecs \:entities 0])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 9999999999)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(get-in ms/game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 1])" "(get-in game [\:ecs \:entities 0])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n         (bt/make-return-map (assoc node \:status \:failure)\\r\\n                             (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                             curr-tile-map)\\r\\n         (let [main-ent (main-ent-id entities)\\r\\n               target-ent ((\:combat-target-id main-ent) entities)\\r\\n               angle-to-face-target (-> \\r\\n                                      (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                      (math-utils/round-to-decimal 1))]\\r\\n           [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities(run (->EngageCombatTarget \:running)\\r\\n               \:41\\r\\n               {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n               (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game))) bt/->EngageCombatTarget" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->TestLeaf \:running 0)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (->EngageCombatTarget \:running 0)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(app)" "(ns basic-combat-ai.enemy-ai)" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          nil))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:2\\r\\n                   {\:2 (get-in ms/game [\:ecs \:entities 0])\\n                    \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n                   (\:tile-map ms/game)))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              (los? main-ent target-ent curr-tile-map)))))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(get-in ms/game [\:ecs \:entities 0])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n         (bt/make-return-map (assoc node \:status \:failure)\\r\\n                             (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                             curr-tile-map)\\r\\n         (let [main-ent (main-ent-id entities)\\r\\n               target-ent ((\:combat-target-id main-ent) entities)\\r\\n               angle-to-face-target (-> \\r\\n                                      (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                      (math-utils/round-to-decimal 1))]\\r\\n           (cond\\r\\n             (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n             (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (fire-weapon main-ent-id entities)\\r\\n                                 curr-tile-map)\\r\\n             \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 (update entities main-ent-id (fn [main-ent] (dissoc main-ent \:combat-target)))\\r\\n                                 curr-tile-map))))))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:2\\r\\n                   {\:2 (get-in ms/game [\:ecs \:entities 0])\\n                    \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n                   (\:tile-map ms/game)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\n             tick-data)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(app)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in game [\:ecs \:entities 0])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities tick-data))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities checked-bt))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             checked-bt)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [id-existing id-canceled])))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 \\"b\\" ;(bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 \\"b\\"))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 (\= id-existing id-canceled)))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(defn get-id-of-running-composite [node]\\r\\n  (loop [unexplored [node]\\r\\n         composites []]      \\r\\n      (if (empty? unexplored)\\r\\n        (\:id (peek composites))\\r\\n        (let [unexp (first unexplored)\\r\\n              rest-unexplored (rest unexplored)]\\r\\n          (recur (if (\:children unexp) \\r\\n                   (into rest-unexplored (\:children unexp))\\r\\n                   rest-unexplored)\\r\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\r\\n                   (conj composites unexp)\\r\\n                   composites))))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled canceled-tick-data]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled (\:entities canceled-tick-data)]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities tick-data))))" "(get-in ms/game [\:ecs \:entities 0])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities checked-bt))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             checked-bt)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             ents-m)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys ents-m)\\n             (keys (\:entities tick-data))]\\n             )))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys (\:3 ents-m))\\n             (keys (\:3 (\:entities tick-data)))]\\n             )))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys (\:3 ents-m))\\n             (\:target-rotation (\:3 (\:entities tick-data)))]\\n             )))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 1] tick-behavior-tree))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 1 1)))" "(app)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 1 1)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 32)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 32)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(do \\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    game\\r\\n    (clear-screen)\\r\\n    (.update (\:camera game))\\r\\n    (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n    (-> game\\r\\n      (ecs/update-ecs))))" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    game\\r\\n    (do (clear-screen)\\r\\n      (.update (\:camera game))\\r\\n      (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n      (-> game\\r\\n        (ecs/update-ecs)))))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(require '[basic-combat-ai.main-screen \:as ms])" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\n  (ms/update-game\! \#(assoc % \:paused true)))" "(ns basic-combat-ai.entities)" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  (ms/update-game\! \#(assoc % \:paused true)))" "ms/update-game\! \#(assoc % \:paused false)" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  )" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  )" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(get-in ms/game [\:ecs \:entities])" "(apply \:id (get-in ms/game [\:ecs \:entities]))" "(apply \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(map \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(first (get-in ms/game [\:ecs \:entities]))" "(defrecord PickRandomTile [status]\\n  bt/NodeCancel\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\n    (bt/make-return-map (assoc node \:status \:failure)\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \:move-to)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (bt/make-return-map (assoc node \:status \:success) \\r\\n                          (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\n                          curr-tile-map))))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ms/update-game\! \#(assoc % \:pause true))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(dissoc % \:pause))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 1])" "(get-in game [\:ecs \:entities 2])" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities])" "(map \#(\:id %) (get-in game [\:ecs \:entities]))" "(map \#([(\:id %) (\:transform %)]) (get-in game [\:ecs \:entities]))" "(map \#((\:id %)) (get-in game [\:ecs \:entities]))" "(map \#([(\:id %)]) (get-in game [\:ecs \:entities]))" "(map \#((\:id %)) (get-in game [\:ecs \:entities]))" "(map \#(\:id %) (get-in game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e)]) (get-in game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e) (\:combat-target-id e)]) (get-in game [\:ecs \:entities]))" "(ns basic-combat-ai.enemy-ai)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 1])" "(\:9 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(let [main-ent (\:9 (ent-vec->map (get-in ms/game [\:ecs \:entities])))\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  reseted-tree)" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      ticked-tree (bt/tick \:9 ent-map (\:tile-map ms/game))]\\n  (\:9 (\:entities ticked-tree)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      ticked-tree (bt/tick reseted-tree \:9 ent-map (\:tile-map ms/game))]\\n  (\:9 (\:entities ticked-tree)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  (\:9 (\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                         \:9\\n                         ent-map\\n                         (\:tile-map ms/game)))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-true\\n      )))\\n\\n(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  (bt/run (->LocateACombatTarget \:fresh)\\n          \:9\\n          ent-map\\n          (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-true\\n      )))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (map \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:entity (\:id e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:entity e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:id (\:entity e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e)]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         ]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" ";so, calc distance is correct." "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  closest-ent\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  (\:id closest-ent)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n        (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n          (\:entity (first e-los))\\r\\n          closest-ent))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  ) ;FML" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  \\n  (rest ents-los-true)\\n  ) ;FML" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent \#(loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id closest-ent)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (recur (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               closest-ent)))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               closest-ent)))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)])))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)]))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    e-los)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      \\"wtf\\"\\r\\n      [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)]))\\n  )" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (first ents-los-true)]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:9 (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n                         \:9\\r\\n                         ent-map\\r\\n                         (\:tile-map ms/game)))))" "(map \#([\:id %]) (get-in ms/game [\:ecs \:entities]))" "(map (fn [e] [\:id e]) (get-in ms/game [\:ecs \:entities]))" "(get-in ms/game [\:ecs \:entities])" "(map (fn [e] [(\:id e)]) (get-in ms/game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e)]) (get-in ms/game [\:ecs \:entities]))" "(ms/update-game\! \#(assoc % \:paused false))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn renderable \\n  [ent texture]\\n    (renderable ent texture 1 1)\\n  [ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y))" "(defn renderable \\n  ([ent texture]\\n    (renderable ent texture 1 1)\\n  [ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y)))" "(defn renderable \\n  ([ent texture]\\n    (renderable ent texture 1 1))\\n  ([ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y)))" "(defn renderable \\r\\n  ([ent texture]\\r\\n    (renderable ent texture 1 1))\\r\\n  ([ent texture scale-x scale-y]\\r\\n    (assoc ent \\r\\n           \:renderable {\:texture texture\\r\\n                        \:scale-x scale-x\\r\\n                        \:scale-y scale-y})))" "(renderable {} \\"some texture\\" 2 2)" "(renderable {} \\"some texture\\")" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (comps/renderable (\:pistol-idle tex-cache))\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(ns basic-combat-ai.main-screen)" "game" "(get-in game [\:ecs \:entities])" "(\:renderable (get-in game [\:ecs \:entities 0]))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(render ms/game)" "ffffffffff" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n;    (.setProjectionMatrix batch (.combined cam))\\r\\n;    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation])))]\\n          (println texture-region)\\r\\n;              width (float (.getRegionWidth texture-region))\\r\\n;              height (float (.getRegionHeight texture-region))]\\r\\n;          (.draw batch texture-region x y origin-x origin-y width height (float 1) (float 1) rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n;    (.end batch))\\r\\n  ents))" "(render ms/game)" "(map \#(\:renderable %) (render ms/game))" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n;    (.setProjectionMatrix batch (.combined cam))\\r\\n;    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation])))]\\r\\n;              width (float (.getRegionWidth texture-region))\\r\\n;              height (float (.getRegionHeight texture-region))]\\r\\n;          (.draw batch texture-region x y origin-x origin-y width height (float 1) (float 1) rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n;    (.end batch))\\r\\n  ents))" "(map \#(\:renderable %) (render ms/game))" "wtf" "(\:renderable (get-in ms/game [\:ecs \:entities]))" "(map \#(\:renderable %) (get-in ms/game [\:ecs \:entities]))" "?????????????????????????" "clojure.core/when" ";oh" ";the ai" "(app)" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n    (.setProjectionMatrix batch (.combined cam))\\r\\n    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation]))) \\r\\n              width (float (.getRegionWidth texture-region))\\r\\n              height (float (.getRegionHeight texture-region))\\r\\n              scale-x (float (\:scale-x (\:renderable e)))\\r\\n              scale-y (float(\:scale-y (\:renderable e)))]\\r\\n          (.draw batch texture-region x y origin-x origin-y width height scale-x scale-y rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n    (.end batch))\\r\\n  ents)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 0] render))" "(ns basic-combat-ai.main-screen)" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion tracer \\"tracer\\")\\r\\n     }))" ";hmm" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion tracer \\"tracer\\")\\r\\n     }))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    (-> atlas\\r\\n    {\:fire-pistol00 (.findRegion \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     })))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    (-> atlas\\r\\n    {\:fire-pistol00 (.findRegion \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion \\"pistol idle\\")\\r\\n     \:floor (.findRegion \\"floor\\")\\r\\n     \:wall (.findRegion \\"wall\\")\\r\\n     \:tracer (.findRegion \\"tracer\\")\\r\\n     })))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(ns basic-combat-ai.main-screen \:as ms)" "(ns '[basic-combat-ai.main-screen \:as ms])" ";why is my brain dead" "(ns basic-combat-ai.main-screen)" "(require '[basic-combat-ai.components \:as comps])" "(-> {}\\n  (comps/renderable (\:tracer (\:tex-cache ms/game)) 1 1)\\n  (assoc \:transform (comps/transform 0 0 0 16 16)))" "(-> {}\\n  (comps/renderable (\:tracer (\:tex-cache game)) 1 1)\\n  (assoc \:transform (comps/transform 0 0 0 16 16)))" "(update-game\! \#(ecs/add-entity % (-> {}\\r\\n                                   (comps/renderable (\:tracer (\:tex-cache game)) 1 1)\\r\\n                                   (assoc \:transform (comps/transform 0 0 0 16 16)))))" ";uhg" "(app)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) x y scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(tracer (\:tex-cache ms/game) 0 0 1 1)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(tracer (\:tex-cache ms/game) 0 0 1 1)" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [old-ents] (conj old-ents (tracer (\:tex-cache %) 0 0 1 1)))))" ";oops" "(app)" "(ns basic-combat-ai.main-screen)" "(\:tex-cache game)" "(\:tracer (\:tex-cache game))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(tracer ms/game 0 0 1 1)" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [old-ents] (conj old-ents (tracer % 0 0 1 1)))))" "(get-in ms/game [\:ecs \:entities 1])" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [t] (assoc t \:x 16 \:y 16))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 2 \:scale-y 2))))" ";what, why did the x and y reset.." "(get-in ms/game [\:ecs \:entities 1])" ";oh hmm what.." ";origin should be 0?" ";mebe.." "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 0 \:origin-y 0))))" ";mebe.." "(get-in ms/game [\:ecs \:entities 1])" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 3 \:scale-y 3))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 10 \:scale-y 10))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 90))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 45))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 3 \:origin-y 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 1 \:origin-y 0))))" ";oh my god it's scaled then origin is applied.." ";........." "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 0 \:origin-y 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 1 \:scale-y 10))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 1 \:scale-y 100))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (pop ents))))" "(get-in ms/game [\:ecs \:entities])" ";2?" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.entities \:as ent-ns])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hp (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(into {} (filter (fn [e] (\:hp (second e))) (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(ent-vec->map (get-in ms/game [\:ecs \:entities]))" "(into {} (filter (fn [e] (\:hit-points (second e))) (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pending-entity [create-entity-fn]\\r\\n  \\"create-entity-fn should be a function from the entity namespace.\\r\\n   It should probably be a partial, with everything except for the game map (first param) filled in.\\r\\n   The expectation is that a system will use this function to replace this entity with whatever entity \\r\\n   pops out of the function.\\"\\r\\n  {\:pending-entity create-entity-fn})" "(pending-entity \#(tracer % 16 16 1 1))" "(let [create-ent-fn (pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (comps/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.components \:as comps])" "(let [create-ent-fn (comps/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (ents-ns/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.entities \:as ents-ns])" "(let [create-ent-fn (ents-ns/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (\:pending-entity (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [create-ent-fn (\:pending-entity (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))]\\r\\n  (create-ent-fn ms/game))" "(assoc [1 2 3] 1 \\"a\\")" "(update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))" "(get-in (update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))) [\:ecs \:entities])" "(count (get-in (update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))) [\:ecs \:entities]))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))))" "(update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))))" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))))" "(count (get-in ms/game [\:ecs \:entities]))" "(get-in ms/game [\:ecs \:entities])" "(defn create-pending-entity [{{entities \:entities} \:ecs \:as game}]\\n  (loop [idx 0\\n         ents entities]\\n    (if (\= idx (count ents))\\n      ents\\n      (recur (inc idx)\\n             (if-let [create-entity-fn (\:pending-entity (nth ents idx))]\\n               (assoc ents idx (create-pending-entity game))\\n               ents)))))" "(get-in ms/game [\:ecs \:entities])" "(create-pending-entity ms/game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn create-pending-entity [{{entities \:entities} \:ecs \:as game}]\\n  (loop [idx 0\\n         ents entities]\\n    (if (\= idx (count ents))\\n      ents\\n      (recur (inc idx)\\n             (if-let [create-entity-fn (\:pending-entity (nth ents idx))]\\n               (assoc ents idx (create-entity-fn game))\\n               ents)))))" "(create-pending-entity ms/game)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" ";(ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc  (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(require '[basic-combat-ai.ecs \:as ecs])" "(keyword 1)" "(keyword \\"1\\")" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.ecs \:as ecs])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(require '[basic-combat-ai.entities \:as ents-ns])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities])" "(keys (get-in ms/game [\:ecs \:entities]))" "(map \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             ;(assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             ;(assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(app)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn timed-life [ent life-in-seconds]\\r\\n  (assoc ent\\r\\n         \:timed-life life-in-seconds))" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (comps/timed-life 0.1)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [entities ents\\n         result-ents []]\\n    (if (empty? entities)\\n      result-ents\\n      (let [e (first entities)]\\n        (if (\:timed-life e)\\n          \\"i have it\\"\\n          (recur (rest entities)\\n                 []))))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)]\\n        (if (\:timed-life e)\\n          \\"i have it\\"\\n          (recur (rest ents)\\n                 []))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (\=< (- timed-life delta) 0))\\n          (recur (rest ents) result-ents)\\n          (recur (rest ents) (into result-ents e)))))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) result-ents)\\n          (recur (rest ents) (into result-ents e)))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) entities)\\n          (recur (rest ents) entities))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) e)\\n          (recur (rest ents) e))))))" "(timed-life ms/game)" "(into [] {\:a \\"1\\"})" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) result-ents)\\r\\n          (recur (rest ents) (conj result-ents e)))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) result-ents)\\r\\n          (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta))))\\r\\n          (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\"a\\"\\n          \:else \\"b\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            (recur (rest ents) (assoc e \:timed-life (- timed-life delta))))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            \\"a\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          (nil? timed-life)\\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            \\"a\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          (nil? timed-life)\\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            (recur (rest ents) (assoc e \:timed-life (- timed-life delta))))))))" "(timed-life ms/game)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s timed-life))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(app)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc % \:paused true))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n            updated-entities (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \#(projectile/tracer % tracer-id (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \#(projectile/tracer % tracer-id (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.1)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            \\"A\\")))))" "(timed-life ms/game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(nil? 0)" "(nil? 0N)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (println timed-life)\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\n        \\"a\\"))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            ]\\n        \\"a\\"))))" "(timed-life ms/game)" "(get-in ms/game [\:ecs \:entities])" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(timed-life game)" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      (\:x main-ent-transform) \\r\\n                                                                      (\:y main-ent-transform) \\r\\n                                                                      2 \\r\\n                                                                      10 \\r\\n                                                                      (\:rotation main-ent-transform))))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcer/reset)" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      (+ (\:x main-ent-transform)\\r\\n                                                                         (\:origin-x main-ent-transform))\\r\\n                                                                      (+ (\:y main-ent-transform)\\r\\n                                                                         (\:origin-y main-ent-transform))\\r\\n                                                                      2 \\r\\n                                                                      10 \\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                     ((\:combat-target-id main-ent) entities))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7)\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ns basic-combat-ai.enemy-ai)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ms/update-game\! \#(assoc % \:paused false))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc % \:paused false))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (println (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                                   ((\:combat-target-id main-ent) entities))\\r\\n                                                                                    7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn distance [e1 e2] \\r\\n  (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n        {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(defn distance \\r\\n  ([e1 e2] \\r\\n    (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n          {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n      (distance x0 y0 x1 y1)))\\r\\n  ([x0 y0 x1 y1]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(distance 0 0 32 32)" "(distance 32 32 0 0)" " (require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 64 64))\\r\\n    ))" "(\= game-loop game-loop)" "(\= game-loop last-fps)" "(\= game-loop init-game)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 128 128))\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(assoc [1 2 3] 0 \\"\\")" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\n  (ms/update-game\! (fn [g] (-> g\\n                             (tick-behavior-tree)\\n                             (create-pending-entity)\\n                             (projectile-weapon-cooldown)\\n                             (animate)\\n                             (rotate)\\n                             (move)\\n                             (death)\\n                             (timed-life)))))" "(run-game)" "(app)" "(ns basic-combat-ai.main-screen)" "(defn run-game []\\r\\n  (update-game\! (fn [g] (-> g\\r\\n                          (tick-behavior-tree)\\r\\n                          (create-pending-entity)\\r\\n                          (projectile-weapon-cooldown)\\r\\n                          (animate)\\r\\n                          (rotate)\\r\\n                          (move)\\r\\n                          (death)\\r\\n                          (timed-life)))))" "(ns basic-combat-ai.systems)" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(-> ms/game\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(-> (get-in ms/game [\:ecs \:entities])\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game '[(tick-behavior-tree)\\r\\n                    (create-pending-entity)\\r\\n                    (projectile-weapon-cooldown)\\r\\n                    (animate)\\r\\n                    (rotate)\\r\\n                    (move)\\r\\n                    (death)\\r\\n                    (timed-life)])" "(run-game ms/game '((tick-behavior-tree)\\r\\n                   (create-pending-entity)\\r\\n                   (projectile-weapon-cooldown)\\r\\n                   (animate)\\r\\n                   (rotate)\\r\\n                   (move)\\r\\n                   (death)\\r\\n                   (timed-life)))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life]) \\n        [\:ecs \:entities])" "(ms/update-game\! (run-game ms/game [tick-behavior-tree\\r\\n                                    create-pending-entity\\r\\n                                    projectile-weapon-cooldown\\r\\n                                    animate\\r\\n                                    rotate\\r\\n                                    move\\r\\n                                    death\\r\\n                                    timed-life]))" "(ms/update-game\! \#(run-game % [tick-behavior-tree\\r\\n                               create-pending-entity\\r\\n                               projectile-weapon-cooldown\\r\\n                               animate\\r\\n                               rotate\\r\\n                               move\\r\\n                               death\\r\\n                               timed-life]))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life])" "(keys (run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life]))" "(ms/update-game\! \#(assoc-in %\\n                            [\:ecs \:entities]\\n                            (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                    [\:ecs \:entities])))" "(defn run-once (ms/update-game\! \#(assoc-in %\\n                                           [\:ecs \:entities]\\n                                           (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                   [\:ecs \:entities]))))" "(defn run-once [] (ms/update-game\! \#(assoc-in %\\n                                              [\:ecs \:entities]\\n                                              (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                      [\:ecs \:entities]))))" "(get-in (run-game % [tick-behavior-tree\\r\\n                     create-pending-entity\\r\\n                     projectile-weapon-cooldown\\r\\n                     animate\\r\\n                     rotate\\r\\n                     move\\r\\n                     death\\r\\n                     timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(tick-behavior-tree ms/game)" "(nth (tick-behavior-tree ms/game) 0)" "(nth (tick-behavior-tree ms/game) 1)" "(nth (tick-behavior-tree ms/game) 2)" "(nth (tick-behavior-tree ms/game) 3)" "(nth (tick-behavior-tree ms/game) 2)" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)))" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)) ms/game)" "(create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game)))" "(count (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))))" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 0)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 1)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 2)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 3)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 10000)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ns basic-combat-ai.systems)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(\:delta ms/game)" "(run-once)" "(math-utils/distance 0 0 32 32)" "(use 'clojure.math.numeric-tower)" "(Math/sqrt \\n  (+ (Math/pow (- 32 0) 2)\\n     (Math/pow (- 32 0) 2)))" "(defn euclidean-distance [x0 y0 x1 y1]\\r\\n  (Math/sqrt \\r\\n    (+ (Math/pow (- x1 x0) 2)\\r\\n       (Math/pow (- y1 y0) 2))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(run-once)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities ms/game)" "ms/game" "(get-in ms/game [\:ecs \:entities])" "(fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:29 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(ns basic-combat-ai.systems)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           ;create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(ns basic-combat-ai.enemy-ai)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "((\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:41 (\:pending-entity (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(\:41 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:44 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:48 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "((\:pending-entity (\:49 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform)))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in entities [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                   (- hp (\:damage (\:projectile-weapon main-ent))))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:52 (pending-tracer-added\\n                        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                        (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))))" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance \\r\\n                                                tracer-x tracer-y\\r\\n                                                (\:x combat-target-transform) (\:y combat-target-transform))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "((\:pending-entity (\:54 (pending-tracer-added\\n                         (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                         (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))) ms/game)" "(\:entities (\:ecs ms/game))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.enemy-ai)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y rotation]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.05)\\r\\n    (assoc \:transform (comps/transform x y rotation 0 0))))" "(ns basic-combat-ai.systems)" "(run-once)" "(conj [1 2 3] 4 5 6)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s \\n                                                             tick-behavior-tree\\n                                                             create-pending-entity\\n                                                             projectile-weapon-cooldown\\n                                                             animate\\n                                                             rotate\\n                                                             move\\n                                                             death\\n                                                             timed-life))))" "(ns basic-combat-ai.entities)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+128 64)))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" "(ns basic-combat-ai.enemy-ai)" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (math-utils/distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))"]
eclipse.preferences.version=1
