cmdhistory=["(get-in ms/game [\:ecs \:entites 0 \:behavior-tree \:tree])" "(get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])" "(\= (->TestLeaf \:fresh 0) (->TestLeaf \:fresh 0))" "(\= (->TestLeaf \:fresh 0) (->TestLeaf \:fresh 1))" "(defn make-node [node]\\n  (assoc node \:id 1))" "(make-node (->TestLeaf \:fresh 0))" "(def node-id-counter (atom 0N))" "(defn get-new-id []\\r\\n  (swap\! node-id-counter inc)\\r\\n  @entity-id-counter)" "(defn get-new-id []\\r\\n  (swap\! node-id-counter inc)\\r\\n  @node-id-counter)" "(get-new-id)" "(defn add-id [node]\\n  (assoc node \:id (get-new-id)))" "(defn add-ids-to-tree [node]\\n  (if-not (\:children node)\\n    (assoc node \:id (get-new-id))\\n    (assoc node \:children (mapv add-ids-to-tree (\:children node)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (if-not (\:children node)\\n    (assoc node \:id (get-new-id))\\n    (assoc (assoc node \:id (get-new-id)) \:children (mapv add-ids-to-tree (\:children node)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (let [children (\:children node)\\n        node-with-id (assoc node \:id (get-new-id))]\\r\\n    (if-not children\\r\\n      node-with-id\\r\\n      (assoc node-with-id \:children (mapv add-ids-to-tree children)))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn add-ids-to-tree [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (\:id (pop composites))\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (\:id (pop composites))\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(defn add-ids-to-tree [node]\\n  (let [children (\:children node)\\n        node-with-id (assoc node \:id (get-new-id))]\\r\\n    (if-not children\\r\\n      node-with-id\\r\\n      (assoc node-with-id \:children (mapv add-ids-to-tree children)))))" "(get-id-of-running-composite (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree])))" "(add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (pop composites)\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(pop [1 2 3])" "(defn get-id-of-running-composite [node]\\n  (loop [unexplored [node]\\n         composites []]      \\n      (if (empty? unexplored)\\n        (peek composites)\\n        (let [unexp (first unexplored)\\n              rest-unexplored (rest unexplored)]\\n          (recur (if (\:children unexp) \\n                   (into rest-unexplored (\:children unexp))\\n                   rest-unexplored)\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\n                   (conj composites unexp)\\n                   composites))))))" "(-> (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n  (get-id-of-running-composite))" "(let [tree-with-ids (add-ids-to-tree (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))\\n      running-comp (get-id-of-running-composite tree-with-ids)]\\n  [tree-with-ids running-comp])" "(ns basic-combat-ai.systems)" "(app)" "(ns basic-combat-ai.entities)" "(bt/add-ids-to-tree (comps/behavior-tree \\r\\n                      (bt/->Selector \:fresh 0 \\r\\n                                     [(bt/->Sequence \:fresh 0\\r\\n                                                     [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                      (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                      (bt/->Sequence \:fresh 0 \\r\\n                                                     [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                      (enemy-ai/->FindPath \:fresh)\\r\\n                                                      (enemy-ai/->FollowPath \:fresh)])])))" "(ns basic-combat-ai.entities)" "(bt/add-ids-to-tree \\n  (\:tree (comps/behavior-tree \\r\\n           (bt/->Selector \:fresh 0 \\r\\n                          [(bt/->Sequence \:fresh 0\\r\\n                                          [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                           (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                           (bt/->Sequence \:fresh 0 \\r\\n                                          [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                           (enemy-ai/->FindPath \:fresh)\\r\\n                                           (enemy-ai/->FollowPath \:fresh)])]))))" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (\:tree)\\r\\n                       (bt/add-ids-to-tree) \\r\\n                       )" "(ns basic-combat-ai.systems)" "(app)" "(ns basic-combat-ai.entities)" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#((bt/add-ids-to-tree))))" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#((bt/add-ids-to-tree %))))" "(->  \\r\\n  (comps/behavior-tree \\r\\n    (bt/->Selector \:fresh 0 \\r\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])]))\\r\\n  (update \:tree \#(bt/add-ids-to-tree %)))" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(ns basic-combat-ai.entities)" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))" "(->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       )" "(pistoleer nil 0 0)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(pistoleer nil 0 0)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite root-node)\\r\\n                                   canceled-tick-data (-> (bt/cancel root-node) ;cancel then resets            \\r\\n                                                        (bt/tick ent-id ents-m t-map))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick root-node ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data (-> (bt/cancel checked-bt) ;cancel then resets            \\r\\n                                                        (bt/tick ent-id ents-m t-map))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(app)" "(ns basic-combat-ai.behavior-tree)" "(defrecord Sequence [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child)))\\n  NodeCancel\\n  (cancel [node main-ent-id entities tile-map]\\n    nil))" "(defrecord Sequence [status curr-child-idx children]\\n  NodeCancel\\r\\n  (cancel [node main-ent-id entities tile-map]\\r\\n    nil)\\n  \\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" ";only one leaf can be running at a time, so cancel just that guy." ";if no children and running, assume it's the only one" ";if it implements cancel, call it, and return it's results." "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node and returns it's results (results are same format as run).\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map node ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node and returns it's results (results are same format as run).\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map node ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])])" "(defrecord TestLeaf [status work-counter]\\n  NodeCancel \\n  (cancel [node main-ent-id entities tile-map]\\n    (make-return-map nil ;node is irrelevant\\n                     (assoc-in entities [main-ent-id \:canceled] true)\\n                     tile-map))\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    nil)\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (if (\= (\:work-counter node) 1)\\r\\n      {\:node (assoc node \:status \:success) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map}\\r\\n      {\:node (assoc node \:work-counter (inc (\:work-counter node))) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map})))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:fresh 0\\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:running 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(rest [])" "(into (rest []) [1 2 3])" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn cancel [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel tree\\n          \:1 \\n          {\:1 {\:id 1}}\\n          nil))" "(defn cancel-running-leaf [node main-ent-id ent-m tile-map]\\n  \\"Calls cancel on the running leaf node.\\n   Returns\: {\:node nil ;this is always nil, cancel is used for updating the ents/map not the tree\\n             \:entities {...}\\n             \:tile-map {...}\\n   Assumptions\: There is only one leaf in a tree that is \:running.\\"\\n  (loop [unexplored [node]]\\n    (if (empty? unexplored)\\n      ;There was nothing to cancel.\\n      (make-return-map nil ent-m tile-map)\\n      (let [unexp (first unexplored)]\\n        (cond \\n          (and (not (\:children unexp)) (\= (\:status unexp) \:running) (satisfies? NodeCancel unexp))\\n            (cancel unexp main-ent-id ent-m tile-map)\\n          (and (\:children unexp) (\= (\:status unexp) \:running))\\n            (recur (into (rest unexplored) (\:children unexp)))\\n          \:else \\n            (recur (rest unexplored)))))))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(app)" "(ns basic-combat-ai.behavior-tree)" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:running 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:running 1)])\\r\\n                           (->Sequence \:fresh 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(let [tree (->Selector \:running 0 \\r\\n                          [(->Sequence \:fresh 0\\r\\n                                          [(->TestLeaf \:success 1)\\r\\n                                           (->TestLeaf \:fresh 1)])\\r\\n                           (->Sequence \:running 0 \\r\\n                                          [(->TestLeaf \:fresh 1)\\r\\n                                           (->TestLeaf \:running 1)\\r\\n                                           (->TestLeaf \:fresh 1)])])]\\n  (cancel-running-leaf tree\\n                       \:1 \\n                       {\:1 {\:id 1}}\\n                       nil))" "(ns basic-combat-ai.behavior-tree)" "(ns basic-combat-ai.systems)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) (\:running))\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    ))" "(app)" "(ns basic-combat-ai.god-mode\\r\\n  (\:require [basic-combat-ai.ecs \:as ecs]\\r\\n            [basic-combat-ai.entities \:as ents]\\r\\n            [basic-combat-ai.systems \:as sys]\\r\\n            [basic-combat-ai.components \:as comps]\\r\\n            [basic-combat-ai.behavior-tree \:as bt]\\r\\n            [basic-combat-ai.main-screen \:as ms]\\r\\n            [basic-combat-ai.math-utils \:as math-utils]\\r\\n            [basic-combat-ai.tile-map \:as tile-map]))" "(defn add-pistoleer [x y]\\n  (ms/update-game\! \#(ecs/add-entity % (ents/pistoleer % x y))))" "(add-pistoleer 1 1)" "(app)" "(ecs/add-entity ms/game (ents/pistoleer ms/game x y))" "(app)" "(ns basic-combat-ai.god-mode\\r\\n  (\:require [basic-combat-ai.ecs \:as ecs]\\r\\n            [basic-combat-ai.components \:as comps]\\r\\n            [basic-combat-ai.behavior-tree \:as bt]\\r\\n            [basic-combat-ai.math-utils \:as math-utils]\\r\\n            [basic-combat-ai.tile-map \:as tile-map]))\\r\\n\\r\\n(defn add-pistoleer [x y]\\r\\n  (ms/update-game\! \#(ecs/add-entity % (ents/pistoleer % x y))))" "(get-in game [\:ecs \:entities 0])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 9999999999)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(get-in ms/game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 1])" "(get-in game [\:ecs \:entities 0])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n         (bt/make-return-map (assoc node \:status \:failure)\\r\\n                             (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                             curr-tile-map)\\r\\n         (let [main-ent (main-ent-id entities)\\r\\n               target-ent ((\:combat-target-id main-ent) entities)\\r\\n               angle-to-face-target (-> \\r\\n                                      (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                      (math-utils/round-to-decimal 1))]\\r\\n           [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities(run (->EngageCombatTarget \:running)\\r\\n               \:41\\r\\n               {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n               (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game))) bt/->EngageCombatTarget" "(\:entities (bt/run (bt/->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (bt/->TestLeaf \:running 0)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (->EngageCombatTarget \:running 0)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(app)" "(ns basic-combat-ai.enemy-ai)" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          nil))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:41\\r\\n                   {\:41 (get-in ms/game [\:ecs \:entities 0])}\\r\\n                   (\:tile-map ms/game)))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              [(\:rotation (\:transform main-ent)) angle-to-face-target]))))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:2\\r\\n                   {\:2 (get-in ms/game [\:ecs \:entities 0])\\n                    \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n                   (\:tile-map ms/game)))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" " (defrecord EngageCombatTarget [status]\\r\\n        bt/NodeBehavior\\r\\n        (bt/reset [node] \\r\\n          (assoc node \:status \:fresh))\\r\\n        (bt/run [node main-ent-id entities curr-tile-map]\\r\\n          (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n            (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                                curr-tile-map)\\r\\n            (let [main-ent (main-ent-id entities)\\r\\n                  target-ent ((\:combat-target-id main-ent) entities)\\r\\n                  angle-to-face-target (-> \\r\\n                                         (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                         (math-utils/round-to-decimal 1))]\\r\\n              (los? main-ent target-ent curr-tile-map)))))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(get-in ms/game [\:ecs \:entities 0])" "(defrecord EngageCombatTarget [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n         (bt/make-return-map (assoc node \:status \:failure)\\r\\n                             (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                             curr-tile-map)\\r\\n         (let [main-ent (main-ent-id entities)\\r\\n               target-ent ((\:combat-target-id main-ent) entities)\\r\\n               angle-to-face-target (-> \\r\\n                                      (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                      (math-utils/round-to-decimal 1))]\\r\\n           (cond\\r\\n             (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n             (bt/make-return-map node\\r\\n                                 (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                                 curr-tile-map)\\r\\n             (los? main-ent target-ent curr-tile-map)\\r\\n             (bt/make-return-map (assoc node \:status \:success)\\r\\n                                 (fire-weapon main-ent-id entities)\\r\\n                                 curr-tile-map)\\r\\n             \:else \\r\\n             (bt/make-return-map (assoc node \:status \:failure)\\r\\n                                 (update entities main-ent-id (fn [main-ent] (dissoc main-ent \:combat-target)))\\r\\n                                 curr-tile-map))))))" "(bt/run (->EngageCombatTarget \:running)\\r\\n        \:2\\r\\n        {\:2 (get-in ms/game [\:ecs \:entities 0])\\n         \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n        (\:tile-map ms/game))" "(\:entities (bt/run (->EngageCombatTarget \:running)\\r\\n                   \:2\\r\\n                   {\:2 (get-in ms/game [\:ecs \:entities 0])\\n                    \:1 (get-in ms/game [\:ecs \:entities 1])}\\r\\n                   (\:tile-map ms/game)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\n             tick-data)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(app)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (\:pistol-idle tex-cache)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n      ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n      ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n      \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n      \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in game [\:ecs \:entities 0])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-map t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-map t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-map t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities tick-data))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities checked-bt))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             checked-bt)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [id-existing id-canceled])))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 \\"b\\" ;(bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 \\"b\\"))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 (\= id-existing id-canceled)))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(defn get-id-of-running-composite [node]\\r\\n  (loop [unexplored [node]\\r\\n         composites []]      \\r\\n      (if (empty? unexplored)\\r\\n        (\:id (peek composites))\\r\\n        (let [unexp (first unexplored)\\r\\n              rest-unexplored (rest unexplored)]\\r\\n          (recur (if (\:children unexp) \\r\\n                   (into rest-unexplored (\:children unexp))\\r\\n                   rest-unexplored)\\r\\n                 (if (and (\:children unexp) (\= (\:status unexp) \:running))\\r\\n                   (conj composites unexp)\\r\\n                   composites))))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled canceled-tick-data]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite canceled-tick-data)]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled (\:entities canceled-tick-data)]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             tick-data)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities tick-data))))" "(get-in ms/game [\:ecs \:entities 0])" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             (\:entities checked-bt))))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             checked-bt)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             ents-m)))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys ents-m)\\n             (keys (\:entities tick-data))]\\n             )))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys (\:3 ents-m))\\n             (keys (\:3 (\:entities tick-data)))]\\n             )))" "(let [q-ents (get-in ms/game [\:ecs \:entities]) ;only use this for the id's. \\r\\n             ents-m (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n              t-map (\:tile-map ms/game)]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 [id-existing id-canceled]))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))]\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             \\r\\n             [(keys (\:3 ents-m))\\n             (\:target-rotation (\:3 (\:entities tick-data)))]\\n             )))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (\= id-existing id-canceled)\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 1] tick-behavior-tree))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 1 1)))" "(app)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 1 1)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 32)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 32)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(do \\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    game\\r\\n    (clear-screen)\\r\\n    (.update (\:camera game))\\r\\n    (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n    (-> game\\r\\n      (ecs/update-ecs))))" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    game\\r\\n    (do (clear-screen)\\r\\n      (.update (\:camera game))\\r\\n      (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n      (-> game\\r\\n        (ecs/update-ecs)))))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(require '[basic-combat-ai.main-screen \:as ms])" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\n  (ms/update-game\! \#(assoc % \:paused true)))" "(ns basic-combat-ai.entities)" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  (ms/update-game\! \#(assoc % \:paused true)))" "ms/update-game\! \#(assoc % \:paused false)" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  )" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(do\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32)))\\r\\n  )" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(get-in ms/game [\:ecs \:entities])" "(apply \:id (get-in ms/game [\:ecs \:entities]))" "(apply \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(map \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(first (get-in ms/game [\:ecs \:entities]))" "(defrecord PickRandomTile [status]\\n  bt/NodeCancel\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\n    (bt/make-return-map (assoc node \:status \:failure)\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \:move-to)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (bt/make-return-map (assoc node \:status \:success) \\r\\n                          (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\n                          curr-tile-map))))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ms/update-game\! \#(assoc % \:pause true))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(dissoc % \:pause))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities 1])" "(get-in game [\:ecs \:entities 2])" "(get-in game [\:ecs \:entities 0])" "(get-in game [\:ecs \:entities])" "(map \#(\:id %) (get-in game [\:ecs \:entities]))" "(map \#([(\:id %) (\:transform %)]) (get-in game [\:ecs \:entities]))" "(map \#((\:id %)) (get-in game [\:ecs \:entities]))" "(map \#([(\:id %)]) (get-in game [\:ecs \:entities]))" "(map \#((\:id %)) (get-in game [\:ecs \:entities]))" "(map \#(\:id %) (get-in game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e)]) (get-in game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e) (\:combat-target-id e)]) (get-in game [\:ecs \:entities]))" "(ns basic-combat-ai.enemy-ai)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 1])" "(\:9 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(let [main-ent (\:9 (ent-vec->map (get-in ms/game [\:ecs \:entities])))\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  reseted-tree)" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      ticked-tree (bt/tick \:9 ent-map (\:tile-map ms/game))]\\n  (\:9 (\:entities ticked-tree)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      ticked-tree (bt/tick reseted-tree \:9 ent-map (\:tile-map ms/game))]\\n  (\:9 (\:entities ticked-tree)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  (\:9 (\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                         \:9\\n                         ent-map\\n                         (\:tile-map ms/game)))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-true\\n      )))\\n\\n(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      main-ent (\:9 ent-map)\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\n  (bt/run (->LocateACombatTarget \:fresh)\\n          \:9\\n          ent-map\\n          (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-true\\n      )))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (map \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      \#(\:entity (\:id e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:entity (\:id e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:entity e-l))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (\:id (\:entity e-l)))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e)]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         ]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" ";so, calc distance is correct." "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  closest-ent\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  (\:id closest-ent)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n        (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n          (\:entity (first e-los))\\r\\n          closest-ent))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  ) ;FML" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  \\n  (rest ents-los-true)\\n  ) ;FML" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent \#(loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance e-l)]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n;  closest-ent\\n  \\n  (rest ents-los-true)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  closest-ent\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id closest-ent)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (recur (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               closest-ent)))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               closest-ent)))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (\:id (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      (do (rest e-los)\\r\\n             (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n               (\:entity (first e-los))\\r\\n               [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)])))))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      closest-ent\\r\\n      [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)]))\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    e-los)\\n  )" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))\\n      calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\n      ents-los-true (bt/run (->LocateACombatTarget \:fresh)\\r\\n                            \:9\\r\\n                            ent-map\\r\\n                            (\:tile-map ms/game))\\n      closest-ent (loop [e-los (rest ents-los-true)\\r\\n                         closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n  (mapv \\n    (fn [e-l]\\n      (let [e (\:entity e-l)]\\n        [(\:id e)\\n         (\:transform e)\\n         (calc-distance (\:entity e-l))]))\\n    ents-los-true)\\n  \\n  (let [e-los (rest ents-los-true)\\r\\n         closest-ent (\:entity (first ents-los-true))]\\r\\n    (if (empty e-los)\\r\\n      \\"wtf\\"\\r\\n      [(calc-distance (\:entity (first e-los))) (calc-distance closest-ent)]))\\n  )" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e-los] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform (\:entity e-los))\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (first ents-los-true)]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc entities main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n          \:9\\r\\n          ent-map\\r\\n          (\:tile-map ms/game))))" "(let [ent-map (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\r\\n      main-ent (\:9 ent-map)\\r\\n      reseted-tree (bt/reset-behavior-tree (\:tree (\:behavior-tree main-ent)))]\\r\\n  (\:9 (\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n                         \:9\\r\\n                         ent-map\\r\\n                         (\:tile-map ms/game)))))" "(map \#([\:id %]) (get-in ms/game [\:ecs \:entities]))" "(map (fn [e] [\:id e]) (get-in ms/game [\:ecs \:entities]))" "(get-in ms/game [\:ecs \:entities])" "(map (fn [e] [(\:id e)]) (get-in ms/game [\:ecs \:entities]))" "(map (fn [e] [(\:id e) (\:transform e)]) (get-in ms/game [\:ecs \:entities]))" "(ms/update-game\! \#(assoc % \:paused false))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn renderable \\n  [ent texture]\\n    (renderable ent texture 1 1)\\n  [ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y))" "(defn renderable \\n  ([ent texture]\\n    (renderable ent texture 1 1)\\n  [ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y)))" "(defn renderable \\n  ([ent texture]\\n    (renderable ent texture 1 1))\\n  ([ent texture scale-x scale-y]\\n    (assoc ent \\n           \:texture texture\\n           \:scale-x scale-x\\n           \:scale-y scale-y)))" "(defn renderable \\r\\n  ([ent texture]\\r\\n    (renderable ent texture 1 1))\\r\\n  ([ent texture scale-x scale-y]\\r\\n    (assoc ent \\r\\n           \:renderable {\:texture texture\\r\\n                        \:scale-x scale-x\\r\\n                        \:scale-y scale-y})))" "(renderable {} \\"some texture\\" 2 2)" "(renderable {} \\"some texture\\")" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:renderable (comps/renderable (\:pistol-idle tex-cache))\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (->  \\r\\n                       (comps/behavior-tree \\r\\n                         (bt/->Selector \:fresh 0 \\r\\n                                        [(bt/->Sequence \:fresh 0\\r\\n                                                        [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                                         (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n                                         (bt/->Sequence \:fresh 0 \\r\\n                                                        [(enemy-ai/->PickRandomTile \:fresh)\\r\\n                                                         (enemy-ai/->FindPath \:fresh)\\r\\n                                                         (enemy-ai/->FollowPath \:fresh)])]))\\r\\n                       (update \:tree \#(bt/add-ids-to-tree %)))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(ns basic-combat-ai.main-screen)" "game" "(get-in game [\:ecs \:entities])" "(\:renderable (get-in game [\:ecs \:entities 0]))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(render ms/game)" "ffffffffff" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n;    (.setProjectionMatrix batch (.combined cam))\\r\\n;    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation])))]\\n          (println texture-region)\\r\\n;              width (float (.getRegionWidth texture-region))\\r\\n;              height (float (.getRegionHeight texture-region))]\\r\\n;          (.draw batch texture-region x y origin-x origin-y width height (float 1) (float 1) rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n;    (.end batch))\\r\\n  ents))" "(render ms/game)" "(map \#(\:renderable %) (render ms/game))" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n;    (.setProjectionMatrix batch (.combined cam))\\r\\n;    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation])))]\\r\\n;              width (float (.getRegionWidth texture-region))\\r\\n;              height (float (.getRegionHeight texture-region))]\\r\\n;          (.draw batch texture-region x y origin-x origin-y width height (float 1) (float 1) rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n;    (.end batch))\\r\\n  ents))" "(map \#(\:renderable %) (render ms/game))" "wtf" "(\:renderable (get-in ms/game [\:ecs \:entities]))" "(map \#(\:renderable %) (get-in ms/game [\:ecs \:entities]))" "?????????????????????????" "clojure.core/when" ";oh" ";the ai" "(app)" "(defn render [{{ents \:entities} \:ecs batch \:batch cam \:camera}]\\r\\n  (let [qualifying-ents (filterv \#(and (\:renderable %) (\:transform %)) ents)]\\r\\n    (.setProjectionMatrix batch (.combined cam))\\r\\n    (.begin batch)\\r\\n    ;this loop isn't really any faster than using map. the slow part is the actual drawing done by libgdx/opengl\\r\\n    (loop [q-ents qualifying-ents]\\r\\n      (if (empty? q-ents)\\r\\n        ents\\r\\n        (let [e (first q-ents)\\r\\n              texture-region (\:texture (\:renderable e))\\r\\n              x (float (get-in e [\:transform \:x]))\\r\\n              y (float (get-in e [\:transform \:y]))\\r\\n              origin-x (float (get-in e [\:transform \:origin-x]))\\r\\n              origin-y (float (get-in e [\:transform \:origin-y]))\\r\\n              ;libgdx draws rotation counter clock wise, and um, i want to keep my code clock wise because it  makes more sense to me.\\r\\n              rotation (* -1.0 (float (get-in e [\:transform \:rotation]))) \\r\\n              width (float (.getRegionWidth texture-region))\\r\\n              height (float (.getRegionHeight texture-region))\\r\\n              scale-x (float (\:scale-x (\:renderable e)))\\r\\n              scale-y (float(\:scale-y (\:renderable e)))]\\r\\n          (.draw batch texture-region x y origin-x origin-y width height scale-x scale-y rotation)\\r\\n          (recur (rest q-ents)))))\\r\\n    (.end batch))\\r\\n  ents)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 0] render))" "(ns basic-combat-ai.main-screen)" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion tracer \\"tracer\\")\\r\\n     }))" ";hmm" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion tracer \\"tracer\\")\\r\\n     }))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    (-> atlas\\r\\n    {\:fire-pistol00 (.findRegion \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     })))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    (-> atlas\\r\\n    {\:fire-pistol00 (.findRegion \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion \\"pistol idle\\")\\r\\n     \:floor (.findRegion \\"floor\\")\\r\\n     \:wall (.findRegion \\"wall\\")\\r\\n     \:tracer (.findRegion \\"tracer\\")\\r\\n     })))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(ns basic-combat-ai.main-screen \:as ms)" "(ns '[basic-combat-ai.main-screen \:as ms])" ";why is my brain dead" "(ns basic-combat-ai.main-screen)" "(require '[basic-combat-ai.components \:as comps])" "(-> {}\\n  (comps/renderable (\:tracer (\:tex-cache ms/game)) 1 1)\\n  (assoc \:transform (comps/transform 0 0 0 16 16)))" "(-> {}\\n  (comps/renderable (\:tracer (\:tex-cache game)) 1 1)\\n  (assoc \:transform (comps/transform 0 0 0 16 16)))" "(update-game\! \#(ecs/add-entity % (-> {}\\r\\n                                   (comps/renderable (\:tracer (\:tex-cache game)) 1 1)\\r\\n                                   (assoc \:transform (comps/transform 0 0 0 16 16)))))" ";uhg" "(app)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) x y scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(tracer (\:tex-cache ms/game) 0 0 1 1)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(tracer (\:tex-cache ms/game) 0 0 1 1)" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [old-ents] (conj old-ents (tracer (\:tex-cache %) 0 0 1 1)))))" ";oops" "(app)" "(ns basic-combat-ai.main-screen)" "(\:tex-cache game)" "(\:tracer (\:tex-cache game))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\n  (-> {}\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(tracer ms/game 0 0 1 1)" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [old-ents] (conj old-ents (tracer % 0 0 1 1)))))" "(get-in ms/game [\:ecs \:entities 1])" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [t] (assoc t \:x 16 \:y 16))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 2 \:scale-y 2))))" ";what, why did the x and y reset.." "(get-in ms/game [\:ecs \:entities 1])" ";oh hmm what.." ";origin should be 0?" ";mebe.." "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 0 \:origin-y 0))))" ";mebe.." "(get-in ms/game [\:ecs \:entities 1])" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 3 \:scale-y 3))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 10 \:scale-y 10))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 90))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:rotation 45))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 3 \:origin-y 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 1 \:origin-y 0))))" ";oh my god it's scaled then origin is applied.." ";........." "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:transform] (fn [r] (assoc r \:origin-x 0 \:origin-y 0))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 1 \:scale-y 10))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities 1 \:renderable] (fn [r] (assoc r \:scale-x 1 \:scale-y 100))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (pop ents))))" "(get-in ms/game [\:ecs \:entities])" ";2?" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.entities \:as ent-ns])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hp (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(into {} (filter (fn [e] (\:hp (second e))) (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(ent-vec->map (get-in ms/game [\:ecs \:entities]))" "(into {} (filter (fn [e] (\:hit-points (second e))) (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          calc-distance (fn [e] \\r\\n                          (let [{x1 \:x, y1 \:y} (\:transform e)\\r\\n                                {x0 \:x, y0 \:y} (\:transform main-ent)]\\r\\n                            (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))           \\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (calc-distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn pending-entity [create-entity-fn]\\r\\n  \\"create-entity-fn should be a function from the entity namespace.\\r\\n   It should probably be a partial, with everything except for the game map (first param) filled in.\\r\\n   The expectation is that a system will use this function to replace this entity with whatever entity \\r\\n   pops out of the function.\\"\\r\\n  {\:pending-entity create-entity-fn})" "(pending-entity \#(tracer % 16 16 1 1))" "(let [create-ent-fn (pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (comps/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.components \:as comps])" "(let [create-ent-fn (comps/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (ents-ns/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.entities \:as ents-ns])" "(let [create-ent-fn (ents-ns/pending-entity \#(tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))\\n      ]\\n  create-ent-fn)" "(let [create-ent-fn (\:pending-entity (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))\\n      ]\\n  create-ent-fn)" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [create-ent-fn (\:pending-entity (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))]\\r\\n  (create-ent-fn ms/game))" "(assoc [1 2 3] 1 \\"a\\")" "(update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))" "(get-in (update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))) [\:ecs \:entities])" "(count (get-in (update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))) [\:ecs \:entities]))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))))" "(update-in ms/game [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))))))" "(ms/update-game\! (fn [g] (update-in g [\:ecs \:entities] (fn [ents] (conj ents (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))))))" "(count (get-in ms/game [\:ecs \:entities]))" "(get-in ms/game [\:ecs \:entities])" "(defn create-pending-entity [{{entities \:entities} \:ecs \:as game}]\\n  (loop [idx 0\\n         ents entities]\\n    (if (\= idx (count ents))\\n      ents\\n      (recur (inc idx)\\n             (if-let [create-entity-fn (\:pending-entity (nth ents idx))]\\n               (assoc ents idx (create-pending-entity game))\\n               ents)))))" "(get-in ms/game [\:ecs \:entities])" "(create-pending-entity ms/game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn create-pending-entity [{{entities \:entities} \:ecs \:as game}]\\n  (loop [idx 0\\n         ents entities]\\n    (if (\= idx (count ents))\\n      ents\\n      (recur (inc idx)\\n             (if-let [create-entity-fn (\:pending-entity (nth ents idx))]\\n               (assoc ents idx (create-entity-fn game))\\n               ents)))))" "(create-pending-entity ms/game)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" ";(ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc  (ents-ns/pending-entity \#(ents-ns/tracer % 16 16 1 1)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(require '[basic-combat-ai.ecs \:as ecs])" "(keyword 1)" "(keyword \\"1\\")" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.ecs \:as ecs])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(require '[basic-combat-ai.entities \:as ents-ns])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities])" "(keys (get-in ms/game [\:ecs \:entities]))" "(map \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform (main-ent))\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             ;(assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             ;(assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc \:1 (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                             (assoc (keyword (str (ecs/get-new-id))) (ents-ns/pending-entity \#(ents-ns/tracer % (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                             )]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon\\n  \:19\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(app)" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn timed-life [ent life-in-seconds]\\r\\n  (assoc ent\\r\\n         \:timed-life life-in-seconds))" "(defn tracer [{tex-cache \:tex-cache} x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\n    (comps/timed-life 0.1)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [entities ents\\n         result-ents []]\\n    (if (empty? entities)\\n      result-ents\\n      (let [e (first entities)]\\n        (if (\:timed-life e)\\n          \\"i have it\\"\\n          (recur (rest entities)\\n                 []))))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)]\\n        (if (\:timed-life e)\\n          \\"i have it\\"\\n          (recur (rest ents)\\n                 []))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (\=< (- timed-life delta) 0))\\n          (recur (rest ents) result-ents)\\n          (recur (rest ents) (into result-ents e)))))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) result-ents)\\n          (recur (rest ents) (into result-ents e)))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) entities)\\n          (recur (rest ents) entities))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\n  (loop [ents entities\\n         result-ents []]\\n    (if (empty? ents)\\n      result-ents\\n      (let [e (first ents)\\n            timed-life (\:timed-life e)]\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\n          (recur (rest ents) e)\\n          (recur (rest ents) e))))))" "(timed-life ms/game)" "(into [] {\:a \\"1\\"})" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) result-ents)\\r\\n          (recur (rest ents) (conj result-ents e)))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) result-ents)\\r\\n          (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (if (and timed-life (<\= (- timed-life delta) 0))\\r\\n          (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta))))\\r\\n          (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\"a\\"\\n          \:else \\"b\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            (recur (rest ents) (assoc e \:timed-life (- timed-life delta))))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          timed-life \\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            \\"a\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          (nil? timed-life)\\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            \\"a\\")))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\n          (nil? timed-life)\\n            (recur (rest ents) (conj e))\\n          (<\= timed-life 0) \\n            (recur (rest ents) result-ents)\\n          \:else\\n            (recur (rest ents) (assoc e \:timed-life (- timed-life delta))))))))" "(timed-life ms/game)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s timed-life))))" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(app)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc % \:paused true))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n            updated-entities (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \#(projectile/tracer % tracer-id (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \#(projectile/tracer % tracer-id (\:x main-ent-transform) (\:y main-ent-transform) 2 10)))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.1)\\r\\n    (assoc \:transform (comps/transform x y 0 0 0))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            \\"A\\")))))" "(timed-life ms/game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(nil? 0)" "(nil? 0N)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (println timed-life)\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) result-ents))))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\n        \\"a\\"))))" "(timed-life ms/game)" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            ]\\n        \\"a\\"))))" "(timed-life ms/game)" "(get-in ms/game [\:ecs \:entities])" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(defn timed-life [{{entities \:entities} \:ecs, delta \:delta}]\\r\\n  (loop [ents entities\\r\\n         result-ents []]\\r\\n    (if (empty? ents)\\r\\n      result-ents\\r\\n      (let [e (first ents)\\r\\n            timed-life (\:timed-life e)]\\r\\n        (cond\\r\\n          (nil? timed-life)\\r\\n            (recur (rest ents) (conj e))\\r\\n          (<\= timed-life 0) \\r\\n            (recur (rest ents) result-ents)\\r\\n          \:else\\r\\n            (recur (rest ents) (conj result-ents (assoc e \:timed-life (- timed-life delta)))))))))" "(timed-life game)" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      (\:x main-ent-transform) \\r\\n                                                                      (\:y main-ent-transform) \\r\\n                                                                      2 \\r\\n                                                                      10 \\r\\n                                                                      (\:rotation main-ent-transform))))\\r\\n                               ))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcer/reset)" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      (+ (\:x main-ent-transform)\\r\\n                                                                         (\:origin-x main-ent-transform))\\r\\n                                                                      (+ (\:y main-ent-transform)\\r\\n                                                                         (\:origin-y main-ent-transform))\\r\\n                                                                      2 \\r\\n                                                                      10 \\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                     ((\:combat-target-id main-ent) entities))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7)\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ns basic-combat-ai.enemy-ai)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ms/update-game\! \#(assoc % \:paused false))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc % \:paused false))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (println (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                                   ((\:combat-target-id main-ent) entities))\\r\\n                                                                                    7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn distance [e1 e2] \\r\\n  (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n        {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(defn distance \\r\\n  ([e1 e2] \\r\\n    (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n          {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n      (distance x0 y0 x1 y1)))\\r\\n  ([x0 y0 x1 y1]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(distance 0 0 32 32)" "(distance 32 32 0 0)" " (require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 64 64))\\r\\n    ))" "(\= game-loop game-loop)" "(\= game-loop last-fps)" "(\= game-loop init-game)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 128 128))\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(assoc [1 2 3] 0 \\"\\")" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\n  (ms/update-game\! (fn [g] (-> g\\n                             (tick-behavior-tree)\\n                             (create-pending-entity)\\n                             (projectile-weapon-cooldown)\\n                             (animate)\\n                             (rotate)\\n                             (move)\\n                             (death)\\n                             (timed-life)))))" "(run-game)" "(app)" "(ns basic-combat-ai.main-screen)" "(defn run-game []\\r\\n  (update-game\! (fn [g] (-> g\\r\\n                          (tick-behavior-tree)\\r\\n                          (create-pending-entity)\\r\\n                          (projectile-weapon-cooldown)\\r\\n                          (animate)\\r\\n                          (rotate)\\r\\n                          (move)\\r\\n                          (death)\\r\\n                          (timed-life)))))" "(ns basic-combat-ai.systems)" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(-> ms/game\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(-> (get-in ms/game [\:ecs \:entities])\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game '[(tick-behavior-tree)\\r\\n                    (create-pending-entity)\\r\\n                    (projectile-weapon-cooldown)\\r\\n                    (animate)\\r\\n                    (rotate)\\r\\n                    (move)\\r\\n                    (death)\\r\\n                    (timed-life)])" "(run-game ms/game '((tick-behavior-tree)\\r\\n                   (create-pending-entity)\\r\\n                   (projectile-weapon-cooldown)\\r\\n                   (animate)\\r\\n                   (rotate)\\r\\n                   (move)\\r\\n                   (death)\\r\\n                   (timed-life)))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life]) \\n        [\:ecs \:entities])" "(ms/update-game\! (run-game ms/game [tick-behavior-tree\\r\\n                                    create-pending-entity\\r\\n                                    projectile-weapon-cooldown\\r\\n                                    animate\\r\\n                                    rotate\\r\\n                                    move\\r\\n                                    death\\r\\n                                    timed-life]))" "(ms/update-game\! \#(run-game % [tick-behavior-tree\\r\\n                               create-pending-entity\\r\\n                               projectile-weapon-cooldown\\r\\n                               animate\\r\\n                               rotate\\r\\n                               move\\r\\n                               death\\r\\n                               timed-life]))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life])" "(keys (run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life]))" "(ms/update-game\! \#(assoc-in %\\n                            [\:ecs \:entities]\\n                            (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                    [\:ecs \:entities])))" "(defn run-once (ms/update-game\! \#(assoc-in %\\n                                           [\:ecs \:entities]\\n                                           (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                   [\:ecs \:entities]))))" "(defn run-once [] (ms/update-game\! \#(assoc-in %\\n                                              [\:ecs \:entities]\\n                                              (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                      [\:ecs \:entities]))))" "(get-in (run-game % [tick-behavior-tree\\r\\n                     create-pending-entity\\r\\n                     projectile-weapon-cooldown\\r\\n                     animate\\r\\n                     rotate\\r\\n                     move\\r\\n                     death\\r\\n                     timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(tick-behavior-tree ms/game)" "(nth (tick-behavior-tree ms/game) 0)" "(nth (tick-behavior-tree ms/game) 1)" "(nth (tick-behavior-tree ms/game) 2)" "(nth (tick-behavior-tree ms/game) 3)" "(nth (tick-behavior-tree ms/game) 2)" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)))" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)) ms/game)" "(create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game)))" "(count (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))))" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 0)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 1)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 2)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 3)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 10000)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ns basic-combat-ai.systems)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(\:delta ms/game)" "(run-once)" "(math-utils/distance 0 0 32 32)" "(use 'clojure.math.numeric-tower)" "(Math/sqrt \\n  (+ (Math/pow (- 32 0) 2)\\n     (Math/pow (- 32 0) 2)))" "(defn euclidean-distance [x0 y0 x1 y1]\\r\\n  (Math/sqrt \\r\\n    (+ (Math/pow (- x1 x0) 2)\\r\\n       (Math/pow (- y1 y0) 2))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(run-once)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities ms/game)" "ms/game" "(get-in ms/game [\:ecs \:entities])" "(fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:29 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(ns basic-combat-ai.systems)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           ;create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(ns basic-combat-ai.enemy-ai)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "((\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:41 (\:pending-entity (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(\:41 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:44 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:48 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "((\:pending-entity (\:49 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform)))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in entities [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                   (- hp (\:damage (\:projectile-weapon main-ent))))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:52 (pending-tracer-added\\n                        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                        (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))))" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance \\r\\n                                                tracer-x tracer-y\\r\\n                                                (\:x combat-target-transform) (\:y combat-target-transform))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "((\:pending-entity (\:54 (pending-tracer-added\\n                         (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                         (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))) ms/game)" "(\:entities (\:ecs ms/game))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.enemy-ai)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y rotation]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.05)\\r\\n    (assoc \:transform (comps/transform x y rotation 0 0))))" "(ns basic-combat-ai.systems)" "(run-once)" "(conj [1 2 3] 4 5 6)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s \\n                                                             tick-behavior-tree\\n                                                             create-pending-entity\\n                                                             projectile-weapon-cooldown\\n                                                             animate\\n                                                             rotate\\n                                                             move\\n                                                             death\\n                                                             timed-life))))" "(ns basic-combat-ai.entities)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+128 64)))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" "(ns basic-combat-ai.enemy-ai)" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (math-utils/distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))" "(ns basic-combat-ai.main-screen)" "(\:tile-map ms/game)" "(\:tile-map game)" "(count (\:tile-map game))" "(nth (\:tile-map game) 0)" "(nth (nth (\:tile-map game) 0) 0)" "(nth (nth (\:tile-map game) 0) 1)" "(let [tile (nth (nth (\:tile-map game) 0) 1)]\\n  (assoc \:passable false\\n         \:texture (\:wall (\:tex-cache game))))" "(let [tile (nth (nth (\:tile-map game) 0) 1)]\\n  (assoc tile\\n         \:passable false\\n         \:texture (\:wall (\:tex-cache game))))" "(defn add-wall [x y]\\n  (let [tile (nth (nth (\:tile-map game) x) y)]\\n    (assoc tile\\n           \:passable false\\n           \:texture (\:wall (\:tex-cache game)))))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities] []))" "(update-game\! \#(assoc-in % [\:tile-map 0 0] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 0 0] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 0] (add-wall 1 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(get-in game [\:ecs \:entities])" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(tile-map/get-tile 0 0 (\:tile-map ms/game))" "(defrecord PickRandomTile [status]\\r\\n  bt/NodeCancel\\r\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\r\\n    (bt/make-return-map (assoc node \:status \:failure)\\r\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \:move-to)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (if (\:passable (tile-map/get-tile x y curr-tile-map))\\r\\n        (bt/make-return-map (assoc node \:status \:success) \\r\\n                            (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(defn init [game]\\r\\n  (-> game\\r\\n    ;(ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 128 128))\\r\\n    ))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(defn run-game [game systems]\\r\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))\\r\\n\\r\\n(defn run-once [] (ms/update-game\! \#(assoc-in %\\r\\n                                              [\:ecs \:entities]\\r\\n                                              (get-in (run-game % [tick-behavior-tree\\r\\n                                                                   create-pending-entity\\r\\n                                                                   projectile-weapon-cooldown\\r\\n                                                                   animate\\r\\n                                                                   rotate\\r\\n                                                                   move\\r\\n                                                                   death\\r\\n                                                                   timed-life])\\r\\n                                                      [\:ecs \:entities]))))" "(get-in ms/game [\:ecs \:entities 0])" "(bt/tick (\:tree (\:behavior-tree (get-in ms/game [\:ecs \:entities]))) \\n         \:1\\n         (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n         (\:tile-map ms/game))" "(\:entities (bt/tick (\:tree (\:behavior-tree (get-in ms/game [\:ecs \:entities]))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(\:entities (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(\:node (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                \:1\\n                (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                (\:tile-map ms/game)))" "(add-wall 1 1)" "(ns basic-combat-ai.systems)" "(\:node (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                \:1\\n                (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                (\:tile-map ms/game)))" "(\:entities (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(def prev-game {})" "(defn run-once [] \\n  (do\\n    (def prev-game ms/game)\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(run-once)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n;    (ecs/add-system tick-behavior-tree)\\r\\n;    (ecs/add-system create-pending-entity)\\r\\n;    (ecs/add-system projectile-weapon-cooldown)\\r\\n;    (ecs/add-system animate)\\r\\n;    (ecs/add-system rotate)\\r\\n;    (ecs/add-system move)\\r\\n;    (ecs/add-system death)\\r\\n;    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(basic-combat-ai.main-screen/add-wall 0 0)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" ";(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj" "(conj [] [1 2 3])" "(into [] [1 2 3])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (into s [tick-behavior-tree\\r\\n                                                                create-pending-entity\\r\\n                                                                projectile-weapon-cooldown\\r\\n                                                                animate\\r\\n                                                                rotate\\r\\n                                                                move\\r\\n                                                                death\\r\\n                                                                timed-life]))))" "(get-in ms/game [\:ecs \:systems])" "(ms/add-wall 1 1)" "(ns basic-combat-ai.main-screen)" "(defn pause []\\r\\n  (ms/update-game\! \#(assoc % \:paused true)))\\r\\n\\r\\n(defn resume []\\r\\n  (ms/update-game\! \#(assoc % \:paused false)))" "(defn pause []\\r\\n  (update-game\! \#(assoc % \:paused true)))\\r\\n\\r\\n(defn resume []\\r\\n  (update-game\! \#(assoc % \:paused false)))" "(ns basic-combat-ai.main-screen)" "(ns basic-combat-ai.systems)" "(ms/resume)" "(ms/pause)" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    (assoc-in game [\:ecs \:entities] (sys/render game))\\r\\n    (do (clear-screen)\\r\\n      (.update (\:camera game))\\r\\n      (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n      (-> game\\r\\n        (ecs/update-ecs))))\\r\\n  )" "(get-in game [\:ecs \:entities])" "(ns basic-combat-ai.systems)" "(run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])" "(\:ecs (\:entities (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(basic-combat-ai.desktop-launcher/reset)" "(ms/add-wall 1 1)" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(\:entities (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/add-wall 1 1)" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in prev-game [\:ecs \:entities 0])" "(run-once)" "(run-once)(run-once)(run-once)" "(run-once)" "(run-once)(run-once)" "(run-once)" "(run-once)(run-once)" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-game)) \\r\\n      (def prev-game (conj (rest prev-game) ms/game))\\r\\n      (def prev-game (conj prev-game ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(run-once)" "(count prev-game)" "(def prev-games [])" "(def prev-game [])" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-game)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(count prev-games)" "(run-once)" "(count prev-games)" "(run-once)" "(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)" "(run-once)" "(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)" "(conj [1 2 3] 4)" ";(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (first prev-games)))" "(\:entities (\:ecs (first prev-games)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (first prev-games)))))" "(defn revert-entities [idx]\\r\\n  (if (and (< idx 10) (>\= idx 0))\\r\\n    (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (nth prev-games idx)))))\\r\\n    \\"idx must be between 0 and 9, inclusive.\\"))" "(defn run-times [n]\\r\\n  (loop [idx n]\\r\\n    (if (zero? idx)\\r\\n      nil\\r\\n      (do\\r\\n        (run-once)\\r\\n        (recur (dec idx))))))" "(run-times 5)" "(run-times 3)" "(run-times 9)" "(get-in ms/game [\:ecs \:entities])" "(run-times 9)" "(get-in ms/game [\:ecs \:entities])" "(run-times 9)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 1)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 2)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 3)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 4)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 5)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 6)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 7)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 8)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 1)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 2)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(get-in ms/game [\:ecs \:entities])" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(run-once)" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(count prev-games)" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-games)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(let [g (nth prev-games 860)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 859)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 858)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 859)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 849)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 849)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" ";when the tree is running and the code to see if a higher priority node wants to run, runs, the random location node has a chance to fail if it picks an unpassable position" ";so now we're comparing a failed tree with a running tree" ";so, if the 'canceled' tree returns a failure, then just ignore that higher priority node for now." ";or say no randomness allowed when it comes to effecting status?" "(use 'clojure.repl)" "(source dissoc)" "(defrecord FollowPath [status]\\r\\n  bt/NodeCancel\\r\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\r\\n    (bt/make-return-map (assoc node \:status \:failure)\\r\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \\r\\n                                                                           \:path\\r\\n                                                                           \:target-location\\r\\n                                                                           \:target-rotation)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          ;this means we spend an AI tick just incrementing the curr path idx. ehh... didn't intend for this.\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/round-to-decimal \\r\\n                                   (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                        [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))]) 1)]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (if (\:target-location main-ent)\\r\\n                (bt/make-return-map node entities curr-tile-map)\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                    curr-tile-map))\\r\\n              ;rotate towards it\\r\\n              (if (\:target-rotation main-ent)\\r\\n                (bt/make-return-map node entities curr-tile-map)\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                    curr-tile-map)))))))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "\\r\\n(defrecord FindPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                        (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                        curr-tile-map)\\r\\n          target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\r\\n          path (astar/calc-path start-tile target-tile curr-tile-map)]\\r\\n      (if (seq? path)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc entities main-ent-id (-> main-ent \\r\\n                                                          (assoc \:path (comps/path path))\\r\\n                                                          (dissoc \:move-to)))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure) main-ent curr-tile-map)))))\\r\\n\\r\\n(defrecord PickRandomTile [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (if (\:passable (tile-map/get-tile x y curr-tile-map))\\r\\n        (bt/make-return-map (assoc node \:status \:success) \\r\\n                            (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(ns basic-combat-ai.systems)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(add-wall 0 0)" "(add-wall 1 1)" "(add-wall 2 2)" "(add-wall 1 0)" "(add-wall 2 1)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 2 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 5 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 5 5)))" "(get-in ms/game [\:ecs \:entities])" "(ms/pause)" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 2 0)))" "(ms/resume)" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.5 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y rotation]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.01)\\r\\n    (assoc \:transform (comps/transform x y rotation 0 0))))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))"]
eclipse.preferences.version=1
