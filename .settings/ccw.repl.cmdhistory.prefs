cmdhistory=["(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                     ((\:combat-target-id main-ent) entities))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7)\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc game \:paused true))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ms/update-game\! \#(assoc % \:paused false))" "(ms/update-game\! \#(assoc % \:paused true))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ns basic-combat-ai.enemy-ai)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                        ((\:combat-target-id main-ent) entities))\\r\\n                                                                         7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(ms/update-game\! \#(assoc % \:paused false))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(assoc % \:paused false))" "(basic-combat-ai.desktop-launcher/reset)" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 calc-distance (fn [e1 e2] \\r\\n                                                 (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n                                                       {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n                                                   (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (println (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                                   ((\:combat-target-id main-ent) entities))\\r\\n                                                                                    7))\\r\\n                                                                        (/ (calc-distance {\:transform {\:x tracer-x, \:y tracer-y}}\\r\\n                                                                                          ((\:combat-target-id main-ent) entities))\\r\\n                                                                           7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(defn distance [e1 e2] \\r\\n  (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n        {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(defn distance \\r\\n  ([e1 e2] \\r\\n    (let [{x1 \:x, y1 \:y} (\:transform e1)\\r\\n          {x0 \:x, y0 \:y} (\:transform e2)]\\r\\n      (distance x0 y0 x1 y1)))\\r\\n  ([x0 y0 x1 y1]\\r\\n    (+ (Math/abs (- x1 x0)) (Math/abs (- y1 y0)))))" "(distance 0 0 32 32)" "(distance 32 32 0 0)" " (require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(assoc % \:paused true))" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities])" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 64 64))\\r\\n    ))" "(\= game-loop game-loop)" "(\= game-loop last-fps)" "(\= game-loop init-game)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 128 128))\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(count (get-in game [\:ecs \:entities]))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(update-game\! \#(assoc % \:paused false))" "(update-game\! \#(assoc % \:paused true))" "(get-in game [\:ecs \:entities])" "(assoc [1 2 3] 0 \\"\\")" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\n  (ms/update-game\! (fn [g] (-> g\\n                             (tick-behavior-tree)\\n                             (create-pending-entity)\\n                             (projectile-weapon-cooldown)\\n                             (animate)\\n                             (rotate)\\n                             (move)\\n                             (death)\\n                             (timed-life)))))" "(run-game)" "(app)" "(ns basic-combat-ai.main-screen)" "(defn run-game []\\r\\n  (update-game\! (fn [g] (-> g\\r\\n                          (tick-behavior-tree)\\r\\n                          (create-pending-entity)\\r\\n                          (projectile-weapon-cooldown)\\r\\n                          (animate)\\r\\n                          (rotate)\\r\\n                          (move)\\r\\n                          (death)\\r\\n                          (timed-life)))))" "(ns basic-combat-ai.systems)" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game []\\r\\n  (ms/update-game\! (fn [g] (-> g\\r\\n                             (tick-behavior-tree)\\r\\n                             (create-pending-entity)\\r\\n                             (projectile-weapon-cooldown)\\r\\n                             (animate)\\r\\n                             (rotate)\\r\\n                             (move)\\r\\n                             (death)\\r\\n                             (timed-life)))))" "(-> ms/game\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(-> (get-in ms/game [\:ecs \:entities])\\r\\n  (tick-behavior-tree)\\r\\n  (create-pending-entity)\\r\\n  (projectile-weapon-cooldown)\\r\\n  (animate)\\r\\n  (rotate)\\r\\n  (move)\\r\\n  (death)\\r\\n  (timed-life))" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game '[(tick-behavior-tree)\\r\\n                    (create-pending-entity)\\r\\n                    (projectile-weapon-cooldown)\\r\\n                    (animate)\\r\\n                    (rotate)\\r\\n                    (move)\\r\\n                    (death)\\r\\n                    (timed-life)])" "(run-game ms/game '((tick-behavior-tree)\\r\\n                   (create-pending-entity)\\r\\n                   (projectile-weapon-cooldown)\\r\\n                   (animate)\\r\\n                   (rotate)\\r\\n                   (move)\\r\\n                   (death)\\r\\n                   (timed-life)))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life]) \\n        [\:ecs \:entities])" "(ms/update-game\! (run-game ms/game [tick-behavior-tree\\r\\n                                    create-pending-entity\\r\\n                                    projectile-weapon-cooldown\\r\\n                                    animate\\r\\n                                    rotate\\r\\n                                    move\\r\\n                                    death\\r\\n                                    timed-life]))" "(ms/update-game\! \#(run-game % [tick-behavior-tree\\r\\n                               create-pending-entity\\r\\n                               projectile-weapon-cooldown\\r\\n                               animate\\r\\n                               rotate\\r\\n                               move\\r\\n                               death\\r\\n                               timed-life]))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(defn run-game [game systems]\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life])" "(keys (run-game ms/game [tick-behavior-tree\\r\\n                      create-pending-entity\\r\\n                      projectile-weapon-cooldown\\r\\n                      animate\\r\\n                      rotate\\r\\n                      move\\r\\n                      death\\r\\n                      timed-life]))" "(ms/update-game\! \#(assoc-in %\\n                            [\:ecs \:entities]\\n                            (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                    [\:ecs \:entities])))" "(defn run-once (ms/update-game\! \#(assoc-in %\\n                                           [\:ecs \:entities]\\n                                           (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                   [\:ecs \:entities]))))" "(defn run-once [] (ms/update-game\! \#(assoc-in %\\n                                              [\:ecs \:entities]\\n                                              (get-in (run-game % [tick-behavior-tree\\r\\n                                                 create-pending-entity\\r\\n                                                 projectile-weapon-cooldown\\r\\n                                                 animate\\r\\n                                                 rotate\\r\\n                                                 move\\r\\n                                                 death\\r\\n                                                 timed-life])\\n                                                      [\:ecs \:entities]))))" "(get-in (run-game % [tick-behavior-tree\\r\\n                     create-pending-entity\\r\\n                     projectile-weapon-cooldown\\r\\n                     animate\\r\\n                     rotate\\r\\n                     move\\r\\n                     death\\r\\n                     timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(tick-behavior-tree ms/game)" "(nth (tick-behavior-tree ms/game) 0)" "(nth (tick-behavior-tree ms/game) 1)" "(nth (tick-behavior-tree ms/game) 2)" "(nth (tick-behavior-tree ms/game) 3)" "(nth (tick-behavior-tree ms/game) 2)" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)))" "((\:pending-entity (nth (tick-behavior-tree ms/game) 2)) ms/game)" "(create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game)))" "(count (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))))" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 0)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 1)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 2)" "(nth (create-pending-entity (assoc-in ms/game [\:ecs \:entities] (tick-behavior-tree ms/game))) 3)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(run-once)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 10000)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ns basic-combat-ai.systems)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(\:delta ms/game)" "(run-once)" "(math-utils/distance 0 0 32 32)" "(use 'clojure.math.numeric-tower)" "(Math/sqrt \\n  (+ (Math/pow (- 32 0) 2)\\n     (Math/pow (- 32 0) 2)))" "(defn euclidean-distance [x0 y0 x1 y1]\\r\\n  (Math/sqrt \\r\\n    (+ (Math/pow (- x1 x0) 2)\\r\\n       (Math/pow (- y1 y0) 2))))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (-> main-ent\\r\\n                             (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n                             (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in main-ent [\:projectile-weapon \:cooldown]))\\r\\n                             (dissoc \:combat-target-id))\\r\\n          main-ent-transform (\:transform main-ent)\\r\\n          updated-entities (let [tracer-id (keyword (str (ecs/get-new-id)))\\r\\n                                 tracer-x (+ (\:x main-ent-transform)\\r\\n                                             (\:origin-x main-ent-transform))\\r\\n                                 tracer-y (+ (\:y main-ent-transform)\\r\\n                                             (\:origin-y main-ent-transform))]\\r\\n                             (-> entities\\r\\n                               (assoc main-ent-id updated-main-ent)\\r\\n                               (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] (- hp (\:damage (\:projectile-weapon main-ent)))))\\r\\n                               (assoc tracer-id (projectile/pending-entity \\r\\n                                                  \#(projectile/tracer % \\r\\n                                                                      tracer-id \\r\\n                                                                      tracer-x\\r\\n                                                                      tracer-y\\r\\n                                                                      1\\r\\n                                                                      (do\\r\\n                                                                        (print (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                        (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                                                      (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                                                      (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                                                         7))\\r\\n                                                                      (\:rotation main-ent-transform))))))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(run-once)" "(basic-combat-ai.desktop-launcher/reset)" "(run-once)" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:entities ms/game)" "ms/game" "(get-in ms/game [\:ecs \:entities])" "(fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:29 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:29 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(ns basic-combat-ai.systems)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           ;create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           ;projectile-weapon-cooldown\\r\\n                           ;animate\\r\\n                           ;rotate\\r\\n                           ;move\\r\\n                           ;death\\r\\n                           ;timed-life\\n                           ])\\r\\n        [\:ecs \:entities])" "(ns basic-combat-ai.enemy-ai)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "((\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(\:pending-entity (\:38 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(\:41 (\:pending-entity (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "(\:41 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:28 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:44 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(keys (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:48 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))" "((\:pending-entity (\:49 (fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))) ms/game)" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform)))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn- fired-weapon [ent]\\r\\n  (-> ent\\r\\n    (assoc-in [\:animation \:current-animation] \:fire-pistol)\\r\\n    (assoc-in [\:projectile-weapon \:curr-cooldown] (get-in ent [\:projectile-weapon \:cooldown]))\\r\\n    (dissoc \:combat-target-id)))\\r\\n\\r\\n(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                                             (\:x ((\:combat-target-id main-ent) entities))\\r\\n                                                                             (\:y ((\:combat-target-id main-ent) entities)))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                          (- hp (\:damage (\:projectile-weapon main-ent))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- combat-target-damaged [entities main-ent]\\r\\n  (update-in entities [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                   (- hp (\:damage (\:projectile-weapon main-ent))))))" "(fire-weapon \:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(\:pending-entity (\:52 (pending-tracer-added\\n                        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                        (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))))" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1\\r\\n                                           (/ (math-utils/euclidean-distance \\r\\n                                                tracer-x tracer-y\\r\\n                                                (\:x combat-target-transform) (\:y combat-target-transform))\\r\\n                                              7)\\r\\n                                           (\:rotation main-ent-transform))))))" "(pending-tracer-added\\n  (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n  (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "((\:pending-entity (\:54 (pending-tracer-added\\n                         (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                         (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities])))))) ms/game)" "(\:entities (\:ecs ms/game))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.enemy-ai)" "(defn- pending-tracer-added [entities main-ent]\\r\\n  (let [main-ent-transform (\:transform main-ent)\\r\\n        tracer-id (keyword (str (ecs/get-new-id)))\\r\\n        tracer-x (+ (\:x main-ent-transform) (\:origin-x main-ent-transform))\\r\\n        tracer-y (+ (\:y main-ent-transform) (\:origin-y main-ent-transform))\\r\\n        combat-target-transform (\:transform ((\:combat-target-id main-ent) entities))\\r\\n        combat-target-x (+ (\:x combat-target-transform) (\:origin-x combat-target-transform))\\r\\n        combat-target-y (+ (\:y combat-target-transform) (\:origin-y combat-target-transform))\\r\\n        scale-y (/ (math-utils/euclidean-distance tracer-x tracer-y\\r\\n                                                  combat-target-x combat-target-y)\\r\\n                 7)]\\r\\n    (assoc entities \\r\\n           tracer-id (projectile/pending-entity \\r\\n                       \#(projectile/tracer % \\r\\n                                           tracer-id \\r\\n                                           tracer-x\\r\\n                                           tracer-y\\r\\n                                           1 ;scale-x\\r\\n                                           scale-y \\r\\n                                           (\:rotation main-ent-transform))))))" "(ns basic-combat-ai.systems)" "(run-once)" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y rotation]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.05)\\r\\n    (assoc \:transform (comps/transform x y rotation 0 0))))" "(ns basic-combat-ai.systems)" "(run-once)" "(conj [1 2 3] 4 5 6)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s \\n                                                             tick-behavior-tree\\n                                                             create-pending-entity\\n                                                             projectile-weapon-cooldown\\n                                                             animate\\n                                                             rotate\\n                                                             move\\n                                                             death\\n                                                             timed-life))))" "(ns basic-combat-ai.entities)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+128 64)))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" "(ns basic-combat-ai.enemy-ai)" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (calc-distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))) (math-utils/distance closest-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(ns basic-combat-ai.entities)" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 (+ 128 64)))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 128 32)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 128))))" "(ns basic-combat-ai.main-screen)" "(\:tile-map ms/game)" "(\:tile-map game)" "(count (\:tile-map game))" "(nth (\:tile-map game) 0)" "(nth (nth (\:tile-map game) 0) 0)" "(nth (nth (\:tile-map game) 0) 1)" "(let [tile (nth (nth (\:tile-map game) 0) 1)]\\n  (assoc \:passable false\\n         \:texture (\:wall (\:tex-cache game))))" "(let [tile (nth (nth (\:tile-map game) 0) 1)]\\n  (assoc tile\\n         \:passable false\\n         \:texture (\:wall (\:tex-cache game))))" "(defn add-wall [x y]\\n  (let [tile (nth (nth (\:tile-map game) x) y)]\\n    (assoc tile\\n           \:passable false\\n           \:texture (\:wall (\:tex-cache game)))))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities] []))" "(update-game\! \#(assoc-in % [\:tile-map 0 0] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 0 0] (add-wall 0 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 0] (add-wall 1 0)))" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(basic-combat-ai.desktop-launcher/reset)" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(get-in game [\:ecs \:entities])" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(get-in game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(tile-map/get-tile 0 0 (\:tile-map ms/game))" "(defrecord PickRandomTile [status]\\r\\n  bt/NodeCancel\\r\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\r\\n    (bt/make-return-map (assoc node \:status \:failure)\\r\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \:move-to)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (if (\:passable (tile-map/get-tile x y curr-tile-map))\\r\\n        (bt/make-return-map (assoc node \:status \:success) \\r\\n                            (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:tile-map 1 1] (add-wall 1 1)))" "(defn init [game]\\r\\n  (-> game\\r\\n    ;(ecs/add-entity (pistoleer game 32 32))\\r\\n    (ecs/add-entity (pistoleer game 128 128))\\r\\n    ))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n(defn run-game [game systems]\\r\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))\\r\\n\\r\\n(defn run-once [] (ms/update-game\! \#(assoc-in %\\r\\n                                              [\:ecs \:entities]\\r\\n                                              (get-in (run-game % [tick-behavior-tree\\r\\n                                                                   create-pending-entity\\r\\n                                                                   projectile-weapon-cooldown\\r\\n                                                                   animate\\r\\n                                                                   rotate\\r\\n                                                                   move\\r\\n                                                                   death\\r\\n                                                                   timed-life])\\r\\n                                                      [\:ecs \:entities]))))" "(get-in ms/game [\:ecs \:entities 0])" "(bt/tick (\:tree (\:behavior-tree (get-in ms/game [\:ecs \:entities]))) \\n         \:1\\n         (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n         (\:tile-map ms/game))" "(\:entities (bt/tick (\:tree (\:behavior-tree (get-in ms/game [\:ecs \:entities]))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(\:entities (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(\:node (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                \:1\\n                (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                (\:tile-map ms/game)))" "(add-wall 1 1)" "(ns basic-combat-ai.systems)" "(\:node (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                \:1\\n                (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                (\:tile-map ms/game)))" "(\:entities (bt/tick (\:tree (\:behavior-tree (first (get-in ms/game [\:ecs \:entities])))) \\n                    \:1\\n                    (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                    (\:tile-map ms/game)))" "(def prev-game {})" "(defn run-once [] \\n  (do\\n    (def prev-game ms/game)\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(run-once)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n;    (ecs/add-system tick-behavior-tree)\\r\\n;    (ecs/add-system create-pending-entity)\\r\\n;    (ecs/add-system projectile-weapon-cooldown)\\r\\n;    (ecs/add-system animate)\\r\\n;    (ecs/add-system rotate)\\r\\n;    (ecs/add-system move)\\r\\n;    (ecs/add-system death)\\r\\n;    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(basic-combat-ai.main-screen/add-wall 0 0)" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(assoc % \:paused true))" ";(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj" "(conj [] [1 2 3])" "(into [] [1 2 3])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (into s [tick-behavior-tree\\r\\n                                                                create-pending-entity\\r\\n                                                                projectile-weapon-cooldown\\r\\n                                                                animate\\r\\n                                                                rotate\\r\\n                                                                move\\r\\n                                                                death\\r\\n                                                                timed-life]))))" "(get-in ms/game [\:ecs \:systems])" "(ms/add-wall 1 1)" "(ns basic-combat-ai.main-screen)" "(defn pause []\\r\\n  (ms/update-game\! \#(assoc % \:paused true)))\\r\\n\\r\\n(defn resume []\\r\\n  (ms/update-game\! \#(assoc % \:paused false)))" "(defn pause []\\r\\n  (update-game\! \#(assoc % \:paused true)))\\r\\n\\r\\n(defn resume []\\r\\n  (update-game\! \#(assoc % \:paused false)))" "(ns basic-combat-ai.main-screen)" "(ns basic-combat-ai.systems)" "(ms/resume)" "(ms/pause)" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    (assoc-in game [\:ecs \:entities] (sys/render game))\\r\\n    (do (clear-screen)\\r\\n      (.update (\:camera game))\\r\\n      (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n      (-> game\\r\\n        (ecs/update-ecs))))\\r\\n  )" "(get-in game [\:ecs \:entities])" "(ns basic-combat-ai.systems)" "(run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])" "(\:ecs (\:entities (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(basic-combat-ai.desktop-launcher/reset)" "(ms/add-wall 1 1)" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(\:entities (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/add-wall 1 1)" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(run-once)" "(first (\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life]))))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in prev-game [\:ecs \:entities 0])" "(run-once)" "(run-once)(run-once)(run-once)" "(run-once)" "(run-once)(run-once)" "(run-once)" "(run-once)(run-once)" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(run-once)" "(get-in ms/game [\:ecs \:entities 0])" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-game)) \\r\\n      (def prev-game (conj (rest prev-game) ms/game))\\r\\n      (def prev-game (conj prev-game ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(run-once)" "(count prev-game)" "(def prev-games [])" "(def prev-game [])" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-game)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(get-in ms/game [\:ecs \:entities 0])" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(run-once)" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])))" "(count prev-games)" "(run-once)" "(count prev-games)" "(run-once)" "(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)" "(run-once)" "(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)(run-once)" "(conj [1 2 3] 4)" ";(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (first prev-games)))" "(\:entities (\:ecs (first prev-games)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (first prev-games)))))" "(defn revert-entities [idx]\\r\\n  (if (and (< idx 10) (>\= idx 0))\\r\\n    (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (nth prev-games idx)))))\\r\\n    \\"idx must be between 0 and 9, inclusive.\\"))" "(defn run-times [n]\\r\\n  (loop [idx n]\\r\\n    (if (zero? idx)\\r\\n      nil\\r\\n      (do\\r\\n        (run-once)\\r\\n        (recur (dec idx))))))" "(run-times 5)" "(run-times 3)" "(run-times 9)" "(get-in ms/game [\:ecs \:entities])" "(run-times 9)" "(get-in ms/game [\:ecs \:entities])" "(run-times 9)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 1)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 2)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 3)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 4)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 5)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 6)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 7)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 8)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 1)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 2)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(get-in ms/game [\:ecs \:entities])" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(run-once)" "(let [g (nth prev-games 9)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 0)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(count prev-games)" "(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 10 (count prev-games)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))" "(let [g (nth prev-games 860)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 859)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 858)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 859)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 851)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 849)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 850)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" "(let [g (nth prev-games 849)\\n      e (first (\:entities (\:ecs g)))]\\n  e)" ";when the tree is running and the code to see if a higher priority node wants to run, runs, the random location node has a chance to fail if it picks an unpassable position" ";so now we're comparing a failed tree with a running tree" ";so, if the 'canceled' tree returns a failure, then just ignore that higher priority node for now." ";or say no randomness allowed when it comes to effecting status?" "(use 'clojure.repl)" "(source dissoc)" "(defrecord FollowPath [status]\\r\\n  bt/NodeCancel\\r\\n  (bt/cancel [node main-ent-id entities curr-tile-map]\\r\\n    (bt/make-return-map (assoc node \:status \:failure)\\r\\n                        (update entities main-ent-id (fn [old-ent] (dissoc old-ent \\r\\n                                                                           \:path\\r\\n                                                                           \:target-location\\r\\n                                                                           \:target-rotation)))))\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          ;this means we spend an AI tick just incrementing the curr path idx. ehh... didn't intend for this.\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/round-to-decimal \\r\\n                                   (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                        [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))]) 1)]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (if (\:target-location main-ent)\\r\\n                (bt/make-return-map node entities curr-tile-map)\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                    curr-tile-map))\\r\\n              ;rotate towards it\\r\\n              (if (\:target-rotation main-ent)\\r\\n                (bt/make-return-map node entities curr-tile-map)\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                    curr-tile-map)))))))))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (\:hit-points (second e))) entities)) \\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "\\r\\n(defrecord FindPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                        (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                        curr-tile-map)\\r\\n          target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\r\\n          path (astar/calc-path start-tile target-tile curr-tile-map)]\\r\\n      (if (seq? path)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc entities main-ent-id (-> main-ent \\r\\n                                                          (assoc \:path (comps/path path))\\r\\n                                                          (dissoc \:move-to)))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure) main-ent curr-tile-map)))))\\r\\n\\r\\n(defrecord PickRandomTile [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [x-max 8\\r\\n          y-max 8\\r\\n          x (rand-int x-max)\\r\\n          y (rand-int y-max)]\\r\\n      (if (\:passable (tile-map/get-tile x y curr-tile-map))\\r\\n        (bt/make-return-map (assoc node \:status \:success) \\r\\n                            (assoc-in entities [main-ent-id \:move-to] (comps/move-to x y)) \\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(ns basic-combat-ai.systems)" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(add-wall 0 0)" "(add-wall 1 1)" "(add-wall 2 2)" "(add-wall 1 0)" "(add-wall 2 1)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 2 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 5 0)))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 5 5)))" "(get-in ms/game [\:ecs \:entities])" "(ms/pause)" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 2 0)))" "(ms/resume)" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.5 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(defn tracer [{tex-cache \:tex-cache} id x y scale-x scale-y rotation]\\r\\n  (-> {}\\r\\n    (assoc \:id id)\\r\\n    (comps/renderable (\:tracer tex-cache) scale-x scale-y)\\r\\n    (comps/timed-life 0.01)\\r\\n    (assoc \:transform (comps/transform x y rotation 0 0))))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))" "(app)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(defn move-camera [{inputs \:inputs, cam \:camera}]\\r\\n  (do\\n    (when (\:Right inputs)\\n      (.translate cam 1 0))))" "(defn game-loop [game]\\r\\n  (def second-counter (+ second-counter (\:delta game)))\\r\\n  (def fps (inc fps))\\r\\n  (when (>\= second-counter 1.0)\\r\\n    (do \\r\\n      (def second-counter 0.0)\\r\\n      (def last-fps fps)\\r\\n      (def fps 0)\\r\\n      (when (< last-fps 60)\\r\\n        (println \\"frame rate is dropping below 60 \: \\" last-fps \\" @ \\" (new java.util.Date)))))\\r\\n  \\r\\n  (if (\:paused game)\\r\\n    (assoc-in game [\:ecs \:entities] (sys/render game))\\r\\n    (do \\r\\n      (clear-screen)\\r\\n      (move-camera)\\r\\n      (.update (\:camera game))\\r\\n      (tile-map/draw-grid (\:tile-map game) (\:batch game))\\r\\n      (-> game\\r\\n        (ecs/update-ecs))))\\r\\n  )" "(ns basic-combat-ai.main-screen)" "(defn move-camera [{inputs \:inputs, cam \:camera}]\\r\\n  (do\\r\\n    (when (\:Right inputs)\\r\\n      (.translate cam 1 0))\\n    (when (\:Left inputs)\\n      (.translate cam -1 0))\\n    (when (\:Up inputs)\\n      (.translate cam 0 1))\\n    (when (\:Down inputs)\\n      (.translate cam 0 -1))\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.components)" "(defn team [ent name]\\n  (assoc ent \:team name))" "(team {} \\"player\\")" "(ns basic-combat-ai.enemy-ai)" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (and (\:hit-points e) (not\= (\:team e) (\:team main-ent))))\\n                                        (vals entities)))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player}\\r\\n         \:2 {\:team \:enemy}}\\n        (\:tile-map ms/game))" "(\:entities (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player}\\r\\n         \:2 {\:team \:enemy}}\\n                   (\:tile-map ms/game)))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player}\\r\\n         \:2 {\:team \:enemy}}\\n               (\:tile-map ms/game)))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:transform {\:x 1, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\n             \:hit-points 100\\n             \:transform {\:x 0, \:y 0}}}\\n        (\:tile-map ms/game)))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:transform {\:x 32, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\n             \:hit-points 100\\n             \:transform {\:x 0, \:y 0}}}\\n        (\:tile-map ms/game)))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game)))" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (and (\:hit-points e) (not\= (\:team e) (\:team main-ent))))\\n                                        (vals entities)))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (let [e-value (second e)]\\n                                                  (and (\:hit-points e-value) (not\= (\:team e-value) (\:team main-ent)))))\\n                                        entities))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game)))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:hit-points 100\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game)))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (let [e-value (second e)]\\n                                                  (and (\:hit-points e-value) (not\= (\:team e-value) (\:team main-ent)))))\\n                                        entities))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-with-hp\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:hit-points 100\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (let [e-value (second e)]\\n                                                  (and (\:hit-points e-value) (not\= (\:team e-value) (\:team main-ent)))))\\n                                        entities))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      ents-los-checked\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:hit-points 100\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          ents-with-hp (into {} (filter (fn [e] (let [e-value (second e)]\\n                                                  (and (\:hit-points e-value) (not\= (\:team e-value) (\:team main-ent)))))\\n                                        entities))\\r\\n          ents-los-checked (map \\r\\n                             (fn [e] \\r\\n                                 {\:entity e \\r\\n                                  \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                             (vals (dissoc ents-with-hp main-ent-id)))\\r\\n          ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n          closest-ent (loop [e-los (rest ents-los-true)\\r\\n                             closest-ent (\:entity (first ents-los-true))]\\r\\n                        (if (empty? e-los)\\r\\n                          closest-ent\\r\\n                          (recur (rest e-los)\\r\\n                                 (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                             main-ent) \\r\\n                                        (math-utils/distance closest-ent\\r\\n                                                             main-ent))\\r\\n                                   (\:entity (first e-los))\\r\\n                                   closest-ent))))]\\r\\n      closest-ent\\n      )))" "(bt/run (->LocateACombatTarget \:fresh)\\r\\n        \:1\\r\\n        {\:1 {\:team \:player\\n             \:hit-points 100\\r\\n             \:transform {\:x 128, \:y 0}}\\r\\n         \:2 {\:team \:enemy\\r\\n             \:hit-points 100\\r\\n             \:transform {\:x 160, \:y 0}}}\\r\\n        (\:tile-map ms/game))" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(update-in % [\:ecs \:entities 0] (fn [e] (\:team \:player))))" "(basic-combat-ai.desktop-launcher/reset)" "(\= \:team nil)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (comps/team \:team1)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" " (require '[basic-combat-ai.main-screen \:as ms])\\n(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 64)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (pistoleer % 64 32))))" "(defn basic-defender-ai []\\r\\n  (bt/->Sequence \:fresh 0\\r\\n                 [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                  (enemy-ai/->EngageCombatTarget \:fresh)]))" "(defn basic-defender-ai []\\r\\n  (->\\r\\n    (bt/->Sequence \:fresh 0\\r\\n                 [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                  (enemy-ai/->EngageCombatTarget \:fresh)])\\r\\n    (bt/add-ids-to-tree)))" "(defn defender [{tex-cache \:tex-cache} x y]\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (comps/team \:team1)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-defender-ai))\\r\\n      )))" "(defn init-game []\\r\\n  (let [tex-cache (init-tex-cache)]\\r\\n    (-> {\:batch (SpriteBatch.)\\r\\n         \:camera (OrthographicCamera. 800 600)\\r\\n         \:tex-cache tex-cache\\r\\n         \:inputs {}\\r\\n         \:tile-map (tile-map/create-grid 10 19 tex-cache)}\\r\\n      (ecs/init)\\r\\n      (ent/init)\\r\\n      (sys/init))))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\n     \:fire-pistol00-orange (.findRegion atlas \\"fire-pistol00 orange\\")\\n     \:fire-pistol01-orange (.findRegion atlas \\"fire-pistol01 orange\\")\\n     \:fire-pistol02-orange (.findRegion atlas \\"fire-pistol02 orange\\")\\n     \:pistol-idle-orange (.findRegion atlas \\"pistol idle orange\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     }))" "(defn basic-attacker-ai []\\n  (-> \\n    (bt/->Selector \:fresh 0\\n                   [(bt/->Sequence \:fresh 0\\r\\n                                   [(enemy-ai/->LocateACombatTarget \:fresh)\\r\\n                                    (enemy-ai/->EngageCombatTarget \:fresh)])\\n                    (bt/->Sequence \:fresh 0 \\r\\n                                   [(enemy-ai/->HasMoveTo \:fresh)\\r\\n                                    (enemy-ai/->FindPath \:fresh)\\r\\n                                    (enemy-ai/->FollowPath \:fresh)])])\\n    (bt/add-ids-to-tree)))" "(defn move-to [ent x-tile y-tile]\\r\\n  (assoc ent\\r\\n         {\:move-to {\:x x-tile\\r\\n                    \:y y-tile}}))" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 96 0))))" ";(do \\r\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 0 0)))\\r\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 32 0)))\\r\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 64 0)))\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 96 0)))\\r\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 128 0)))\\r\\n;  (ms/update-game\! \#(ecs/add-entity % (attacker % 160 0))))" "(defn attacker [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle-orange tex-cache))\\r\\n    (comps/team \:team2)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 180 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle-orange tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01-orange tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02-orange tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle-orange tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-attacker-ai))\\r\\n      )))" "(do \\r\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192))))" "(\:entities (\:ecs ms/game)\\n           )" "(map (fn [e] [(\:renderable e) (\:animation e) (\:transform e)])\\n  (\:entities (\:ecs ms/game)))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(render ms/game)" "(ns basic-combat-ai.entities)" "(filter (fn [e] (get-in e [\:renderable \:texture]))\\n  (\:entities (\:ecs ms/game)))" "(filter (fn [e] (nil? (get-in e [\:renderable \:texture])))\\n  (\:entities (\:ecs ms/game)))" "(count (filter (fn [e] (nil? (get-in e [\:renderable \:texture])))\\n         (\:entities (\:ecs ms/game))))" " (require '[basic-combat-ai.main-screen \:as ms])\\r\\n\\r\\n\\r\\n(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))\\r\\n\\r\\n(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192))))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 96 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))\\r\\n\\r\\n(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192))))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 96 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))\\r\\n\\r\\n(do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192))))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\n  (do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 96 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))\\r\\n\\r\\n  (do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192)))))" "(basic-combat-ai.desktop-launcher/reset)" "(do \\n  (do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 32 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 64 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 96 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 128 0)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (defender % 160 0))))\\r\\n\\r\\n  (do \\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 96 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 128 192)))\\r\\n     (ms/update-game\! \#(ecs/add-entity % (attacker % 160 192)))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.atlas\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:fire-pistol00-orange (.findRegion atlas \\"fire pistol00 orange\\")\\r\\n     \:fire-pistol01-orange (.findRegion atlas \\"fire pistol01 orange\\")\\r\\n     \:fire-pistol02-orange (.findRegion atlas \\"fire pistol02 orange\\")\\r\\n     \:pistol-idle-orange (.findRegion atlas \\"pistol idle orange\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     \:cover (.findRegion atlas \\"cover\\")\\r\\n     }))" ";cover entity." ";\:claimed-by id 1" ";\:chance-to-miss" ";system for cover to check if someone is standing on it" ";maybe here i do collisions?" ";at beginning of cover system, remove cover from all ents then re-apply" "(\:cover (\:tex-cache game))" "(basic-combat-ai.desktop-launcher/reset)" "(\:cover (\:tex-cache game))" "\\r\\n(defn missable [ent chance-to-miss]\\r\\n  (assoc ent \:chance-to-miss chance-to-miss))" "(defn sandbags [x y]\\r\\n  (->\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/missable 10)))" "(defn sandbags [{tex-cache \:tex-cache} x y]\\r\\n  (->\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/missable 10)))" "(defn sandbags [{tex-cache \:tex-cache} x y]\\r\\n  (->\\r\\n    (comps/transform x y 0 16 16)\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/missable 10)))" ";(defn cover [{{entities \:entities} \:ecs}]\\n ;check if any entities share a tile-grid with current sandbag." "(defn cover [ent chance-to-miss]\\r\\n  (assoc ent \:cover chance-to-miss))\\r\\n\\r\\n(defn missable [ent chance-to-miss]\\r\\n  (assoc ent \:chance-to-miss chance-to-miss))" ";(defn cover [{{entities \:entities} \:ecs}]\\n ;remove \:in-cover\\n  ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\n ;if one does," ";(defn cover [{{entities \:entities} \:ecs}]\\n ;remove in-cover\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\n ;if one does," "(defn in-cover [ent chance-to-miss]\\r\\n  (assoc ent \:chance-to-miss chance-to-miss))" "(\= {} {})" "(\= {} {\:1 1})" "(\= {\:1 1} {\:1 1})" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [qualifying-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))]\\n   (in-same-tile? {\:transform {\:x 32 \:y 64}} {\:transform {\:x 32 \:y 64}})))" "(require '[basic-combat-ai.main-screen \:as ms])" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [qualifying-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))]\\n   (in-same-tile? {\:transform {\:x 32 \:y 64}} {\:transform {\:x 32 \:y 0}})))" "(cover ms/game)" "(for [a [1 2 3 4 5]\\n      b [5 6 7 8 9]]\\n  (\= a b))" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (let [cs (first c-spots)]\\n                        (if (in-same-tile? e (first cs))\\n                          cs\\n                          (recur (rest c-spots))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 32 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (let [cs (first c-spots)]\\n                        (if (in-same-tile? e cs)\\n                          cs\\n                          (recur (rest c-spots))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 32 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (let [cs (first c-spots)]\\n                        (if (in-same-tile? e cs)\\n                          cs\\n                          (recur (rest c-spots))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (let [cs (first c-spots)]\\n                        (if (in-same-tile? e cs)\\n                          cs\\n                          (recur (rest c-spots))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 0}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 0}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))                \\n       ]\\n   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover ms/game)" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/in-cover e (\:cover e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 updated)))))]\\n   applicable-ents-have-cover\\n;   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 0 \:y 0}}\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/in-cover e (\:cover e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated e))))))]\\n   applicable-ents-have-cover\\n;   (ents-cover {\:transform {\:x 32 \:y 32}} [{\:transform {\:x 0 \:y 0}} {\:transform {\:x 32 \:y 32}}])\\n   ))" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 0 \:y 0}}\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 0 \:y 0}}\\n                         ]}})" "(cover {\:ecs {\:entities [\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/in-cover e (\:cover e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated e))))))]\\n   (into cover-ents applicable-ents-have-cover)))" "(cover {\:ecs {\:entities [\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 0 \:y 0}}\\n                         ]}})" "(cover {\:ecs {\:entities [{\:transform {\:x 32 \:y 32}}\\n                         {\:transform {\:x 0 \:y 0}}\\n                         {\:transform {\:x 32 \:y 32}\\n                          \:cover 100}]}})" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:in-cover)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:cover %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\n       ents-cover (fn [e cover-spots]\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\n                    (loop [c-spots cover-spots]\\n                      (if (empty? c-spots)\\n                        nil\\n                        (let [cs (first c-spots)]\\n                          (if (in-same-tile? e cs)\\n                            cs\\n                            (recur (rest c-spots)))))))\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/in-cover e (\:cover e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated e))))))]\\n   (into cover-ents applicable-ents-have-cover)))" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:chance-to-miss)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:provides-chance-to-miss %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\r\\n       ents-cover (fn [e cover-spots]\\r\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\r\\n                    (loop [c-spots cover-spots]\\r\\n                      (if (empty? c-spots)\\r\\n                        nil\\r\\n                        (let [cs (first c-spots)]\\r\\n                          (if (in-same-tile? e cs)\\r\\n                            cs\\r\\n                            (recur (rest c-spots)))))))\\r\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/chance-to-miss e (\:provides-chance-to-miss e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated e))))))]\\r\\n   (into cover-ents applicable-ents-have-cover)))" "(defn provides-chance-to-miss [ent chance-to-miss]\\r\\n  (assoc ent \:provides-chance-to-miss chance-to-miss))\\r\\n\\r\\n(defn chance-to-miss [ent chance-to-miss]\\r\\n  (assoc ent \:chance-to-miss chance-to-miss))" "(defn cover [{{entities \:entities} \:ecs tile-map \:tile-map}]\\r\\n ;remove in-cover\\r\\n ;check if any entities with hp share a tile-grid with current sandbag, other than the sandbag itself.\\r\\n ;if one does, give it in-cover with appropriate miss chance.\\r\\n (let [removed-in-cover (mapv (fn [e] (dissoc e \:chance-to-miss)) entities)\\r\\n       [cover-ents rest-ents] (filter-ents removed-in-cover \#(\:provides-chance-to-miss %))\\r\\n       in-same-tile? (fn [e1 e2]\\r\\n                       (let [e1-transform (\:transform e1)\\r\\n                             e1-tile-loc {\:x (tile-map/world-coord->grid (\:x e1-transform)), \:y (tile-map/world-coord->grid (\:y e1-transform))}\\r\\n                             e2-transform (\:transform e2)\\r\\n                             e2-tile-loc {\:x (tile-map/world-coord->grid (\:x e2-transform)), \:y (tile-map/world-coord->grid (\:y e2-transform))}]\\r\\n                         (\= e1-tile-loc e2-tile-loc)))\\r\\n       ents-cover (fn [e cover-spots]\\r\\n                    \\"return the entity's cover spot, if it doesnt have one then return nil.\\"\\r\\n                    (loop [c-spots cover-spots]\\r\\n                      (if (empty? c-spots)\\r\\n                        nil\\r\\n                        (let [cs (first c-spots)]\\r\\n                          (if (in-same-tile? e cs)\\r\\n                            cs\\r\\n                            (recur (rest c-spots)))))))\\r\\n       applicable-ents-have-cover (loop [ents rest-ents\\r\\n                                         updated []]\\r\\n                                    (if (empty? ents)\\r\\n                                      updated\\r\\n                                      (let [e (first ents)]\\r\\n                                        (if-let [e-cover (ents-cover e cover-ents)]\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated (comps/chance-to-miss e (\:provides-chance-to-miss e-cover))))\\r\\n                                          (recur (rest ents)\\r\\n                                                 (conj updated e))))))]\\r\\n   (into cover-ents applicable-ents-have-cover)))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    (ecs/add-system cover)\\r\\n    ))" "(defn sandbags [{tex-cache \:tex-cache} x y]\\r\\n  (->\\r\\n    (comps/transform x y 0 16 16)\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/provides-chance-to-miss 10)))" "(defn add-entity [ent-fn]\\r\\n  \\"Accepts an entity function and adds it to the global game map directly.\\"\\r\\n  (ms/update-game\! \#(ecs/add-entity % ent-fn)))" "(add-entity \#(sandbags % 0 0))" "(defn add-entity [ent-fn]\\r\\n  \\"Accepts an entity function and adds it to the global game map directly.\\"\\r\\n  (ms/update-game\! \#(ecs/add-entity % (ent-fn %))))" "(add-entity \#(sandbags % 0 0))" "(get-in ms/game [\:ecs \:entities])" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(require '[basic-combat-ai.main-screen \:as ms])" "(sandbags ms/game 0 0)" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" ";(defn did-target-miss? [entities main-ent]\\n;  (if-let [miss-chance (\:chance-to-miss main-ent)]\\n    (rand 100)" ";(defn did-target-miss? [entities main-ent]\\n;  (if-let [miss-chance (\:chance-to-miss main-ent)]\\n    (rand-int 100)" "(defn did-target-miss? [entities main-ent]\\r\\n  (if-let [miss-chance (\:chance-to-miss main-ent)]\\r\\n    (< (rand-int 100) miss-chance)\\r\\n    false))" "(defn did-target-miss? [main-ent]\\r\\n  (if-let [miss-chance (\:chance-to-miss main-ent)]\\r\\n    (< (rand-int 100) miss-chance)\\r\\n    false))" "(did-target-miss? {\:chance-to-miss 100})" "(did-target-miss? {\:chance-to-miss 1})" "(did-target-miss? {})" "(did-target-miss? {\:chance-to-miss 50})" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(get-in ms/game [\:ecs \:entities])" " (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "(get-in ms/game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(ms/pause)" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(cover ms/game)" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(defn run-game [game systems]\\r\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           ;death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n                           timed-life])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n                           death\\r\\n])\\r\\n        [\:ecs \:entities])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                           create-pending-entity\\r\\n                           projectile-weapon-cooldown\\r\\n                           animate\\r\\n                           rotate\\r\\n                           move\\r\\n\\r\\n])\\r\\n        [\:ecs \:entities])" "(death ms/game)" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (<\= (\:hit-points e) 0))]\\r\\n    (filter die? qualifying-ents)))" "(death ms/game)" "(death {\:ecs {\:entities [{\:hit-points 0}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (if (<\= (\:hit-points e) 0) e nil))]\\r\\n    (map die? qualifying-ents)))" "(death {\:ecs {\:entities [{\:hit-points 0}]}})" "(death {\:ecs {\:entities [{\:hit-points 1}]}})" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0}]}})" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (if (<\= (\:hit-points e) 0) e nil))]\\r\\n    (into rest-ents (map die? qualifying-ents))))" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0}]}})" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(death {\:ecs {\:entities [{}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (if (<\= (\:hit-points e) 0) e nil))]\\r\\n    (into rest-ents (filter \#(not nil?) (map die? qualifying-ents)))))" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (if (<\= (\:hit-points e) 0) e nil))]\\r\\n    (into rest-ents (filter \#(not (nil? %)) (map die? qualifying-ents)))))" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        die? (fn [e] (if (<\= (\:hit-points e) 0) nil e))]\\r\\n    (into rest-ents (filter \#(not (nil? %)) (map die? qualifying-ents)))))" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(defn death [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:hit-points %))\\r\\n        nil-if-dead (fn [e] (if (<\= (\:hit-points e) 0) nil e))\\n        remove-nils (fn [ents] (filter \#(not (nil? %)) ents))]\\n    (-> (map nil-if-dead qualifying-ents)\\n      (remove-nils)\\r\\n      (into rest-ents))))" "(death {\:ecs {\:entities [{\:hit-points 1} {\:hit-points 0} {}]}})" "(-> [1]\\n  (if (\= 1 1) \#(+ 1) 0))" "(-> 1\\n  (if (\= 1 1) \\n    \#(+ 1) \\n    0))" "(-> 1\\n  \#(if (\= 1 1) \\n    \#(+ % 1) \\n    0))" "(-> 1\\n  \#(if (\= 1 1) \\n    (+ % 1)\\n    0))" "(-> 1\\n  (fn [x] (if (\= 1 1) (+ x 1) 0)))" "(defn miss-shot? [target]\\r\\n  (if-let [miss-chance (\:chance-to-miss target)]\\r\\n    (< (rand-int 100) miss-chance)\\r\\n    false))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (let [target-id (\:combat-target-id main-ent)]\\r\\n    (if (miss-shot? (target-id entities))\\r\\n      entities\\r\\n      (update-in entities [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                       (- hp (\:damage (\:projectile-weapon main-ent)))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged updated-main-ent)\\r\\n                             (pending-tracer-added updated-main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(defn miss-shot? [target]\\r\\n  (if-let [miss-chance (\:chance-to-miss target)]\\r\\n    (< (rand-int 100) miss-chance)\\r\\n    false))\\r\\n\\r\\n(defn- combat-target-damaged [entities main-ent]\\r\\n  (let [target-id (\:combat-target-id main-ent)]\\r\\n    (if (miss-shot? (target-id entities))\\r\\n      entities\\r\\n      (update-in entities [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                       (- hp (\:damage (\:projectile-weapon main-ent))))))))\\r\\n  \\r\\n(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged updated-main-ent)\\r\\n                             (pending-tracer-added updated-main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sangbags % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities])" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(combat-target-damaged (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                       (\:27 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(combat-target-damaged (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                       (\:28 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(combat-target-damaged (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                       (\:27 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(count (get-in ms/game [\:ecs \:entities]))" "(map \#(\:id %) (get-in ms/game [\:ecs \:entities]))" "(get-in ms/game [\:ecs \:entities])" ";27 is the cover" "(combat-target-damaged (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                       (\:26 (ent-vec->map (get-in ms/game [\:ecs \:entities]))))" "(tick-behavior-tree ms/game)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (let [q-ents qualifying-ents ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (or (\= (\:status (\:node canceled-tick-data)) \:failure)\\r\\n                                       (\= id-existing id-canceled))\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n            ))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (let [q-ents qualifying-ents ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n                                    (\= \:failure (\:status unchecked-bt)))\\r\\n                              (bt/reset-behavior-tree unchecked-bt)\\r\\n                              unchecked-bt)\\r\\n                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n                               (if (or (\= (\:status (\:node canceled-tick-data)) \:failure)\\r\\n                                       (\= id-existing id-canceled))\\r\\n                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                                 canceled-tick-data))\\r\\n                             ;status is fresh\\r\\n                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n            ))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n      ents-map (ent-vec->map ents)]\\r\\n       (let [q-ents qualifying-ents ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))]\\n             ent-id))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n;                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n;                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n;                                    (\= \:failure (\:status unchecked-bt)))\\r\\n;                              (bt/reset-behavior-tree unchecked-bt)\\r\\n;                              unchecked-bt)\\r\\n;                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n;                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n;                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n;                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n;                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n;                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n;                               (if (or (\= (\:status (\:node canceled-tick-data)) \:failure)\\r\\n;                                       (\= id-existing id-canceled))\\r\\n;                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n;                                 canceled-tick-data))\\r\\n;                             ;status is fresh\\r\\n;                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n;             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n;            ))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n      ents-map (ent-vec->map ents)]\\r\\n       (let [q-ents qualifying-ents ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))]\\n             (bt/tick checked-bt ent-id ents-m t-map)))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n;                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n;                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n;                                    (\= \:failure (\:status unchecked-bt)))\\r\\n;                              (bt/reset-behavior-tree unchecked-bt)\\r\\n;                              unchecked-bt)\\r\\n;                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n;                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n;                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n;                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n;                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n;                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n;                               (if (or (\= (\:status (\:node canceled-tick-data)) \:failure)\\r\\n;                                       (\= id-existing id-canceled))\\r\\n;                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n;                                 canceled-tick-data))\\r\\n;                             ;status is fresh\\r\\n;                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n;             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n;            ))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n      ents-map (ent-vec->map ents)]\\r\\n       (let [q-ents qualifying-ents ;only use this for the id's. \\r\\n             ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))]\\n             (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\r\\n;                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\r\\n;                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\r\\n;                                    (\= \:failure (\:status unchecked-bt)))\\r\\n;                              (bt/reset-behavior-tree unchecked-bt)\\r\\n;                              unchecked-bt)\\r\\n;                 tick-data (if (\= (\:status checked-bt) \:running)\\r\\n;                             (let [id-existing (bt/get-id-of-running-composite checked-bt)\\r\\n;                                   canceled-tick-data  (let [canceled-return-data (bt/cancel-running-leaf checked-bt ent-id ents-m t-map)\\r\\n;                                                             reseted-tree (bt/reset-behavior-tree checked-bt)]\\r\\n;                                                        (bt/tick reseted-tree ent-id (\:entities canceled-return-data) (\:tile-map canceled-return-data)))\\r\\n;                                   id-canceled (bt/get-id-of-running-composite (\:node canceled-tick-data))]\\r\\n;                               (if (or (\= (\:status (\:node canceled-tick-data)) \:failure)\\r\\n;                                       (\= id-existing id-canceled))\\r\\n;                                 (bt/tick checked-bt ent-id ents-m t-map)\\r\\n;                                 canceled-tick-data))\\r\\n;                             ;status is fresh\\r\\n;                             (bt/tick checked-bt ent-id ents-m t-map))\\r\\n;                 updated-ents-m (\:entities tick-data)\\r\\n;                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n;             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n;            ))))" "(bt/run (->EngageCombatTarget \:running)\\n        \:26\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(fire-weapon \:26 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged updated-main-ent)\\r\\n                             (pending-tracer-added updated-main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon \:26 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(defn- fire-weapon [main-ent-id entities]\\r\\n  \\"Returns the full map of entities with the main entity and the target entity updated as a result of firing the main ent's weapon.\\r\\n   Does not tick the cooldown for the weapon. Expecting a system to handle it because it will always tick every update.\\"\\r\\n  (if (can-fire? (main-ent-id entities))\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          updated-main-ent (fired-weapon main-ent)\\r\\n          updated-entities (-> entities\\r\\n                             (assoc main-ent-id updated-main-ent)\\r\\n                             (combat-target-damaged main-ent)\\r\\n                             (pending-tracer-added main-ent))]\\r\\n      updated-entities)\\r\\n    entities))" "(fire-weapon \:26 (ent-vec->map (get-in ms/game [\:ecs \:entities])))" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "(defn sandbags [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/provides-chance-to-miss 100)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "(get-in ms/game [\:ecs \:entities])" "(defn sandbags [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:cover tex-cache))\\r\\n    (comps/provides-chance-to-miss 30)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16))))" "(defn defender [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.2\\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (comps/team \:team1)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-defender-ai))\\r\\n      )))\\r\\n\\r\\n(defn attacker [{tex-cache \:tex-cache} x y]\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.2\\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle-orange tex-cache))\\r\\n    (comps/team \:team2)\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 180 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle-orange tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01-orange tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02-orange tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle-orange tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-attacker-ai))\\r\\n      )))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:chance-to-miss 90]))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:chance-to-miss] 90))" "(ms/update-game\! \#(update-in % [\:ecs \:entities] \#(rest %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(update-in % [\:ecs \:entities] (fn [s] (rest s))))" "(get-in ms/game [\:ecs \:entities])" "(ns basic-combat-ai.systems)" "(death ms/game)" "(require '[basic-combat-ai.main-screen \:as ms])" "(death ms/game)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:projectile-weapon \:cooldown] 0.3))" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192))))" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (sandbags % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 32 192)))\\n  (ms/update-game\! \#(ecs/add-entity % (attacker % 64 192))))" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n\\n  )" ";alien planet, harvest their fukkin resources, YO\!" ";the zerg" ";they getting fucking pissed" ";they don't know how strong you are" ";they send increasingly more powerful attack groups" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:fire-pistol00-orange (.findRegion atlas \\"fire pistol00 orange\\")\\r\\n     \:fire-pistol01-orange (.findRegion atlas \\"fire pistol01 orange\\")\\r\\n     \:fire-pistol02-orange (.findRegion atlas \\"fire pistol02 orange\\")\\r\\n     \:pistol-idle-orange (.findRegion atlas \\"pistol idle orange\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     \:cover (.findRegion atlas \\"cover\\")\\r\\n     \:monster-idle (.findRegion atlas \\"monster idle\\")\\r\\n     \:monster-walk00 (.findRegion atlas \\"monster walk 00\\")\\r\\n     \:mosnter-walk01 (.findREgion atlas \\"monster walk 01\\")\\r\\n     }))" "(defn init-tex-cache []\\r\\n  (let [atlas (TextureAtlas. \\"s.pack\\")]\\r\\n    {\:fire-pistol00 (.findRegion atlas \\"fire pistol00\\")\\r\\n     \:fire-pistol01 (.findRegion atlas \\"fire pistol01\\")\\r\\n     \:fire-pistol02 (.findRegion atlas \\"fire pistol02\\")\\r\\n     \:pistol-idle (.findRegion atlas \\"pistol idle\\")\\r\\n     \:fire-pistol00-orange (.findRegion atlas \\"fire pistol00 orange\\")\\r\\n     \:fire-pistol01-orange (.findRegion atlas \\"fire pistol01 orange\\")\\r\\n     \:fire-pistol02-orange (.findRegion atlas \\"fire pistol02 orange\\")\\r\\n     \:pistol-idle-orange (.findRegion atlas \\"pistol idle orange\\")\\r\\n     \:floor (.findRegion atlas \\"floor\\")\\r\\n     \:wall (.findRegion atlas \\"wall\\")\\r\\n     \:tracer (.findRegion atlas \\"tracer\\")\\r\\n     \:cover (.findRegion atlas \\"cover\\")\\r\\n     \:monster-idle (.findRegion atlas \\"monster idle\\")\\r\\n     \:monster-walk00 (.findRegion atlas \\"monster walk 00\\")\\r\\n     \:monster-walk01 (.findREgion atlas \\"monster walk 01\\")\\n     \:monster-attack-00 (.findRegion atlas \\"monster attack 00\\")\\n     \:monster-attack-01 (.findRegion atlas \\"monster attack 01\\")\\n     \:monster-attack-02 (.findRegion atlas \\"monster attack 02\\")\\r\\n     }))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(\:tex-cache game)" "(sort (keys (\:tex-cache game)))" "(defn zergling [{tex-cache \:tex-cache} x y]\\n  (-> {}\\n    (comps/renderable (\:monster-idle tex-cache))\\n    (comps/hit-points 40)\\n    (comps/team \:team2)\\n    (assoc \:transform (comps/transform x y 0 16 16)\\n           \:movespeed (comps/movespeed 2 8)\\n           \:animation (comps/animation\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)\\n                                                     (comps/frame (\:monster-idle tex-cache) 0.1)] true\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.1)] false)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (zergling % 64 64)))" "(\:camera ms/game)" "(.zoom (\:camera ms/game) (float 0.5))" "(.-zoom (\:camera ms/game) (float 0.5))" "(.-zoom (\:camera ms/game))" "(set\! (.-zoom (\:camera ms/game)) (float 1.5))" "(set\! (.-zoom (\:camera ms/game)) (float 0.5))" "(ns basic-combat-ai.main-screen)" "(.getWidth() Gdx/graphics)" "(.getWidth Gdx/graphics)" "(ns basic-combat-ai.entities)" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-idle))" "(get-in ms/game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:pistol-idle))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 0)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-idle))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-idle))" "(get-in ms/game [\:ecs \:entites])" "(get-in ms/game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 0)))" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(animate ms/game)" "(animate (assoc-in ms/game [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(ms/update-game ms/game [\:ecs \:entities \:renderable \:texture] (\:monster-walk00 (\:tex-cache ms/game)))" "(ms/update-game\! ms/game [\:ecs \:entities \:renderable \:texture] (\:monster-walk00 (\:tex-cache ms/game)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities \:renderable \:texture] (\:monster-walk00 (\:tex-cache %))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:renderable \:texture] (\:monster-walk00 (\:tex-cache %))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:renderable \:texture] (\:monster-walk01 (\:tex-cache %))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:renderable \:texture] (\:monster-walk00 (\:tex-cache %))))" "(ns basic-combat-ai.entities)" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 40)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.1)] false)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (zergling % 32 32)))" "(animate (assoc-in ms/game [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(get-in ms/game [\:ecs \:entities])" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n;    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    (ecs/add-system cover)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 0)))" "(ns basic-combat-ai.systems)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(animate ms/game)" "(ms/update-game \#(assoc-in % [\:ecs \:entities] (animate %)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(animate ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(animate ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(animate ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (animate %)))" "(get-in ms/game [\:ecs \:entities])" "(animate ms/game)" "(defn- animate* [e delta]\\r\\n  (if-not (get-in e [\:animation \:current-animation])\\r\\n\\t  e\\r\\n\\t  (let [current-duration (get-in e [\:animation \:current-duration])\\r\\n\\t        current-frame-num (get-in e [\:animation \:current-frame])\\r\\n\\t        current-animation (get-in e [\:animation \:current-animation])\\r\\n\\t        current-frames (get-in e [\:animation \:frames current-animation \:frame-duration])]\\r\\n\\t    (cond\\r\\n        (neg? current-frame-num)\\r\\n        (-> e \\r\\n          (set-current-frame-num 0)\\r\\n          (assoc-in [\:animation \:current-duration] (\:duration (first current-frames)))\\r\\n          (set-renderable 0 current-frames))\\r\\n\\t          \\r\\n\\t      (> current-duration 0)\\r\\n\\t      (assoc-in e [\:animation \:current-duration] (- current-duration delta))\\r\\n\\t    \\r\\n\\t      (and (neg? current-duration) (< current-frame-num (dec (count current-frames))))\\r\\n\\t      (-> e \\r\\n\\t         (set-current-frame-num (inc current-frame-num))\\r\\n\\t         (set-renderable (inc current-frame-num) current-frames)\\r\\n\\t         (assoc-in [\:animation \:current-duration] (\:duration (nth current-frames (inc current-frame-num)))))\\r\\n\\t      \\r\\n\\t      (\= current-frame-num (dec (count current-frames)))\\r\\n\\t      (if (get-in e [\:animation \:frames current-animation \:loop?])\\r\\n\\t\\t      (-> e \\r\\n\\t\\t        (set-current-frame-num 0)\\r\\n            (set-renderable 0 current-frames)\\r\\n\\t\\t        (assoc-in [\:animation \:current-duration] (\:duration (first current-frames))))\\r\\n\\t\\t      (-> e\\r\\n\\t\\t        (assoc-in [\:animation \:current-animation] nil)\\r\\n\\t\\t        (set-current-frame-num -1)))))))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    (ecs/add-system cover)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 0)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-idle))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-walk))" "(do \\n  (ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-animation] \:monster-idle))\\n  (ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:animation \:current-frame] -1)))" ";(defrecord LoopUntil [status curr-child-idx children]\\r\\n;  NodeBehavior\\r\\n;  (reset [node]\\r\\n;    (assoc node \\r\\n;           \:status \:fresh\\r\\n;           \:curr-child-idx 0))\\r\\n;  (run [node main-ent-id entities tile-map]\\r\\n;    (reduce (fn [child] (\= (\:status child) \:success)) children)" "(reduce \#(and %1 %2) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(reduce \#(and (\= \:success (\:status %1)) (\= \:success (\:status %2))) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(map \#(\= \:success (\:status %)) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(apply and [true true true])" "(apply \#(and % %) [true true true])" "(apply \#(and % % %) [true true true])" "(apply \#(and %1 %2) [true true true])" "(apply \#(and %1 %2 %3) [true true true])" "(use 'clojure.repl)" "(source and)" "(source def)" "(+ [1 2 3])" "(apply + [1 2 3])" "(apply (fn [& b] b) [true true false true])" "(every? identity '(true false))" "(every? identity [true false])" ";(defrecord LoopUntil [status curr-child-idx children]\\r\\n;  NodeBehavior\\r\\n;  (reset [node]\\r\\n;    (assoc node \\r\\n;           \:status \:fresh\\r\\n;           \:curr-child-idx 0))\\r\\n;  (run [node main-ent-id entities tile-map]\\r\\n;    (every \#(\= (\:status %)) children)" "(every \#(\= \:success (\:status %)) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(every? \#(\= \:success (\:status %)) [{\:status \:success} {\:status \:success} {\:status \:success}])" "(every? \#(\= \:success (\:status %)) [{\:status \:success} {\:status \:success} {\:status \:running}])" "(ns basic-combat-ai.components)" "(defn melee-weapon [ent & {\:keys cooldown curr-cooldown damage}]\\r\\n  (assoc ent \\r\\n         \:melee-weapon {\:cooldown cooldown\\r\\n                        \:curr-cooldown curr-cooldown\\r\\n                        \:damage damage}))" "(defn melee-weapon [ent & {\:keys cooldown curr-cooldown damage}]\\r\\n  nil)" "(defn melee-weapon [ent & {\:keys [cooldown curr-cooldown damage]}]\\r\\n  (assoc ent \\r\\n         \:melee-weapon {\:cooldown cooldown\\r\\n                        \:curr-cooldown curr-cooldown\\r\\n                        \:damage damage}))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.1)] false)))))" "(defn- engage-combat [node main-ent-id entities curr-tile-map attack-fn]\\n  (if (nil? ((\:combat-target-id (main-ent-id entities)) entities))\\r\\n    (bt/make-return-map (assoc node \:status \:failure)\\r\\n                        (update entities main-ent-id (fn [main-ent] (dissoc (main-ent-id entities) \:combat-target)))\\r\\n                        curr-tile-map)\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          target-ent ((\:combat-target-id main-ent) entities)\\r\\n          angle-to-face-target (-> \\r\\n                                 (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] [(\:x (\:transform target-ent)) (\:y (\:transform target-ent))])\\r\\n                                 (math-utils/round-to-decimal 1))]\\r\\n      (cond\\r\\n        (not\= (\:rotation (\:transform main-ent)) angle-to-face-target)\\r\\n        (bt/make-return-map node\\r\\n                            (assoc-in entities [main-ent-id \:target-rotation] angle-to-face-target)\\r\\n                            curr-tile-map)\\r\\n        (los? main-ent target-ent curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (attack-fn)\\r\\n                            curr-tile-map)\\r\\n        \:else \\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            (update entities main-ent-id (fn [main-ent] (dissoc main-ent \:combat-target)))\\r\\n                            curr-tile-map)))))\\n  \\n(defrecord MeleeCombatTarget [status]\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\n  (bt/run [node main-ent-id entities curr-tile-map]\\n    (engage-combat node main-ent-id entities curr-tile-map \#(fire-weapon main-ent-id entities))))" "((fn [] \#(println \\"hello world\\")))" "(fn [] \#(println \\"hello world\\"))" "((fn [] (\#(println \\"hello world\\"))))" "(defrecord EngageCombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (engage-combat node main-ent-id entities curr-tile-map \#(fire-weapon main-ent-id entities))))" "(ns basic-combat-ai.entities)" "(basic-combat-ai.desktop-launcher/reset)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  \\"x and y need to be in terms of world coordinates. stop fucking putting in grid coords, chris.\\r\\nalthough you should definately make it grid coords, because putting in world coordinates makes no fucking sense.\\"\\r\\n  (-> {} \\r\\n    (comps/hit-points 100)\\r\\n    (comps/projectile-weapon \:cooldown 0.8 \\r\\n                             \:curr-cooldown 0.0 \\r\\n                             \:damage 10 \\r\\n                             \:max-ammo 9 \\r\\n                             \:current-ammo 9 \\r\\n                             \:reload-speed 5)\\r\\n    (comps/renderable (\:pistol-idle tex-cache))\\r\\n    (assoc \\r\\n      \:transform (comps/transform x y 0 16 16)\\r\\n      \:movespeed (comps/movespeed 2 8)\\r\\n      \:animation (comps/animation\\r\\n                   (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                 \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                               (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n      \:behavior-tree (comps/behavior-tree (enemy-ai-tree/basic-ai))\\r\\n      \\r\\n      ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n        ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n        ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n        \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n        \:self-collider (comps/self-collider 0 0 32 32)\\r\\n      )))" "(ms/update-game\! \#(ecs/add-entity % (pistoleer % 0 0)))" "(ms/pause)" "(ms/resume)" "(ms/pause)" "(get-in ms/game [\:ecs \:entities])" "(not\= nil nil)" "(ms/resume)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(get-in ms/game [\:ecs \:entities])" "(ns basic-combat-ai.enemy-ai)" "(source can-fire?)" "(use 'clojure.repl)" "(source can-fire?)" "(defn melee-attack [main-ent-id entities]\\r\\n  (let [main-ent (main-ent-id entiites)]\\n    (if (<\= (\:curr-cooldown (\:melee-weapon main-ent)) 0)\\n      (let [launched-attack (-> main-ent\\n                              (assoc-in [\:animation \:current-animation] \:monster-attack)\\n                              (assoc-in [\:animation \:current-frame] -1)\\n                              (assoc-in [\:melee-weapon \:curr-cooldown] (get-in main-ent [\:melee-weapon \:cooldown]))\\n                              (dissoc \:combat-target-id))\\n            entities-w-launched (assoc entities main-ent-id launched-attack)\\n            entities-w-damaged (update-in entities-w-launched [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                                                           (- hp (\:damage (\:melee-weapon main-ent)))))]\\n        entities-w-damaged)\\n      entities)))" "(defn melee-attack [main-ent-id entities]\\r\\n  (let [main-ent (main-ent-id entities)]\\n    (if (<\= (\:curr-cooldown (\:melee-weapon main-ent)) 0)\\n      (let [launched-attack (-> main-ent\\n                              (assoc-in [\:animation \:current-animation] \:monster-attack)\\n                              (assoc-in [\:animation \:current-frame] -1)\\n                              (assoc-in [\:melee-weapon \:curr-cooldown] (get-in main-ent [\:melee-weapon \:cooldown]))\\n                              (dissoc \:combat-target-id))\\n            entities-w-launched (assoc entities main-ent-id launched-attack)\\n            entities-w-damaged (update-in entities-w-launched [(\:combat-target-id main-ent) \:hit-points] (fn [hp] \\r\\n                                                                                                           (- hp (\:damage (\:melee-weapon main-ent)))))]\\n        entities-w-damaged)\\n      entities)))" "(defrecord MeleeCombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (engage-combat node main-ent-id entities curr-tile-map \#(melee-attack main-ent-id entities))))" "(defn- closest-visible-entity [main-ent-id entities curr-tile-map]\\n  \\"Returns the closest visible entity. If none found, nil.\\"\\n  (let [main-ent (main-ent-id entities)\\r\\n        qualifying-ents (into {} (filter (fn [e] (let [e-value (second e)]\\r\\n                                                   (and (\:hit-points e-value) (not\= (\:team e-value) (\:team main-ent)))))\\r\\n                                         entities)) \\r\\n        ents-los-checked (map \\r\\n                           (fn [e] \\r\\n                             {\:entity e \\r\\n                              \:have-los? (los? main-ent e curr-tile-map)})\\r\\n                           (vals (dissoc qualifying-ents main-ent-id)))\\r\\n        ents-los-true (filter \#(\:have-los? %) ents-los-checked)\\r\\n        closest-ent (loop [e-los (rest ents-los-true)\\r\\n                           closest-ent (\:entity (first ents-los-true))]\\r\\n                      (if (empty? e-los)\\r\\n                        closest-ent\\r\\n                        (recur (rest e-los)\\r\\n                               (if (< (math-utils/distance (\:entity (first e-los))\\r\\n                                                           main-ent) \\r\\n                                      (math-utils/distance closest-ent\\r\\n                                                           main-ent))\\r\\n                                 (\:entity (first e-los))\\r\\n                                 closest-ent))))]\\n    closest-ent))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "\\r\\n(defrecord FindMeleeTargetToMoveTo [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id] (comps/move-to main-ent (\:x (\:transform closest-ent)) (\:y (\:transform closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(ns basic-combat-ai.enemy-ai)" "\\r\\n(defrecord FindMeleeTargetToMoveTo [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id] (comps/move-to main-ent (\:x (\:transform closest-ent)) (\:y (\:transform closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(nil {})" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          combat-target ((\:combat-target-id main-ent) entities)]\\n      (if (and (not (nil? combat-target)) (pos? (\:hit-points combat-target)))\\n        (bt/make-return-map (assoc node \:status \:success) entities tile-map)\\n        (bt/make-return-map (assoc node \:status \:failure) entities tile-map)))))" "(defn zergling-ai []\\n  (-> \\n    (bt/->Sequence \:fresh 0 \\n                   [(enemy-ai/->FindMeleeTargetToMoveTo \:fresh)\\n                    (enemy-ai/->FindPath \:fresh)\\n                    (enemy-ai/->FollowPath \:fresh)\\n                    (enemy-ai/->CombatTargetAlive? \:fresh)\\n                    (enemy-ai/->MeleeCombatTarget \:fresh)])\\n    (bt/add-ids-to-tree)))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.1)] false)))\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 192)))" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(do \\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192)))\\r\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/pause))" "(ms/resume)" "(ms/pause)" "(get-in ms/game [\:ecs \:entities])" "(get-in ms/game [\:ecs \:entities 0])" "(ns basic-combat-ai.enemy-ai)\\n(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          combat-target ((\:combat-target-id main-ent) entities)]\\r\\n      (if (and (not (nil? combat-target)) (pos? (\:hit-points combat-target)))\\r\\n        (bt/make-return-map (assoc node \:status \:success) entities tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure) entities tile-map)))))" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          combat-target ((\:combat-target-id main-ent) entities)]\\r\\n      (if (and (not (nil? combat-target)) (pos? (\:hit-points combat-target)))\\r\\n        (bt/make-return-map (assoc node \:status \:success) entities tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure) entities tile-map)))))" "(bt/run (->CombatTargetAlive \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(use 'clojure.repl)" "(print-stack-trace *e)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(print-stack-trace *e)" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          combat-target ((\:combat-target-id main-ent) entities)]\\r\\n      (if true\\r\\n        \\"a\\"\\r\\n        \\"b\\"))))" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          combat-target ((\:combat-target-id main-ent) entities)]\\r\\n      \\"a\\")))" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    \\"a\\"))" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(get nil {})" "(get \:a {\:a \\"a\\"})" "(get {} nil)" "(get {\:a 1} \:a)" "(defrecord CombatTargetAlive? [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\n          combat-target (get entities (\:combat-target-id main-ent))]\\r\\n      (if (and (not (nil? combat-target)) (pos? (\:hit-points combat-target)))\\r\\n        (bt/make-return-map (assoc node \:status \:success) entities tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure) entities tile-map)))))" "(bt/run (->CombatTargetAlive? \:fresh)\\n        \:1\\n        {\:1 {}\\n         \:2 {}}\\n        nil)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 192)))" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 1])" "(ms/pause)" "(get-in ms/game [\:ecs \:entities 0])" "(ns basic-combat-ai.enemy-ai)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 32)))" "(get-in ms/game [\:ecs \:entities 1])" "(get-in ms/game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 2])" "(get-in ms/game [\:ecs \:entities])" "(defrecord FindMeleeTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (-> entities\\r\\n                              (assoc main-ent-id (comps/move-to main-ent (\:x (\:transform closest-ent)) (\:y (\:transform closest-ent))))\\r\\n                              (assoc-in [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent)))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 32)))" "(get-in ms/game [\:ecs \:entities])" "(ms/pause)" "(ns basic-combat-ai.enemy-ai)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      closest-ent)))" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:696\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(defrecord LocateACombatTarget [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          closest-ent (closest-visible-entity main-ent-id entities curr-tile-map)]\\r\\n      (if (\:id closest-ent)\\r\\n        (bt/make-return-map (assoc node \:status \:success)\\r\\n                            (assoc-in entities [main-ent-id \:combat-target-id] (keyword (str (\:id closest-ent))))\\r\\n                            curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:failure)\\r\\n                            entities\\r\\n                            curr-tile-map)))))" "(bt/run (->LocateACombatTarget \:fresh)\\n        \:696\\n        (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n        (\:tile-map ms/game))" "(\:entities (bt/run (->LocateACombatTarget \:fresh)\\n                   \:696\\n                   (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n                   (\:tile-map ms/game)))" "(\:node (bt/run (->LocateACombatTarget \:fresh)\\n               \:696\\n               (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n               (\:tile-map ms/game)))" "(ns basic-combat-ai.entities)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 192)))" "(get-in ms/game [\:ecs \:entities])" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-idle tex-cache) 0.1)] false)))\\r\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 192)))" "(ms/pause)" "(get-in ms/game [\:ecs \:entities])" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn run-game [game systems]\\r\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))\\r\\n\\r\\n(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 9 (count prev-games)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))\\r\\n\\r\\n(defn run-times [n]\\r\\n  (loop [idx n]\\r\\n    (if (zero? idx)\\r\\n      nil\\r\\n      (do\\r\\n        (run-once)\\r\\n        (recur (dec idx))))))\\r\\n\\r\\n(defn revert-entities [idx]\\r\\n  (if (and (< idx 10) (>\= idx 0))\\r\\n    (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (nth prev-games idx)))))\\r\\n    \\"idx must be between 0 and 9, inclusive.\\"))" "(def prev-games [])\\n(defn run-game [game systems]\\r\\n  (assoc-in game [\:ecs \:entities] (loop [syss systems\\r\\n                                         ents (get-in game [\:ecs \:entities])]\\r\\n                                    (if (empty? syss)\\r\\n                                      ents\\r\\n                                      (recur (rest syss) ((first syss) (assoc-in game [\:ecs \:entities] ents)))))))\\r\\n\\r\\n(defn run-once [] \\r\\n  (do\\r\\n    (if (\= 9 (count prev-games)) \\r\\n      (def prev-games (conj (rest prev-games) ms/game))\\r\\n      (def prev-games (conj prev-games ms/game)))\\r\\n    (ms/update-game\! \#(assoc-in %\\r\\n                                [\:ecs \:entities]\\r\\n                                (get-in (run-game % [tick-behavior-tree\\r\\n                                                     create-pending-entity\\r\\n                                                     projectile-weapon-cooldown\\r\\n                                                     animate\\r\\n                                                     rotate\\r\\n                                                     move\\r\\n                                                     death\\r\\n                                                     timed-life])\\r\\n                                        [\:ecs \:entities])))))\\r\\n\\r\\n(defn run-times [n]\\r\\n  (loop [idx n]\\r\\n    (if (zero? idx)\\r\\n      nil\\r\\n      (do\\r\\n        (run-once)\\r\\n        (recur (dec idx))))))\\r\\n\\r\\n(defn revert-entities [idx]\\r\\n  (if (and (< idx 10) (>\= idx 0))\\r\\n    (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (\:entities (\:ecs (nth prev-games idx)))))\\r\\n    \\"idx must be between 0 and 9, inclusive.\\"))" "(run-game ms/game [tick-behavior-tree\\r\\n                   create-pending-entity\\r\\n                   projectile-weapon-cooldown\\r\\n                   animate\\r\\n                   rotate\\r\\n                   move\\r\\n                   death\\r\\n                   timed-life])" "(\:entities (run-game ms/game [tick-behavior-tree\\r\\n                              create-pending-entity\\r\\n                              projectile-weapon-cooldown\\r\\n                              animate\\r\\n                              rotate\\r\\n                              move\\r\\n                              death\\r\\n                              timed-life]))" "(\:entities (\:ecs (run-game ms/game [tick-behavior-tree\\r\\n                              create-pending-entity\\r\\n                              projectile-weapon-cooldown\\r\\n                              animate\\r\\n                              rotate\\r\\n                              move\\r\\n                              death\\r\\n                              timed-life])))" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                              create-pending-entity\\r\\n                              projectile-weapon-cooldown\\r\\n                              animate\\r\\n                              rotate\\r\\n                              move\\r\\n                              death\\r\\n                              timed-life]) [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 0])" "(get-in (run-game ms/game [tick-behavior-tree\\r\\n                              create-pending-entity\\r\\n                              projectile-weapon-cooldown\\r\\n                              animate\\r\\n                              rotate\\r\\n                              move\\r\\n                              death\\r\\n                              timed-life]) [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 0])" "(defn melee-weapon-cooldown [{{ents \:entities} \:ecs delta \:delta}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:melee-weapon %))\\r\\n        tick-cooldown (fn [e]\\r\\n                        (if (pos? (\:curr-cooldown (\:melee-weapon e)))\\r\\n                          (update-in e [\:melee-weapon \:curr-cooldown] (fn [ccd] (math-utils/round-to-decimal (- ccd delta) 3)))\\r\\n                          e))\\r\\n        modified-ents (map tick-cooldown qualifying-ents)]\\r\\n    (into rest-ents modified-ents)))" "(defn init [game]\\r\\n  (-> game\\r\\n    (ecs/add-system render)\\r\\n    (ecs/add-system tick-behavior-tree)\\r\\n    (ecs/add-system create-pending-entity)\\r\\n    (ecs/add-system projectile-weapon-cooldown)\\r\\n    (ecs/add-system melee-weapon-cooldown)\\r\\n    (ecs/add-system animate)\\r\\n    (ecs/add-system rotate)\\r\\n    (ecs/add-system move)\\r\\n    (ecs/add-system death)\\r\\n    (ecs/add-system timed-life)\\r\\n    (ecs/add-system cover)\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.entities)" "(ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))" "(ms/update-game\! \#(ecs/add-entity % (zergling % 0 32)))" "(ms/update-game\! \#(ecs/add-entity % (attacker % 0 192)))" "(do\\n  (basic-combat-ai.desktop-launcher/reset)\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.2)\\r\\n                                                       (comps/frame (\:monster-idle tex-cache) 0.1)] false)))\\r\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "  (basic-combat-ai.desktop-launcher/reset)" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.02)\\r\\n                                                       (comps/frame (\:monster-idle tex-cache) 0.1)] false)))\\r\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "  (basic-combat-ai.desktop-launcher/reset)" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.04)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.04)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.02)\\r\\n                                                       (comps/frame (\:monster-idle tex-cache) 0.1)] false)))\\r\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "  (basic-combat-ai.desktop-launcher/reset)" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "(defn zergling [{tex-cache \:tex-cache} x y]\\r\\n  (-> {}\\r\\n    (comps/melee-weapon \:cooldown 0.5\\r\\n                        \:curr-cooldown 0.0\\r\\n                        \:damage 1)\\r\\n    (comps/renderable (\:monster-idle tex-cache))\\r\\n    (comps/hit-points 4000)\\r\\n    (comps/team \:team2)\\r\\n    (assoc \:transform (comps/transform x y 0 16 16)\\r\\n           \:movespeed (comps/movespeed 2 8)\\r\\n           \:animation (comps/animation\\r\\n                        (comps/frames \:monster-idle (comps/frame (\:monster-idle tex-cache) 0.1) false\\r\\n                                      \:monster-walk [(comps/frame (\:monster-walk00 tex-cache) 0.1)\\r\\n                                                     (comps/frame (\:monster-walk01 tex-cache) 0.1)] true\\r\\n                                      \:monster-attack [(comps/frame (\:monster-attack-00 tex-cache) 0.04)\\r\\n                                                       (comps/frame (\:monster-attack-01 tex-cache) 0.1)\\r\\n                                                       (comps/frame (\:monster-attack-02 tex-cache) 0.02)\\r\\n                                                       (comps/frame (\:monster-idle tex-cache) 0.1)] false)))\\r\\n    (assoc \:behavior-tree (comps/behavior-tree (enemy-ai-tree/zergling-ai)))))" "  (basic-combat-ai.desktop-launcher/reset)" "(do\\n  (ms/update-game\! \#(ecs/add-entity % (defender % 0 0)))\\n  (ms/update-game\! \#(ecs/add-entity % (zergling % 0 192))))" "  (basic-combat-ai.desktop-launcher/reset)"]
eclipse.preferences.version=1
