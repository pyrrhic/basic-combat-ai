cmdhistory=["(get-in ms/g [\:ecs \:entities])" "(get-in ms/game [\:ecs \:entities])" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(refresh n)" "(reset)" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x y1 \:y width1 \:width height1 \:height} r1\\n        {x2 \:x y2 \:y width2 \:width height2 \:height} r2]\\n    x1))" "(rectangle-overlap? {\:x 5})" "(rectangle-overlap? {\:x 5} {})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    x1))" "(rectangle-overlap? {\:x 5} {})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) r2))))" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width1) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) r2))))" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 32 \:y 32 \:width 32 \:height 32})" "(defn rectangle-overlap? [r1 r2]\\n  (let [{x1 \:x, y1 \:y, width1 \:width, height1 \:height} r1\\n        {x2 \:x, y2 \:y, width2 \:width, height2 \:height} r2]\\n    (and \\n      (< x1 (+ x2 width2))\\n      (> (+ x1 width1) x2)\\n      (< y1 (+ y2 height2))\\n      (> (+ y1 height1) y2))))" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 32 \:y 32 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 64 \:y 64 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 0 \:y 0 \:width 32 \:height 32})" "(rectangle-overlap? {\:x 0 \:y 0 \:width 64 \:height 64} \\n                    {\:x 0 \:y 0 \:width 64 \:height 64})" "(require '[basic-combat-ai.main-screen \:as ms])" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))]\\n  (map (fn [e]\\n         (if (is-same-ent? main-ent e)\\n           nil\\n           (if (math-utils/rectangle-overlap? main-e-collider (\:self-collider e))\\n             e\\n             nil)))\\n       ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))]\\n  (map (fn [e]\\n         (if (is-same-ent? main-ent e)\\n           nil\\n           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\n                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\n                            \:width (\:width main-e-collider)\\n                            \:height (\:height main-e-collider)}\\n                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\n                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\n                         \:width (\:width (\:self-collider e))\\n                         \:height (\:height (\:self-collider e))}]\\n             (if (math-utils/rectangle-overlap? main-rect e-rect)\\n               e\\n               nil)))) \\n       ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (remove nil? ents-in-fov-nils)]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vector (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:self-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(count [])" "(use 'clojure.repl)" "(source empty?)" "(source seq)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  main-ent)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])\\n      main-e-collider (\:fov-collider main-ent)\\n      is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n      ents-in-fov-nils (map (fn [e]\\r\\n                         (if (is-same-ent? main-ent e)\\r\\n                           nil\\r\\n                           (let [main-rect {\:x (+ (\:x main-e-collider) (\:x (\:transform main-ent)))\\r\\n                                            \:y (+ (\:y main-e-collider) (\:y (\:transform main-ent)))\\r\\n                                            \:width (\:width main-e-collider)\\r\\n                                            \:height (\:height main-e-collider)}\\r\\n                                 e-rect {\:x (+ (\:x (\:self-collider e)) (\:x (\:transform e)))\\r\\n                                         \:y (+ (\:y (\:self-collider e)) (\:y (\:transform e)))\\r\\n                                         \:width (\:width (\:self-collider e))\\r\\n                                         \:height (\:height (\:self-collider e))}]\\r\\n                             (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                               e\\r\\n                               nil)))) \\r\\n                       ents)\\n      ents-in-fov (vec (remove nil? ents-in-fov-nils))]\\n  ents-in-fov)" "(defn- ents-in-fov [main-ent ents]\\n  (let [main-e-collider (\:fov-collider main-ent)\\n        main-e-transform (\:transform main-ent)\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n        local->world-coord (fn [collider transform]\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\n    (vec (remove nil? ents-in-fov-nils))))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 0]) (get-in ms/game [\:ecs \:entities]))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (vec (remove nil? ents-in-fov-nils))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    local->world-coord))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (local->world-coord main-e-collider main-e-transform) ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils ))" "(use 'clojure.stacktrace)" "(use clojure.stacktrace)" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents-in-fov-nils ))" "(print-stack-trace *e)" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents) ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    ents ))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (local->world-coord (\:self-collider e) e)\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      \\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      e\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (\:self-collider e)\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      e\\n    )))" "(let [ents (get-in ms/game [\:ecs \:entities])\\r\\n      main-ent (get-in ms/game [\:ecs \:entities 0])]  \\r\\n  (let [main-e-collider (\:fov-collider main-ent)\\r\\n        main-e-transform (\:transform main-ent)\\r\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\r\\n        local->world-coord (fn [collider transform]\\r\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\r\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\r\\n                                        e-rect (local->world-coord (\:self-collider e) e)]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\r\\n    (let [e (second ents)]\\n      (local->world-coord (\:self-collider e) e)\\n    )))" "(defn- ents-in-fov [main-ent ents]\\n  (let [main-e-collider (\:fov-collider main-ent)\\n        main-e-transform (\:transform main-ent)\\n        is-same-ent? (fn [e1 e2] (\= (\:id e1) (\:id e2)))\\n        local->world-coord (fn [collider transform]\\n                             {\:x (+ (\:x collider) (\:x transform))\\r\\n                              \:y (+ (\:y collider) (\:y transform))\\r\\n                              \:width (\:width collider)\\r\\n                              \:height (\:height collider)})\\n        ents-in-fov-nils (map (fn [e]\\r\\n                                (if (is-same-ent? main-ent e)\\r\\n                                  nil\\r\\n                                  (let [main-rect (local->world-coord main-e-collider main-e-transform)\\n                                        e-rect (local->world-coord (\:self-collider e) (\:transform e))]\\r\\n                                    (if (math-utils/rectangle-overlap? main-rect e-rect)\\r\\n                                      e\\r\\n                                      nil)))) \\r\\n                              ents)]\\n    (vec (remove nil? ents-in-fov-nils))))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 0]) (get-in ms/game [\:ecs \:entities]))" "(ents-in-fov (get-in ms/game [\:ecs \:entities 1]) (get-in ms/game [\:ecs \:entities]))" "(app)" "\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\"\\n(let [x0 1, y0 1\\n      x1 6, y1 2\\n      dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? curr-n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))))))" "\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\"\\n(let [x0 1, y0 1\\n      x1 6, y1 2\\n      dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))))))" "(defn raytrace [x0 y0 x1 y1]\\n\\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\nReturns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\n(let [dx (Math/abs (- x1 x0))\\n      dy (Math/abs (- y1 y0))\\n      x-inc (if (> x1 x0) 1 -1)\\n      y-inc (if (> y1 y0) 1 -1)]\\n  (loop [x x0\\n         y y0\\n         n (+ 1 dx dy)\\n         err (- dx dy) \\n         result []]\\n    (if (zero? n)\\n      result\\n      (if (pos? err)\\n        (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\n        (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y])))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(require '[basic-combat-ai.tile-map \:as tile-map])" "(reset)" "(raytrace 0 0 6 2)" "(time (raytrace 0 0 6 2))" "(\:tile-map (ms/game))" "(\:tile-map ms/game)" "(nth (\:tile-map ms/game) 0)" "(nth (nth (\:tile-map ms/game) 0) 0)" "(get-in (\:tile-map ms/game) [0 0])" "(assoc-in (\:tile-map ms/game) [0 0 \:texture] nil)" "(let [positions (raytrace 0 0 6 2)\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\n  (ms/update-game\! \#(assoc % \:tile-map (update-tile 0 0))))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(\:tex-cache ms/game)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     wall-texture)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     positions)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     update-tile)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (ms/update-game\! \#(assoc % \:tile-map (update-tile 0 0))))" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      floor-texture (\:floor (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     floor-texture)" "(let [positions (raytrace 0 0 6 2)\\r\\n      wall-texture (\:wall (\:tex-cache ms/game))\\n      floor-texture (\:floor (\:tex-cache ms/game))\\r\\n      update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n  (loop [posis positions]\\n    (if (empty? posis)\\n      nil\\n      (do\\n        (let [tile-pos (nth posis 0)\\n              x (nth tile-pos 0)\\n              y (nth tile-pos 1)]\\n        (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\n        (recur (rest posis)))))))" "(defn raytrace [x0 y0 x1 y1]\\r\\n   \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n   Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n   (let [dx (Math/abs (- x1 x0))\\r\\n         dy (Math/abs (- y1 y0))\\r\\n         x-inc (if (> x1 x0) 1 -1)\\r\\n         y-inc (if (> y1 y0) 1 -1)]\\r\\n     (loop [x x0\\r\\n            y y0\\r\\n            n (+ 1 dx dy)\\r\\n            err (- dx dy) \\r\\n            result []]\\r\\n       (if (zero? n)\\r\\n         result\\r\\n         (cond \\r\\n           (pos? err) (recur (+ x x-inc) y (dec n) (- err dy) (conj result [x y]))\\r\\n           (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx) (conj result [x y]))\\n           \:else (recur (+ x x-inc) (+ y y-inc) (dec n) (+ err dx) (conj result [x y])))))))" "(ns basic-combat-ai.desktop-launcher/reset)" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.math-utils)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 2 6 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     positions)" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              \:else (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y])))))))" "(let [positions (raytrace 0 0 2 6)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              )))))" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (zero? n)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              \:else (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y])))))))" "(let [positions (raytrace 0 5 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (<\= n 0)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (- n 2) (+ err dx2) (conj result [x y]))\\n              )))))" "(let [positions (raytrace 0 5 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(defn raytrace [x0 y0 x1 y1]\\r\\n      \\"http\://playtechs.blogspot.com/2007/03/raytracing-on-grid.html at the bottom, the all integer version.\\r\\n      Returns something like this [[x y] [x y] [x y]]. It's in order, based on the input.\\"\\r\\n      (let [dx (Math/abs (- x1 x0))\\r\\n            dy (Math/abs (- y1 y0))\\r\\n            x-inc (if (> x1 x0) 1 -1)\\r\\n            y-inc (if (> y1 y0) 1 -1)\\n            dx2 (* dx 2)\\n            dy2 (* dy 2)]\\r\\n        (loop [x x0\\r\\n               y y0\\r\\n               n (+ 1 dx dy)\\r\\n               err (- dx dy) \\r\\n               result []]\\r\\n          (if (<\= n 0)\\r\\n            result\\r\\n            (cond \\r\\n              (pos? err) (recur (+ x x-inc) y (dec n) (- err dy2) (conj result [x y]))\\r\\n              (neg? err) (recur x (+ y y-inc) (dec n) (+ err dx2) (conj result [x y]))\\n              \:else (recur (+ x x-inc) (+ y y-inc) (- n 2) (- (+ err dx2) dy2) (conj result [x y]))\\n              )))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 6 2 0 0)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(let [positions (raytrace 0 0 6 2)\\r\\n         wall-texture (\:wall (\:tex-cache ms/game))\\r\\n         floor-texture (\:floor (\:tex-cache ms/game))\\r\\n         update-tile (fn [x y] (assoc-in (\:tile-map ms/game) [x y \:texture] wall-texture))]\\r\\n     (loop [posis positions]\\r\\n       (if (empty? posis)\\r\\n         nil\\r\\n         (do\\r\\n           (let [tile-pos (nth posis 0)\\r\\n                 x (nth tile-pos 0)\\r\\n                 y (nth tile-pos 1)]\\r\\n           (ms/update-game\! \#(assoc % \:tile-map (update-tile x y)))\\r\\n           (recur (rest posis)))))))" "(basic-combat-ai.desktop-launcher/reset)" "(app)" "(use 'clojure.repl)" "(source vals)" "(defprotocol NodeBehavior\\r\\n  \\"Node for a behavior tree. duh. The main-ent will also be in the game object, and will need to be updated in both spots. \\r\\n   It's just there so we don't have to keep retrieving it from the list of entities since most nodes will act on the main-ent.\\"\\r\\n  ;(start [node main-ent game] \\"Node will perform any sort of initializing behavior before it runs.\\")\\r\\n  (run [node main-ent-id ents tile-map] \\"Main node logic. Expected to set the node's status to success or failure.\\")\\r\\n  (reset [node] \\"reset to fresh state. do any clean up necessary.\\"))" "(defrecord Selector [status children curr-child-idx]\\n  NodeBehavior\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\n  (run [node main-ent-id ents tile-map]\\n    (loop [new-child-idx (inc (\:curr-child-idx node))]\\n      (if (\= new-child-idx (count (\:children node)))\\n        {\:node (assoc node \:status \:success)\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\n        (let [updated-child-data (run (nth (\:children node) new-child-idx))\\n              updated-child-status (\:status updated-child-data)]\\n          (if-not (\= \:success updated-child-status)\\n            {\:node (assoc node \\n                          \:status updated-child-status\\n                          \:children (assoc (\:children node) \\n                                           new-child-idx \\n                                           (\:node updated-child-data)))\\n             \:entities (\:entities updated-child-data)\\n             \:tile-map (\:tile-map updated-child-data)}\\n            (recur new-child-idx)))))))" "(defprotocol NodeBehavior\\r\\n  \\"Node for a behavior tree. duh. The main-ent will also be in the game object, and will need to be updated in both spots. \\r\\n   It's just there so we don't have to keep retrieving it from the list of entities since most nodes will act on the main-ent.\\"\\r\\n  ;(start [node main-ent game] \\"Node will perform any sort of initializing behavior before it runs.\\")\\r\\n  (reset [node] \\"reset to fresh state. do any clean up necessary.\\")\\r\\n  (run [node main-ent-id ents tile-map] \\"Main node logic. Expected to set the node's status to success or failure.\\"))" "(defrecord Selector [status children curr-child-idx]\\n  NodeBehavior\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\n  (run [node main-ent-id ents tile-map]\\n    (loop [new-child-idx (inc (\:curr-child-idx node))]\\n      (if (\= new-child-idx (count (\:children node)))\\n        {\:node (assoc node \:status \:success)\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\n        (let [updated-child-data (run (nth (\:children node) new-child-idx))\\n              updated-child-status (\:status updated-child-data)]\\n          (if-not (\= \:success updated-child-status)\\n            {\:node (assoc node \\n                          \:status updated-child-status\\n                          \:children (assoc (\:children node) \\n                                           new-child-idx \\n                                           (\:node updated-child-data)))\\n             \:entities (\:entities updated-child-data)\\n             \:tile-map (\:tile-map updated-child-data)}\\n            (recur new-child-idx)))))))" "(defprotocol NodeBehavior\\r\\n  \\"Node for a behavior tree. duh. The main-ent will also be in the game object, and will need to be updated in both spots. \\r\\n   It's just there so we don't have to keep retrieving it from the list of entities since most nodes will act on the main-ent.\\"\\r\\n  ;(start [node main-ent game] \\"Node will perform any sort of initializing behavior before it runs.\\")\\r\\n  (reset [node] \\"reset to fresh state. do any clean up necessary.\\")\\r\\n  (run [node main-ent-id ents tile-map] \\"Main node logic. Expected to set the node's status to success or failure.\\"))" "(defrecord Selector [status children curr-child-idx]\\n  NodeBehavior\\n  (reset [node])\\n  (run [node main-ent-id ents tile-map]))" "(defrecord Selector [status children curr-child-idx]\\n  NodeBehavior\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\n  (run [node main-ent-id ents tile-map]\\n    (loop [new-child-idx (inc (\:curr-child-idx node))]\\n      (if (\= new-child-idx (count (\:children node)))\\n        {\:node (assoc node \:status \:success)\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\n        (let [updated-child-data (run (nth (\:children node) new-child-idx))\\n              updated-child-status (\:status updated-child-data)]\\n          (if-not (\= \:success updated-child-status)\\n            {\:node (assoc node \\n                          \:status updated-child-status\\n                          \:children (assoc (\:children node) \\n                                           new-child-idx \\n                                           (\:node updated-child-data)))\\n             \:entities (\:entities updated-child-data)\\n             \:tile-map (\:tile-map updated-child-data)}\\n            (recur new-child-idx)))))))" "(defrecord Selector [status children curr-child-idx]\\n  NodeBehavior\\n  (reset [node]\\r\\n    )\\n  (run [node main-ent-id ents tile-map]\\n    (loop [new-child-idx (inc (\:curr-child-idx node))]\\n      (if (\= new-child-idx (count (\:children node)))\\n        {\:node (assoc node \:status \:success)\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\n        (let [updated-child-data (run (nth (\:children node) new-child-idx))\\n              updated-child-status (\:status updated-child-data)]\\n          (if-not (\= \:success updated-child-status)\\n            {\:node (assoc node \\n                          \:status updated-child-status\\n                          \:children (assoc (\:children node) \\n                                           new-child-idx \\n                                           (\:node updated-child-data)))\\n             \:entities (\:entities updated-child-data)\\n             \:tile-map (\:tile-map updated-child-data)}\\n            (recur new-child-idx)))))))" "(defn update-node [node]\\n  (run node))" "(defn update-node [node main-ent-id ents tile-map]\\n  (run node main-ent-id ents tile-map))" "(ns-unmap *ns* 'update-node)" "(defrecord Selector [status children curr-child-idx]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\r\\n  (run [node main-ent-id ents tile-map]\\r\\n    (let [new-child-idx (inc (\:curr-child-idx node))]\\r\\n      (if (\= new-child-idx (count (\:children node)))\\r\\n        {\:node (assoc node \:status \:success)\\r\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\r\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\r\\n        (let [updated-child-data (run (nth (\:children node) new-child-idx) main-ent-id ents tile-map)\\r\\n              updated-child-status (\:status updated-child-data)\\n        return-data {\:node (assoc node \\r\\n                          \:status updated-child-status\\r\\n                          \:children (assoc (\:children node) \\r\\n                                           new-child-idx \\r\\n                                           (\:node updated-child-data)))\\r\\n                           \:entities (\:entities updated-child-data)\\r\\n                           \:tile-map (\:tile-map updated-child-data)}]\\r\\n          (if-not (\= \:success updated-child-status)\\r\\n            return-data\\r\\n            (run (\:node return-data) main-ent-id (\:entities return-data) (\:tile-map return-data))))))))" "(defrecord Selector [status children curr-child-idx]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (let [current-child-idx (\:curr-child-idx node)]\\r\\n      (if (\= current-child-idx (count (\:children node)))\\r\\n        {\:node (assoc node \:status \:success)\\r\\n         \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\r\\n         \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))}\\r\\n        (let [updated-child-data (run (nth (\:children node) current-child-idx) main-ent-id entities tile-map)\\r\\n              updated-child-status (\:status updated-child-data)]\\r\\n          ;selector only calls the next child when the child was a success. so increment the child counter.\\r\\n          ;anything else, and we don't want to run the next child.\\r\\n          (if (\= \:success updated-child-status)\\r\\n            (run \\r\\n              (assoc node \\r\\n                     \:children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n                     \:curr-child-idx (inc current-child-idx))\\r\\n              main-ent-id\\r\\n              (\:entities updated-child-data)\\r\\n              (\:tile-map updated-child-data))\\r\\n            {\:node (assoc node \\r\\n                          ;if child failed, selector fails. if child is running, selector is running.\\r\\n                          \:status updated-child-status\\r\\n                          \:children (assoc (\:children node) current-child-idx (\:node updated-child-data)))\\r\\n             \:entities (\:entities updated-child-data)\\r\\n             \:tile-map (\:tile-map updated-child-data)}))))))" "(defn return-data-for-success [node]\\r\\n  {\:node (assoc node \:status \:success)\\r\\n   \:entities (\:entities (nth (\:children node) (\:curr-child-idx node)))\\r\\n   \:tile-map (\:tile-map (nth (\:children node) (\:curr-child-idx node)))})" "(defrecord Selector [status children curr-child-idx]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx -1))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (let [current-child-idx (\:curr-child-idx node)]\\r\\n      (if (\= current-child-idx (count (\:children node)))\\r\\n        (return-data-for-success node)\\r\\n        (let [updated-child-data (run (nth (\:children node) current-child-idx) main-ent-id entities tile-map)\\r\\n              updated-child-status (\:status updated-child-data)]\\r\\n          ;selector only calls the next child when the child was a success. so increment the child counter.\\r\\n          ;anything else, and we don't want to run the next child.\\r\\n          (if (\= \:success updated-child-status)\\r\\n            (run \\r\\n              (assoc node \\r\\n                     \:children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n                     \:curr-child-idx (inc current-child-idx))\\r\\n              main-ent-id\\r\\n              (\:entities updated-child-data)\\r\\n              (\:tile-map updated-child-data))\\r\\n            {\:node (assoc node \\r\\n                          ;if child failed, selector fails. if child is running, selector is running.\\r\\n                          \:status updated-child-status\\r\\n                          \:children (assoc (\:children node) current-child-idx (\:node updated-child-data)))\\r\\n             \:entities (\:entities updated-child-data)\\r\\n             \:tile-map (\:tile-map updated-child-data)}))))))" "(defrecord TestLeaf [status]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    nil)\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    {\:node node \\r\\n     \:entities entities\\r\\n     \:tile-map tile-map}))" "(defrecord Selector [status children curr-child-idx]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" "(defn tick [node main-ent-id ents tile-map]\\r\\n  (case (\:status node)\\r\\n    \:fresh (run (assoc node \:status \:running)\\r\\n                main-ent-id\\r\\n                ents\\r\\n                tile-map)\\r\\n    \:running (run node\\r\\n                  main-ent-id\\r\\n                  ents\\r\\n                  tile-map)\\r\\n    \:else {\:node node\\r\\n           \:entities ents\\r\\n           \:tile-map tile-map}))" "(defrecord Selector [status children curr-child-idx]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" "(->Selector \:fresh 0 [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" "(->Selector \:fresh 0 [])" "(defrecord TestLeaf [status work-counter]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    nil)\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n    (if (\= (\:work-counter node) 1)\\r\\n      {\:node (assoc node \:status \:success) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map}\\r\\n      {\:node (assoc node \:work-counter (inc (\:work-counter node))) \\r\\n       \:entities entities\\r\\n       \:tile-map tile-map})))" "(->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                      (->TestLeaf \:fresh 1)\\n                      (->TestLeaf \:fresh 0)])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:fresh 0)])\\n      0\\n      []\\n      [])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n;\\t    (if child-successful-and-not-last?\\r\\n;\\t      (tick-updated-selector)\\r\\n;\\t      selector-with-last-updated-child)\\r\\n     child-successful-and-not-last?\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n;\\t    (if child-successful-and-not-last?\\r\\n;\\t      (tick-updated-selector)\\r\\n;\\t      selector-with-last-updated-child)\\r\\n     selector-with-last-updated-child\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status updated-child-data)\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n;\\t    (if child-successful-and-not-last?\\r\\n;\\t      (tick-updated-selector)\\r\\n;\\t      selector-with-last-updated-child)\\r\\n     updated-child-data\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n;\\t    (if child-successful-and-not-last?\\r\\n;\\t      (tick-updated-selector)\\r\\n;\\t      selector-with-last-updated-child)\\r\\n     updated-child-data\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n;\\t    (if child-successful-and-not-last?\\r\\n;\\t      (tick-updated-selector)\\r\\n;\\t      selector-with-last-updated-child)\\r\\n     selector-with-last-updated-child\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)])\\n      0\\n      []\\n      [])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 0)])\\n      0\\n      []\\n      [])" "(tick (tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 0)])\\n            0\\n            []\\n            []))" "(tick (tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 0)])\\n            0\\n            []\\n            [])\\n      0 \\n      []\\n      [])" "(tick (\:node (tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 0)])\\n                   0\\n                   []\\n                   []))\\n      0 \\n      []\\n      [])" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child)\\r\\n     )))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:fresh 0)])\\n      0\\n      []\\n      [])" "(tick (\:node (tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                                         (->TestLeaf \:fresh 1)\\n                                         (->TestLeaf \:fresh 0)])\\n                   0\\n                   []\\n                   []))\\n      0 [] [])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:failure 1)\\n                            (->TestLeaf \:fresh 0)])\\n      0\\n      []\\n      [])" "(defn tick [node main-ent-id ents tile-map]\\r\\n  (cond\\r\\n    (\= \:fresh (\:status node)) (run (assoc node \:status \:running)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t               main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t               ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t               tile-map)\\r\\n    (\= \:running (\:status node)) (run node\\r\\n                                     main-ent-id\\r\\n                                     ents\\r\\n                                     tile-map)\\r\\n    \:else {\:node node\\r\\n           \:entities ents\\r\\n           \:tile-map tile-map}))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\n                            (->TestLeaf \:failure 1)\\n                            (->TestLeaf \:fresh 0)])\\n      0\\n      []\\n      [])" "(app)" "(defrecord HasMoveTo [status]\\n  bt/NodeBehavior\\n  (bt/reset [node]\\n    (assoc node \:status \:fresh))\\n  (bt/run [node main-ent-id entities tile-map]\\n    (let [main-ent (main-ent-id entities)]\\n      (if (\:move-to main-ent) \\n        {\:node (assoc node \:status \:success)\\n         \:entities entities\\n         \:tile-map tile-map}\\n        {\:node (assoc node \:status \:failure)\\r\\n         \:entities entities\\r\\n         \:tile-map tile-map}))))" "(defn make-return-map (node entities tile-map)\\r\\n  {\:node node\\r\\n   \:entities entities\\r\\n   \:tile-map tile-map})" "(defn make-return-map [node entities tile-map]\\r\\n  {\:node node\\r\\n   \:entities entities\\r\\n   \:tile-map tile-map})" "(defrecord HasMoveTo [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities tile-map]\\r\\n       (let [main-ent (main-ent-id entities)]\\r\\n         (if (\:move-to main-ent)\\n           (bt/make-return-map (assoc node \:status \:success) entities tile-map)\\r\\n           (bt/make-return-map (assoc node \:status \:failure) entities tile-map)))))" "(defrecord FindPath [status]\\n  bt/NodeBehavior\\n  (bt/reset [node]\\r\\n    (assoc node \:status \:fresh))\\n  (bt/run [node main-ent-id entities curr-tile-map]\\n    (let [main-ent (main-ent-id entities)\\n          start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\n                                        (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\n                                        curr-tile-map)]\\n          start-tile)))" "(FindPath. \:fresh)" "(run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}}, \:1 {\:id 1}} (tile-map/create-grid 3 3 nil))" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}}, \:1 {\:id 1}} (tile-map/create-grid 3 3 nil))" "(require '[basic-combat-ai.main-screen \:as ms])" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}}, \:1 {\:id 1}} (\:tile-map ms/game))" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game))" "(defrecord FindPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                           (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                           curr-tile-map)\\n             target-tile (tile-map/get-tile (\:x (\:move-to)) (\:y (\:move-to)) curr-tile-map)\\n             path (astar/calc-path start-tile target-tile curr-tile-map)]\\n         path)))" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game))" "(defrecord FindPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                           (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                           curr-tile-map)\\n             target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\n             path (astar/calc-path start-tile target-tile curr-tile-map)]\\n         path)))" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game))" "(defrecord FindPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                           (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                           curr-tile-map)\\n             target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\n             path (astar/calc-path start-tile target-tile curr-tile-map)]\\n         (if (seq? path)\\n           (assoc main-ent \:path (comps/path path))\\n           nil))))" "(source comps/path)" "(use 'clojure.repl)" "(source comps/path)" "(defrecord FindPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                           (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                           curr-tile-map)\\n             target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\n             path (astar/calc-path start-tile target-tile curr-tile-map)]\\n         (if (seq? path)\\n           (bt/make-return-map (assoc node \:status \:success)\\n                               (assoc entities main-ent-id (assoc main-ent \:path (comps/path path)))\\n                               curr-tile-map)\\n           (bt/make-return-map (assoc node \:status \:failure) main-ent curr-tile-map)))))" "(bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game))" "(dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map)" "(defrecord FollowPath [status]\\n  bt/NodeBehavior\\n  (bt/reset (assoc node \:status \:fresh))\\n  (bt/run [node main-ent-id entities curr-tile-map]\\n    (let [main-ent (main-ent-id entities)\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)\\r\\n          update-entity \#(-> % \\r\\n                           (assoc-in [\:transform \:x] (tile-map/grid->world-coord (\:grid-x target-node)))\\r\\n                           (assoc-in [\:transform \:y] (tile-map/grid->world-coord (\:grid-y target-node)))\\r\\n                           (assoc-in [\:path \:curr-path-idx] (inc curr-path-idx)))]\\r\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (bt/make-return-map (assoc node \:status \:running) (assoc entities main-ent-id (update-entity main-ent)) curr-tile-map)))))" "(defrecord FollowPath [status]\\n  bt/NodeBehavior\\n  (bt/reset [node] \\n    (assoc node \:status \:fresh))\\n  (bt/run [node main-ent-id entities curr-tile-map]\\n    (let [main-ent (main-ent-id entities)\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)\\r\\n          update-entity \#(-> % \\r\\n                           (assoc-in [\:transform \:x] (tile-map/grid->world-coord (\:grid-x target-node)))\\r\\n                           (assoc-in [\:transform \:y] (tile-map/grid->world-coord (\:grid-y target-node)))\\r\\n                           (assoc-in [\:path \:curr-path-idx] (inc curr-path-idx)))]\\r\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (bt/make-return-map (assoc node \:status \:running) (assoc entities main-ent-id (update-entity main-ent)) curr-tile-map)))))" "(dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map)" "(\:path (dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map))" "(\:0 (\:entities (dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map)))" "(let [ents (\:entities (dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map))]\\n  (bt/run (->FollowPath \:fresh) \:0 ents (\:tile-map ms/game)))" "(let [ents (\:entities (dissoc (bt/run (FindPath. \:fresh) \:0 {\:0 {\:id 0, \:move-to {\:x 1, \:y 1}, \:transform {\:x 96, \:y 96}}, \:1 {\:id 1}} (\:tile-map ms/game)) \:tile-map))]\\n  (dissoc (bt/run (->FollowPath \:fresh) \:0 ents (\:tile-map ms/game)) \:tile-map))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs \:as game}]\\r\\n  \\"ticks the behavior tree once.\\"\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(\:behavior-tree %))\\n        \\n        ]\\n    (loop [q-ents qualifying-ents\\r\\n           all-ents ents]\\r\\n      (if (empty? q-ents)\\r\\n        all-ents" "(source into)" "(use 'clojure.repl)" "(source into)" "(conj {} 1)" "(conj [] 1)" "(conj {} [1])" "(conj {} [1 2])" "(conj {} [\:1 2])" "(conj {} [\:1 2 \:3 4])" "(source conj)" "(for [a [1 2 3] b [4 5 6]] (+ a b))" "(for [a [1 1 1] b [4 5 6]] (+ a b))" "(for [a [1 1 1] b \#(+ % 1)] (+ a b))" "(for [a [1 1 1] \:let [m {\:a \\"hi\\"}] ] m)" "(for [a [1 1 1] \:let [m {a \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {a \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {(symbol a) \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {(keyword a) \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {\:a \\"hi\\"}] ] m)" "(keyword 1)" "(keyword '1)" "(keyword 'a)" "(\:0 {\:0 \\"hi\\"})" "(keyword \\"1\\")" "(for [a [1 2 3] \:let [m {(String. a) \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {(str a) \\"hi\\"}] ] m)" "(vec (for [a [1 2 3] \:let [m {(keyword (String. a)) \\"hi\\"}] ] m))" "(for [a [1 2 3] \:let [m {(keyword (String. a)) \\"hi\\"}] ] m)" "(for [a [1 2 3] \:let [m {(keyword (str a)) \\"hi\\"}] ] m)" "(for [a (range 10) \:let [m {(keyword (str a)) \\"hi\\"}] ] m)" "(defn make-fake-ents (for [a (range 10) \:let [m {(keyword (str a)) \\"hi\\"}] ] m))" "(defn make-fake-ents [] (for [a (range 10) \:let [m {(keyword (str a)) \\"hi\\"}] ] m))" "(defn make-fake-ents [n] (for [a (range n) \:let [m {(keyword (str a)) \\"hi\\"}] ] m))" "(defn make-fake-ents [] (for [a (range 10) \:let [m {\:id a}] ] m))" "(make-fake-ents 10)" "(defn make-fake-ents [n] (for [a (range n) \:let [m {\:id a}] ] m))" "(make-fake-ents 10)" "(loop [ents (make-fake-ents 10)\\n       ents-map {}]\\n  (if (empty? ents)\\n    ents-map\\n    (recur (rest ents) (assoc ents-map (\:id (first ents)) (first ents)))))" "(loop [ents (make-fake-ents 10)\\n       ents-map {}]\\n  (if (empty? ents)\\n    ents-map\\n    (recur (rest ents) (assoc ents-map (keyword (\:id (first ents))) (first ents)))))" "(loop [ents (make-fake-ents 10)\\n       ents-map {}]\\n  (if (empty? ents)\\n    ents-map\\n    (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents)))))" "(time (loop [ents (make-fake-ents 2000)\\n             ents-map {}]\\n        (if (empty? ents)\\n          ents-map\\n          (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents))))))" "(time (loop [ents (make-fake-ents 2000)\\n             ents-map {}]\\n        (if (empty? ents)\\n          nil\\n          (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents))))))" "(time (loop [ents (make-fake-ents 2000)\\n             ents-map {}]\\n        (if (empty? ents)\\n          nil\\n          (recur (rest ents) (assoc ents-map (\:id (first ents)) (first ents))))))" "(repeatedly 10 (time (loop [ents (make-fake-ents 2000)\\n                            ents-map {}]\\n                       (if (empty? ents)\\n                         nil\\n                         (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents)))))))" "(repeatedly 10 \#(time (loop [ents (make-fake-ents 2000)\\n                            ents-map {}]\\n                       (if (empty? ents)\\n                         nil\\n                         (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents)))))))" "(keys (make-fake-ents 2000))" "(vals (make-fake-ents 2000))" "(repeatedly 10 \#(time (loop [ents (make-fake-ents 2000)\\n                            ents-map {}]\\n                       (if (empty? ents)\\n                         nil\\n                         (recur (rest ents) (assoc ents-map (keyword (str (\:id (first ents)))) (first ents)))))))" "(repeatedly 10 \#(time (loop [ents (make-fake-ents 2000)\\n                            ents-map {}]\\n                       (if (empty? ents)\\n                         nil\\n                         (let [e (first ents)]\\n                           (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e)))))))" "(repeatedly 10 \#(time (loop [ents (make-fake-ents 10000)\\n                            ents-map {}]\\n                       (if (empty? ents)\\n                         nil\\n                         (let [e (first ents)]\\n                           (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e)))))))" "(repeatedly 10 \#(let [es (make-fake-ents 10000)]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (make-fake-ents 2000)]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (vec (make-fake-ents 2000))]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (list (make-fake-ents 2000))]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (asso ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (list (make-fake-ents 2000))]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (list (make-fake-ents 10000))]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(repeatedly 10 \#(let [es (list (make-fake-ents 1000000000))]\\n                  (time (loop [ents es\\n                              ents-map {}]\\n                         (if (empty? ents)\\n                           nil\\n                           (let [e (first ents)]\\n                             (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))))" "(defn ent-vec->map [entities]\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      nil\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(ent-vec->map (make-fake-ents 10))" "(defn ent-vec->map [entities]\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(ent-vec->map (make-fake-ents 10))" "(defn ent-vec->map [entities]\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(ent-vec->map (make-fake-ents 10))" "(app)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-m ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (\:id (first q-ents))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-map tick-data)))))))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-m ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (\:id (first q-ents))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities])" "(get-in ms/game [\:ecs \:entities 0])" "(require '[basic-combat-ai.enemy-ai \:as enemy-ai])" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:behavior-tree (bt/->Selector \:fresh 0 [(enemy-ai/->HasMoveTo \:fresh)\\n                                                                                               (enemy-ai/->FindPath \:fresh)\\n                                                                                               (enemy-ai/->FollowPath)]))))" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:behavior-tree (bt/->Selector \:fresh 0 [(enemy-ai/->HasMoveTo \:fresh)\\n                                                                                               (enemy-ai/->FindPath \:fresh)\\n                                                                                               (enemy-ai/->FollowPath \:fresh)]))))" "(ms/update-game\! (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:behavior-tree (bt/->Selector \:fresh 0 [(enemy-ai/->HasMoveTo \:fresh)\\n                                                                                                                (enemy-ai/->FindPath \:fresh)\\n                                                                                                                (enemy-ai/->FollowPath \:fresh)])))))" "(ms/update-game\! (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1)))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-map ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (\:id (first q-ents))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    ents-map))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    qualifying-ents))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    ents))" "(tick-behavior-tree ms/game)" "ms/game" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-map ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (\:id (first q-ents))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))" "(ms/game)" "ms/game" "(basic-combat-ai.desktop-launcher/reset)" "ms/game" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))" "ms/game" "(ms/update-game\! (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1)))))" "ms/game" "(basic-combat-ai.desktop-launcher/reset)" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))" "(keys (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1)))))" "(keys (\:ecs (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))))" "(keys (\:entities (\:ecs (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1)))))))" "(\:entities (\:ecs (update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))))" "(update-in ms/game [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1))))" "ms/game" "(use 'clojure.repl)" "(source ms/update-game\!)" "(ms/update-game\! \#(update-in % [\:ecs \:entities 0] (fn [e] (assoc e \:move-to (comps/move-to 1 1)))))" "ms/game" "(ms/update-game\! \#(update-in % [\:ecs \:entities 0] (fn [e] (assoc e \:behavior-tree (bt/->Selector \:fresh 0 [(enemy-ai/->HasMoveTo \:fresh)\\n                                                                                                          (enemy-ai/->FindPath \:fresh)\\n                                                                                                          (enemy-ai/->FollowPath \:fresh)])))))" "ms/game" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-map ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-map ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-m ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(\:behavior-tree (get-in ms/game [\:ecs \:entities 0]))" "(get-in ms/game [\:ecs \:entities 0])" "(bt/tick (\:behavior-tree (get-in ms/game [\:ecs \:entities 0])) \:5 (ent-vec->map (get-in ms/game [\:ecs \:entities])) (\:tile-map ms/game))" "(dissoc (bt/tick (\:behavior-tree (get-in ms/game [\:ecs \:entities 0])) \:5 (ent-vec->map (get-in ms/game [\:ecs \:entities])) (\:tile-map ms/game)) \:tile-map)" "(->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\r\\n                      (->TestLeaf \:fresh 1)\\r\\n                      (->TestLeaf \:fresh 0)])" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 0)])\\r\\n      \:5" "(defn- ent-vec->map [entities]\\r\\n  (loop [ents entities\\r\\n         ents-map {}]\\r\\n    (if (empty? ents)\\r\\n      ents-map\\r\\n      (let [e (first ents)]\\r\\n        (recur (rest ents) (assoc ents-map (keyword (str (\:id e))) e))))))" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 0)])\\r\\n      \:5\\n      (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      nil)" "(basic-combat-ai.desktop-launcher/reset)" "(defn pistoleer [{tex-cache \:tex-cache} x y]\\r\\n  (assoc {}\\r\\n         \:transform (comps/transform x y 0 16 16)\\r\\n         \:movespeed (comps/movespeed 1 3)\\r\\n         \:renderable (\:pistol-idle tex-cache)\\r\\n         \:animation (comps/animation\\r\\n                    (comps/frames \:pistol-idle (comps/frame (\:pistol-idle tex-cache) 0.1) false\\r\\n                                  \:fire-pistol [(comps/frame (\:fire-pistol01 tex-cache) 0.05)\\r\\n                                                (comps/frame (\:fire-pistol02 tex-cache) 0.05)\\r\\n                                                (comps/frame (\:pistol-idle tex-cache) 0.1)] false))\\r\\n         \:behavior-tree (comps/behavior-tree (bt/->Selector \:fresh 0 [(enemy-ai/->HasMoveTo \:fresh)\\r\\n                                                                      (enemy-ai/->FindPath \:fresh)\\r\\n                                                                      (enemy-ai/->FollowPath \:fresh)]))\\r\\n         \:move-to (comps/move-to 1 1)\\r\\n         ;this is a box, so that means yes, they have eyes on the back of their heads.\\r\\n         ;doing this for simpilicity, and i'm not sure that having a cone fov is worth the extra work anyways.\\r\\n         ;it's not like these guys can be controlled individually, using super advanced tactics or something.\\r\\n         \:fov-collider (comps/fov-collider -240 -240 480 480) ;7 tiles worth of view, each way\\r\\n         \:self-collider (comps/self-collider 0 0 32 32)\\r\\n         ))" "(defn init [game]\\r\\n  (-> game\\r\\n    ;(ecs/add-entity (pistoleer game 0 0))\\r\\n    (ecs/add-entity (pistoleer game 64 96))\\r\\n    ))" "(basic-combat-ai.desktop-launcher/reset)" "(defrecord Selector [status curr-child-idx children]\\r\\n  NodeBehavior\\r\\n  (reset [node]\\r\\n    (assoc node \\r\\n           \:status \:fresh\\r\\n           \:return-ents []\\r\\n           \:curr-child-idx 0))\\r\\n  (run [node main-ent-id entities tile-map]\\r\\n\\t  (let [current-child-idx (\:curr-child-idx node)\\r\\n         ;update current child\\r\\n\\t        updated-child-data (tick (nth (\:children node) current-child-idx) \\r\\n\\t                                 main-ent-id \\r\\n\\t                                 entities \\r\\n\\t                                 tile-map)\\r\\n\\t        updated-child-status (\:status (\:node updated-child-data))\\r\\n\\t        updated-children (assoc (\:children node) current-child-idx (\:node updated-child-data))\\r\\n\\t        updated-child-ents (\:entities updated-child-data)\\r\\n\\t        updated-child-map (\:tile-map updated-child-data)\\r\\n\\t        child-successful-and-not-last? (and (\= \:success updated-child-status) (not\= current-child-idx (dec (count (\:children node)))))\\r\\n\\t        selector-with-updated-children (assoc node \:children updated-children)\\r\\n          tick-updated-selector (fn [] (tick (assoc selector-with-updated-children \:curr-child-idx (inc current-child-idx))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            main-ent-id\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t            updated-child-map))\\r\\n          selector-with-last-updated-child {\:node (assoc selector-with-updated-children \:status updated-child-status)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:entities updated-child-ents\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t        \:tile-map updated-child-map}]\\r\\n\\t    (if child-successful-and-not-last?\\r\\n\\t      (tick-updated-selector)\\r\\n\\t      selector-with-last-updated-child))))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in game [\:ecs \:entities 0])" "(tick (->Selector \:fresh 0 [(->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 1)\\r\\n                            (->TestLeaf \:fresh 0)])\\r\\n      \:5\\n      (ent-vec->map (get-in ms/game [\:ecs \:entities]))\\n      nil)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-m ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        qualifying-ents ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        ent-id))))" "(let [ents (get-in game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        ent-id))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        ent-id))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        ent-id))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        tick-data))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        (dissoc tick-data \:tile-map)))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:behavior-tree (ent-id ents-m)) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc (ent-id updated-ents-m) \:behavior-tree (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        (\:node tick-data)))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        (\:node tick-data)))))" "(let [ents (get-in ms/game [\:ecs \:entities])\\n      tile-map (\:tile-map ms/game)\\n      qualifying-ents (filter \#(\:behavior-tree %) ents)\\n      ents-map (ent-vec->map ents)]\\n  (let [q-ents qualifying-ents ;only use this for the id's. \\n        ents-m ents-map\\n        t-map tile-map]\\n    (if (empty? q-ents)\\n      ents-m ; need to convert this to a vector\\n      ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n      (let [ent-id (keyword (str (\:id (first q-ents))))\\n            ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n            tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n            updated-ents-m (\:entities tick-data)\\n            updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n        ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n        updated-ent-with-ticked-node))))" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        qualifying-ents ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        ents-m ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(doc do)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        (vals ents-m) ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(doc do)" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        (vec (vals ents-m)) ; need to convert this to a vector\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(tick-behavior-tree ms/game)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\n  (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\n        ents-map (ent-vec->map ents)]\\n    (loop [q-ents qualifying-ents ;only use this for the id's. \\n           ents-m ents-map\\n           t-map tile-map]\\n      (if (empty? q-ents)\\n        (vec (vals ents-m))\\n        ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\n        (let [ent-id (keyword (str (\:id (first q-ents))))\\n              ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n              tick-data (bt/tick (\:tree (\:behavior-tree (ent-id ents-m))) ent-id ents-m t-map)\\n              updated-ents-m (\:entities tick-data)\\n              updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\n          ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\n          (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(app)" "(ns basic-combat-ai.systems)" "(ecs/add-system tick-behavior-tree)" "(require '[basic-combat-ai.main-screen \:as ms])" "(ecs/add-system ms/game tick-behavior-tree)" "(get-in (ecs/add-system ms/game tick-behavior-tree) [\:ecs \:systems])" "(ms/update-game\! \#(ecs/add-system % tick-behavior-tree))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)\\r\\n          update-entity \#(-> % \\r\\n                           (assoc-in [\:transform \:x] (tile-map/grid->world-coord (\:grid-x target-node)))\\r\\n                           (assoc-in [\:transform \:y] (tile-map/grid->world-coord (\:grid-y target-node)))\\r\\n                           (assoc-in [\:path \:curr-path-idx] (inc curr-path-idx)))]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (bt/make-return-map (assoc node \:status \:running) (assoc entities main-ent-id (update-entity main-ent)) curr-tile-map)))))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth cur-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)))\\n          nil)))))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)))\\n          nil)))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(run (-> FollowPath \:fresh) \\r\\n     \:1 \\r\\n     {\:1 {\:id 1 \\r\\n          \:transform {\:x 32 \:y 32}\\r\\n          \:path {\:a-path [{\:grid-x 1\\r\\n                           \:grid-y 1}] \\r\\n                 \:curr-path-idx 0}}}\\n     (\:tile-map ms/game))" "(bt/run (-> FollowPath \:fresh) \\r\\n        \:1 \\r\\n        {\:1 {\:id 1 \\r\\n             \:transform {\:x 32 \:y 32}\\r\\n             \:path {\:a-path [{\:grid-x 1\\r\\n                              \:grid-y 1}] \\r\\n                    \:curr-path-idx 0}}}\\n        (\:tile-map ms/game))" "(bt/run (->FollowPath \:fresh) \\r\\n        \:1 \\r\\n        {\:1 {\:id 1 \\r\\n             \:transform {\:x 32 \:y 32}\\r\\n             \:path {\:a-path [{\:grid-x 1\\r\\n                              \:grid-y 1}] \\r\\n                    \:curr-path-idx 0}}}\\n        (\:tile-map ms/game))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          nil)))))" "(bt/run (->FollowPath \:fresh) \\r\\n        \:1 \\r\\n        {\:1 {\:id 1 \\r\\n             \:transform {\:x 32 \:y 32}\\r\\n             \:path {\:a-path [{\:grid-x 1\\r\\n                              \:grid-y 1}] \\r\\n                    \:curr-path-idx 0}}}\\n        (\:tile-map ms/game))" "(dissoc (bt/run (->FollowPath \:fresh) \\r\\n        \:1 \\r\\n        {\:1 {\:id 1 \\r\\n             \:transform {\:x 32 \:y 32}\\r\\n             \:path {\:a-path [{\:grid-x 1\\r\\n                              \:grid-y 1}] \\r\\n                    \:curr-path-idx 0}}}\\n                (\:tile-map ms/game))\\n        \:tile-map)" "(dissoc (bt/run (->FollowPath \:running) \\r\\n        \:1 \\r\\n        {\:1 {\:id 1 \\r\\n             \:transform {\:x 32 \:y 32}\\r\\n             \:path {\:a-path [{\:grid-x 1\\r\\n                              \:grid-y 1}] \\r\\n                    \:curr-path-idx 0}}}\\n                (\:tile-map ms/game))\\n        \:tile-map)" "(bt/run (->FollowPath \:fresh) \\r\\n        \:1 \\r\\n        {\:1 (get-in ms/game [\:ecs \:entities 0])}\\n        (\:tile-map ms/game))" "(get-in ms/game [\:ecs \:entities 0])" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-mp ms/game))\\n        \:tile-map)" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of [(\:x (\:transform main-ent))\\n                                (\:y (\:transform main-ent))] \\n                               [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" "(use 'clojure.repl)" "(source math-utils/angle-of)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n[(\:x (\:transform main-ent))\\r\\n                                (\:y (\:transform main-ent))]\\n\\n)))))" "(source math-utils/angle-of)" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          \\"what\\"\\n\\n)))))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          \\"what\\")))))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          {\:a \\"what\\"}\\n          \\n          )))))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 1\\r\\n                                       \:grid-y 1}] \\r\\n                             \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of [(\:x (\:transform main-ent))\\n                                (\:y (\:transform main-ent))] \\n                               [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 1\\r\\n                               \:grid-y 1}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n[(\:x (\:transform main-ent))\\n (\:y (\:transform main-ent))] \\n                               \\n          )))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 1\\r\\n                               \:grid-y 1}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n[(tile-map/grid->world-coord (\:grid-x target-node))\\n (tile-map/grid->world-coord (\:grid-y target-node))])\\n          ))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 1\\r\\n                               \:grid-y 1}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of [(\:x (\:transform main-ent))\\n                                (\:y (\:transform main-ent))] \\n                               [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" "(defn angle-of [p2 p1]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees)]\\r\\n     bound-0-360))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of [(\:x (\:transform main-ent))\\n                                (\:y (\:transform main-ent))] \\n                               [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" "(defn angle-of-unbounded [p1 p2]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)]\\r\\n     angle-degrees))" "(defn angle-of-unbounded [p2 p1]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)]\\r\\n     angle-degrees))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of [(\:x (\:transform main-ent))\\n                                (\:y (\:transform main-ent))] \\n                               [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(defn angle-of-unbounded [p2 p1]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)]\\r\\n     angle-degrees))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (math-utils/angle-of-unbounded [(\:x (\:transform main-ent))\\n                                          (\:y (\:transform main-ent))] \\n                                         [(tile-map/grid->world-coord (\:grid-x target-node))\\n                                          (tile-map/grid->world-coord (\:grid-y target-node))])\\n          )))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\n            (if (zero? ent-target-angle-diff)\\n              ;walk towards it\\n              (bt/make-return-map node\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\n                                  curr-tile-map)\\n              ;turn towards it\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform \:rotation] (fn [r] (+ r ent-target-angle-diff)))\\r\\n                                  curr-tile-map))))))))" "(bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n              (get-in ms/game [\:ecs \:entities 0])\\n              \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n         (\:tile-map ms/game))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" "(defn bind-0-359 [angle-degrees]\\r\\n  (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees))\\r\\n\\r\\n(defn angle-of [p2 p1]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (bind-0-359 angle-degrees)]\\r\\n     bound-0-360))" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\n            (if (zero? ent-target-angle-diff)\\n              ;walk towards it\\n              (bt/make-return-map node\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\n                                  curr-tile-map)\\n              ;turn towards it\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform \:rotation] (fn [r] (+ r (math-utils/bind-0-359 ent-target-angle-diff))))\\r\\n                                  curr-tile-map))))))))" "(defn bind-0-359 [angle-degrees]\\r\\n  (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees))\\r\\n\\r\\n(defn angle-of [p2 p1]\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (bind-0-359 angle-degrees)]\\r\\n     bound-0-360))" "(ns-unmap 'bind-0-359)" "(ns-unmap *ns* 'bind-0-359)" ";are there anymore nodes left?\\n;no, then success\\n;yes, \\n;am i at target node?\\n;yes, get next\\n;no, am i facing it?\\n;yes, walk towards it\\n;no, turn towards it.\\n(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\n      (if (nil? target-node)\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\n        (if (and \\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\n            (if (zero? ent-target-angle-diff)\\n              ;walk towards it\\n              (bt/make-return-map node\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\n                                  curr-tile-map)\\n              ;turn towards it\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform \:rotation] (fn [r] (+ r (math-utils/bind-0-359 ent-target-angle-diff))))\\r\\n                                  curr-tile-map))))))))" "(dissoc (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                      (get-in ms/game [\:ecs \:entities 0])\\n                      \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n                 (\:tile-map ms/game))\\n        \:tile-map)" "(get-in (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n             (get-in ms/game [\:ecs \:entities 0])\\n             \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n        (\:tile-map ms/game))\\n        [\:entities 0])" "(get-in (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n             (get-in ms/game [\:ecs \:entities 0])\\n             \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n        (\:tile-map ms/game))\\n        [\:entities])" "(get-in (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n             (get-in ms/game [\:ecs \:entities 0])\\n             \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n        (\:tile-map ms/game))\\n        [\:entities \:1])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0]\\n                            \\n                            (get-in (bt/run (->FollowPath \:running) \\r\\n                \:1 \\r\\n                {\:1 (assoc \\n                                (get-in ms/game [\:ecs \:entities 0])\\n                                \:path {\:a-path [{\:grid-x 0\\r\\n                               \:grid-y 0}] \\r\\n              \:curr-path-idx 0})}\\n                   (\:tile-map ms/game))\\n                   [\:entities \:1])))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform \:rotation] (fn [r] (+ r (math-utils/bind-0-359 ent-target-angle-diff))))\\r\\n                                  curr-tile-map))))))))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:transform \:rotate-by] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(app)" "(ns basic-combat-ai.main-screen)" "(def get-first-ent []\\n  (get-in game [\:ecs \:entities 0]))" "(defn get-first-ent []\\n  (get-in game [\:ecs \:entities 0]))" "(get-first-ent)" "(basic-combat-ai.desktop-launcher/reset)" "(get-first-ent)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:rotate-by] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(ns basic-combat-ai.enemy-ai)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:transform \:rotate-by] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(get-first-ent)" "(ns basic-combat-ai.enemy-ai)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:rotate-by] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(ns basic-combat-ai.enemy-ai)" "(let [q-ent (ms/get-first-ent)\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n  ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n    (-> q-ent\\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n      (dissoc \:rotate-by))\\r\\n    (-> q-ent \\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [existing-systems] [(nth existing-systems 0)\\n                                                                       (nth existing-systems 1)\\n                                                                       (nth existing-systems 3)])))" "(ms/get-first-ent)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation 0]))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 180))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 360))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 270))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0))" "(let [q-ent (ms/get-first-ent)\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n  ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n    (-> q-ent\\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n      (dissoc \:rotate-by))\\r\\n    (-> q-ent \\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))" "(ms/get-first-ent)" "(let [q-ent (ms/get-first-ent)\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent))]\\r\\n  ;if the rotation speed is > than the rotation, don't overshoot.\\r\\n  (if (neg? (- (Math/abs rot-by) rot-speed)) \\r\\n    (-> q-ent\\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-by))\\r\\n      (dissoc \:rotate-by))\\r\\n    (-> q-ent \\r\\n      (update-in [\:transform \:rotation] \#(+ % rot-speed))\\r\\n      (assoc \:rotate-by (if (neg? rot-by) (+ rot-by rot-speed) (- rot-by rot-speed))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] -45))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0))" "(use 'clojure.repl)" "(source +)" "(let [x 1]\\n  ((if (neg? x) + -) 5 x))" "(let [x 0]\\n  ((if (neg? x) + -) 5 x))" "(neg? 0)" "(let [q-ent (ms/get-first-ent)\\r\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\n      updated-rotation ((if (neg? rot-by) - +) rotation rot-speed)\\n      updated-rot-by ((if (neg? rot-by) + -) rot-speed)]\\r\\n    [updated-rotation updated-rot-by]\\n  )" "(let [q-ent (ms/get-first-ent)\\r\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\n      updated-rotation ((if (neg? rot-by) - +) rot rot-speed)\\n      updated-rot-by ((if (neg? rot-by) + -) rot-speed)]\\r\\n    [updated-rotation updated-rot-by]\\n  )" "(ms/get-first-ent)" "(let [q-ent (ms/get-first-ent)\\r\\n      rot (\:rotation (\:transform q-ent))\\r\\n      rot-by (\:rotate-by q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\n      updated-rotation ((if (neg? rot-by) - +) rot rot-speed)\\n      updated-rot-by ((if (neg? rot-by) + -) rot-by rot-speed)]\\r\\n    [updated-rotation updated-rot-by]\\n  )" "(dissoc {} \:1)" "(/ 135 3)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id  \:target-rotation] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(pos? 0)" "(neg? 0)" "(get-in ms/game [\:ecs \:systems])" ";(update-game \#(update-in % [\:ecs \:systems] (fn [existing-systems] (conj existing-systems rotate))))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [q-ent (ms/get-first-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rotation) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                          ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                          target-rot)]\\r\\n                                   (if (\= updated-rotation target-rot)\\r\\n                                     (dissoc q-ent \:target-rot)\\r\\n                                     (assoc-in q-ent [\:transform rotation] updated-rotation))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rotation) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                          ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                          target-rot)]\\r\\n                                   (if (\= updated-rotation target-rot)\\r\\n                                     (dissoc q-ent \:target-rot)\\r\\n                                     (assoc-in q-ent [\:transform rotation] updated-rotation))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                          ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                          target-rot)]\\r\\n                                   (if (\= updated-rotation target-rot)\\r\\n                                     (dissoc q-ent \:target-rot)\\r\\n                                     (assoc-in q-ent [\:transform rotation] updated-rotation))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n     (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                               (\:movespeed %)\\r\\n                                                               (\:transform %)))\\r\\n           modified-ents (mapv (fn [q-ent]\\r\\n                                 (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                          ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                          target-rot)]\\r\\n                                   (if (\= updated-rotation target-rot)\\r\\n                                     (dissoc q-ent \:target-rot)\\r\\n                                     (assoc-in q-ent [\:transform \:rotation] updated-rotation))))\\r\\n                               qualifying-ents)]\\r\\n       (into modified-ents rest-ents)))" "(update-game \#(update-in % [\:ecs \:systems] (fn [existing-systems] (conj existing-systems rotate))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(ms/update-game \#(update-in % [\:ecs \:systems] (fn [existing-systems] (conj existing-systems rotate))))" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [existing-systems] (conj existing-systems rotate))))" "(Math/abs -1)" "ms/game" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n        (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                                  (\:movespeed %)\\r\\n                                                                  (\:transform %)))\\r\\n              modified-ents (mapv (fn [q-ent]\\r\\n                                    (let [rot (\:rotation (\:transform q-ent))\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                             ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                             target-rot)]\\r\\n                                      (if (\= updated-rotation target-rot)\\r\\n                                        (dissoc q-ent \:target-rot)\\r\\n                                        (assoc-in q-ent [\:transform \:rotation] updated-rotation))))\\r\\n                                  qualifying-ents)]\\r\\n          (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n        (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:rotate-by %) \\r\\n                                                                  (\:movespeed %)\\r\\n                                                                  (\:transform %)))\\r\\n              modified-ents (mapv (fn [q-ent]\\r\\n                                    (let [rot (\:rotation (\:transform q-ent))\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     ]\\r\\n                                      target-rot\\n                                      ))\\r\\n                                  qualifying-ents)]\\r\\n          (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n        (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n                                                                  (\:movespeed %)\\r\\n                                                                  (\:transform %)))\\r\\n              modified-ents (mapv (fn [q-ent]\\r\\n                                    (let [rot (\:rotation (\:transform q-ent))\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n   \\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n                                                             ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                                                             target-rot)]\\r\\n                                      (if (\= updated-rotation target-rot)\\r\\n                                        (dissoc q-ent \:target-rot)\\r\\n                                        (assoc-in q-ent [\:transform \:rotation] updated-rotation))))\\r\\n                                  qualifying-ents)]\\r\\n          (into modified-ents rest-ents)))" "(rotate ms/game)" "(app)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(update-in % [\:ecs \:systems] (fn [old-s] [(nth old-s 0)\\n                                                         (nth old-s 1)\\n                                                         (nth old-s 3)])))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:transform \:rotation] 0))" "(sys/rotate game)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? ent-target-angle-diff)\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;turn towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id  \:rotate-by] ent-target-angle-diff)\\r\\n                                  curr-tile-map))))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities])" "(run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))" "(bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (dissoc updated-node \:tile-map))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle-diff (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            ent-target-angle-diff))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(require '[basic-combat-ai.systems \:as systems])" "(systems/rotate ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\r\\n     updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (zero? (\= ent-target-angle (\:rotation (\:transform main-ent))))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                  curr-tile-map))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\r\\n     updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                  curr-tile-map))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\r\\n     updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (\= ent-target-angle (\:rotation (\:transform main-ent)))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\r\\n     updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            [ent-target-angle (\:rotation (\:transform main-ent))] ))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\r\\n     updated-node)" "(\= 0 0.0)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                  curr-tile-map))))))))" "(update-game\! \#(update-in % [\:ecs \:systems] (fn [old-s] (conj old-s systems/rotate))))" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [old-s] (conj old-s systems/rotate))))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities 0])" "(bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))" "(let [updated-node (bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          \\"what\\")))))" "(let [updated-node (bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          [(\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent)))]\\n           \\n           )))))" "(let [updated-node (bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                  curr-tile-map))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(let [updated-node (bt/run (->FollowPath \:running) \:4 {\:4 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (dissoc updated-node \:tile-map))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:running)))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (pop os))))" "(get-in ms/game [\:ecs \:systems])" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(first (\:ecs (\:entities ms/game)))" "(get-in ms/game [\:ecs \:entities 0])" "(let [q-ent (get-in ms/game [\:ecs \:entities 0])\\n      rot (\:rotation (\:transform q-ent))\\r\\n      target-rot (\:target-rotation q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n      target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n      updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n                               (zero? target-rot-diff-rot-speed))\\r\\n                         ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                         target-rot)]\\r\\n  (if (\= updated-rotation target-rot)\\r\\n    (dissoc q-ent \:target-rot)\\r\\n    (assoc-in q-ent [\:transform \:rotation] updated-rotation)))" "(let [q-ent (get-in ms/game [\:ecs \:entities 0])\\n      rot (\:rotation (\:transform q-ent))\\r\\n      target-rot (\:target-rotation q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n      target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n      updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n                               (zero? target-rot-diff-rot-speed))\\r\\n                         ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                         target-rot)]\\r\\n  updated-rotation)" "(let [q-ent (get-in ms/game [\:ecs \:entities 0])\\n      rot (\:rotation (\:transform q-ent))\\r\\n      target-rot (\:target-rotation q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n      target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n      updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n                               (zero? target-rot-diff-rot-speed))\\r\\n                         ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                         target-rot)]\\r\\n  target-rot)" "(let [q-ent (get-in ms/game [\:ecs \:entities 0])\\n      rot (\:rotation (\:transform q-ent))\\r\\n      target-rot (\:target-rotation q-ent)\\r\\n      rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n      target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n      updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n                               (zero? target-rot-diff-rot-speed))\\r\\n                         ((if (neg? target-rot) - +) rot rot-speed)\\r\\n                         target-rot)]\\r\\n  (if (\=\= updated-rotation target-rot)\\r\\n    (dissoc q-ent \:target-rot)\\r\\n    (assoc-in q-ent [\:transform \:rotation] updated-rotation)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n\\t                                                     ((if (neg? target-rot) - +) rot rot-speed)\\r\\n\\t                                                     target-rot)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n\\t                                (dissoc q-ent \:target-rot)\\r\\n\\t                                (assoc-in q-ent [\:transform \:rotation] updated-rotation))))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(require '[basic-combat-ai.systems \:as systems])" "(ms/update-game\! \#(assoc-in [\:ecs \:entities] (systems/rotate %)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(repeatedly 5 (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %))))" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(repeat 5 (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %))))" "(repeat 20 (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %))))" "(repeat 100 (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %))))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(repeat 2 (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %))))" "(get-in ms/game [\:ecs \:entities])" "(loop [counter 0]\\n  (if (\=\= counter 10)\\n    nil\\n    (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))))" "(loop [counter 0]\\n  (if (\=\= counter 10)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(- 135 84)" "(/ 51 3)" "(loop [counter 0]\\n  (if (\=\= counter 16)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(loop [counter 0]\\n  (if (\=\= counter 1)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(loop [counter 0]\\n  (if (\=\= counter 1)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent)) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n\\t                                                     ((if (neg? target-rot) - +) rot rot-speed)\\r\\n\\t                                                     target-rot)\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\n                                  (dissoc rotated-ent \:target-rot)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ns basic-combat-ai.enemy-ai)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\n                                   unchecked-target-rot (\:target-rotation q-ent)\\n                                   ;visually, the end result of 180 or -180 doesn't make a difference. But, if we're currently facing a westerly orientation, we don't want to spin clockwise to hit 180.\\n                                   ;so temporarily make it -180, so we spin counter-clock-wise.\\n                                   ;same goes for 0\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (if (and (or (\=\= 180 unchecked-target-rot)\\n                                                           (zero? unchecked-target-rot))\\n                                                       (neg? rot)) \\n                                                (* -1 unchecked-target-rot) \\n                                                unchecked-target-rot)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n\\t                                                     ((if (neg? target-rot) - +) rot rot-speed)\\r\\n\\t                                                     target-rot)\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rot)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(get-in ms/game [\:ecs \:entities])" "(systems/rotate ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))" "(get-in ms/game [\:ecs \:entities])" "(let [ent-target-angle 180\\n      main-ent {\:transform {\:rotation -135}}]\\n  (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n           (neg? (\:rotation (\:transform main-ent))))\\n    (* -1 ent-target-angle)\\n    ent-target-angle))" "(let [ent-target-angle 0\\n      main-ent {\:transform {\:rotation -135}}]\\n  (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n           (neg? (\:rotation (\:transform main-ent))))\\n    (* -1 ent-target-angle)\\n    ent-target-angle))" "-0" "-0.0" "(let [ent-target-angle 0.0\\n      main-ent {\:transform {\:rotation -135}}]\\n  (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n           (neg? (\:rotation (\:transform main-ent))))\\n    (* -1 ent-target-angle)\\n    ent-target-angle))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (let [target-rotation-component (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t           (neg? (\:rotation (\:transform main-ent))))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    (* -1 ent-target-angle)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    ent-target-angle)]\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] target-rotation-component)\\r\\n                                    curr-tile-map)))))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:running)))" "(basic-combat-ai.desktop-launcher/reset)" "(loop [counter 0]\\n  (if (\=\= counter 20)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(loop [counter 0]\\n  (if (\=\= counter 5)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(systems/rotate ms/game)" "(/ 180 3)" "(/ (- 180 135) 3)" "(loop [counter 0]\\n  (if (\=\= counter 14)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(loop [counter 0]\\n  (if (\=\= counter 1)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (systems/rotate %)))\\n      (recur (inc counter))\\n    \\n    )))" "(get-in ms/game [\:ecs \:entities])" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (dissoc updated-node \:tile-map))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              \\"wtf\\")))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (dissoc updated-node \:tile-map))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            [ent-target-angle (\:rotation (\:transform main-ent))]))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(zero? 0.0)" "(zero? -0.0)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n                angles-same? (fn [target-rot ent-rot] (if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot)))]\\r\\n            (if (angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (let [target-rotation-component (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t           (neg? (\:rotation (\:transform main-ent))))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    (* -1 ent-target-angle)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    ent-target-angle)]\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] target-rotation-component)\\r\\n                                    curr-tile-map)))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (\:entities updated-node))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:running)))" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n                angles-same? (fn [target-rot ent-rot] (if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot)))]\\r\\n            (angles-same? ent-target-angle (\:rotation (\:transform main-ent)))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n]\\r\\n            ;(if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot))\\n            ;(angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\n            ent-target-angle\\n            ))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n]\\r\\n            ;(if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot))\\n            ;(angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\n            (\:rotation (\:transform main-ent))\\n            ))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n]\\r\\n            ;(if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot))\\n            ;(angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\n            (or (\=\= ent-target-angle 180) (zero? ent-target-angle))\\n            ))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n]\\r\\n            ;(if (or (\=\= ent-rot 180) (zero? ent-rot)) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot))\\n            ;(angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\n            (or (\=\= (\:rotation (\:transform main-ent)) 180) (zero? (\:rotation (\:transform main-ent))))\\n            ))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  updated-node)" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n                angles-same? (fn [target-rot ent-rot] (if (or (\=\= (Math/abs ent-rot) 180) (zero? (Math/abs ent-rot))) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot)))]\\r\\n            (if (angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (let [target-rotation-component (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t           (neg? (\:rotation (\:transform main-ent))))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    (* -1 ent-target-angle)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    ent-target-angle)]\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] target-rotation-component)\\r\\n                                    curr-tile-map)))))))))" "(let [updated-node (bt/run (->FollowPath \:running) \:2 {\:2 (get-in ms/game [\:ecs \:entities 0])} (\:tile-map ms/game))]\\n  (\:entities updated-node))" "(get-in ms/game [\:ecs \:entities 0])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:running)))" "(get-in ms/game [\:ecs \:entities 0])" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of-unbounded [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                                     [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])\\r\\n                angles-same? (fn [target-rot ent-rot] (if (or (\=\= (Math/abs ent-rot) 180) (zero? (Math/abs ent-rot))) (\=\= target-rot (Math/abs ent-rot)) (\=\= target-rot ent-rot)))]\\r\\n            (if (angles-same? ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n              (let [target-rotation-component (if (and (or (\=\= ent-target-angle 0) (\=\= ent-target-angle 180))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t           (neg? (\:rotation (\:transform main-ent))))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    (* -1 ent-target-angle)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    ent-target-angle)]\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] target-rotation-component)\\r\\n                                    curr-tile-map)))))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:running)))" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (conj os systems/rotate))))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (conj os systems/rotate))))" "(get-in ms/game [\:ecs \:entities 0])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot-diff-rot-speed (- (Math/abs target-rot) rot-speed)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (if (or (pos? target-rot-diff-rot-speed) \\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t                              (zero? target-rot-diff-rot-speed))\\r\\n\\t                                                     ((if (neg? target-rot) - +) rot rot-speed)\\r\\n\\t                                                     target-rot)\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(basic-combat-ai.desktop-launcher/reset)" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (conj os systems/rotate))))" "(require '[basic-combat-ai.components \:as comps])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 5 1)))" "(app)" "(ns basic-combat-ai.behavior-tree)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 0])" "(def test-bt (get-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree]))" "test-bt" "(defn reset-behavior-tree [node]\\n  (if-not (\:children node)\\n    (reset node)\\n    (update node \:children \#(map reset-behavior-tree %))))" "(reset-behavior-tree test-bt)" "(defn reset-behavior-tree [node]\\n  (if-not (\:children node)\\n    (reset node)\\n    (-> node\\n      (reset)\\n      (update \:children \#(map reset-behavior-tree %)))))" "(reset-behavior-tree test-bt)" "(defn reset-behavior-tree [node]\\n  (if-not (\:children node)\\n    (reset node)\\n    (-> node\\n      (reset)\\n      (update \:children \#(mapv reset-behavior-tree %)))))" "(reset-behavior-tree test-bt)" "(ns basic-combat-ai.systems)" "(defn tick-behavior-tree [{{ents \:entities} \:ecs tile-map \:tile-map \:as game}]\\r\\n     (let [qualifying-ents (filter \#(\:behavior-tree %) ents)\\r\\n           ents-map (ent-vec->map ents)]\\r\\n       (loop [q-ents qualifying-ents ;only use this for the id's. \\r\\n              ents-m ents-map\\r\\n              t-map tile-map]\\r\\n         (if (empty? q-ents)\\r\\n           (vec (vals ents-m))\\r\\n           ;only using q-ents for the id's. try to do all other read/write to the ent-map, so I don't get confused later and try updating anything in q-ents.\\r\\n           (let [ent-id (keyword (str (\:id (first q-ents))))\\r\\n                 ;returns {\:node (the root) \:entities (as map) \:tile-map}\\n                 unchecked-bt (\:tree (\:behavior-tree (ent-id ents-m)))\\n                 checked-bt (if (or (\= \:success (\:status unchecked-bt))\\n                                    (\= \:failure (\:status unchecked-bt)))\\n                              (bt/reset-behavior-tree unchecked-bt)\\n                              unchecked-bt)\\r\\n                 tick-data (bt/tick checked-bt ent-id ents-m t-map)\\r\\n                 updated-ents-m (\:entities tick-data)\\r\\n                 updated-ent-with-ticked-node (assoc-in (ent-id updated-ents-m) [\:behavior-tree \:tree] (\:node tick-data))]\\r\\n             ;somewhere i need to do a dirty update to the tile map, directly. yay global variables.\\r\\n             (recur (rest q-ents) (assoc updated-ents-m ent-id updated-ent-with-ticked-node) (\:tile-ap tick-data)))))))" "(require '[basic-combat-ai.main-screen \:as ms])" "(tick-behavior-tree ms/game)" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (pop os))))" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (conj tick-behavior-tree))))" "(app)" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 0])" "(defrecord FindPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node]\\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             start-tile (tile-map/get-tile (tile-map/world-coord->grid (\:x (\:transform main-ent)))\\r\\n                                           (tile-map/world-coord->grid (\:y (\:transform main-ent)))\\r\\n                                           curr-tile-map)\\r\\n             target-tile (tile-map/get-tile (\:x (\:move-to main-ent)) (\:y (\:move-to main-ent)) curr-tile-map)\\r\\n             path (astar/calc-path start-tile target-tile curr-tile-map)]\\r\\n         (if (seq? path)\\r\\n           (bt/make-return-map (assoc node \:status \:success)\\r\\n                               (assoc entities main-ent-id (-> main-ent \\n                                                             (assoc \:path (comps/path path))\\n                                                             (dissoc \:move-to)))\\r\\n                               curr-tile-map)\\r\\n           (bt/make-return-map (assoc node \:status \:failure) main-ent curr-tile-map)))))" "(basic-combat-ai.desktop-launcher/reset)" "(ns basic-combat-ai.systems)" "(get-in ms/game [\:ecs \:entities 0])" "(require '[basic-combat-ai.components \:as comps])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 2 2)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 2 2)))" "(Math/abs (- 315 275))" "(Math/abs (- 275 315))" "(+ -270 360)" "(angle-of [1 1] [2 2])" "(angle-of [1 1] [1 1])" "(angle-of [1 1] [0 0])" "(angle-of [1 1] [1 2])" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                      [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (update-in entities [main-ent-id \:transform] (fn [t] (assoc t \\r\\n                                                                                              \:x (tile-map/grid->world-coord (\:grid-x target-node))\\r\\n                                                                                              \:y (tile-map/grid->world-coord (\:grid-y target-node)))))\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n                (bt/make-return-map node\\r\\n                                    (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                    curr-tile-map))))))))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\n                                                       (if (neg? angle-diff)\\n                                                         (+ 360 angle-diff)\\n                                                         (- angle-diff 360))\\n                                                       angle-diff)\\n                                   ;'overflow' check\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\n                                                        raw-rotation-left\\n                                                        rot-speed)\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (rotation-direction rot rotation-increment)\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(require '[basic-combat-ai.math-utils \:as math-utils])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\n                                                       (if (neg? angle-diff)\\n                                                         (+ 360 angle-diff)\\n                                                         (- angle-diff 360))\\n                                                       angle-diff)\\n                                   ;'overflow' check\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\n                                                        raw-rotation-left\\n                                                        rot-speed)\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(defn angle-of [p2 p1]\\r\\n  ;add check to see if the points are the same. if so, return nil because valid numbers are 0-359.\\r\\n  ;and this scenario would generate 0, which isn't correct. 0 means north.\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (bind-0-359 angle-degrees)]\\r\\n     bound-0-360))" "(defn bind-0-359 [angle-degrees]\\r\\n  (if (neg? angle-degrees) (+ 360 angle-degrees) angle-degrees))\\r\\n\\r\\n(defn angle-of [p2 p1]\\r\\n  ;add check to see if the points are the same. if so, return nil because valid numbers are 0-359.\\r\\n  ;and this scenario would generate 0, which isn't correct. 0 means north.\\r\\n  (let [delta-y (- (first p1) (first p2))\\r\\n        delta-x (- (second p1) (second p2))\\r\\n        angle-radians (Math/atan2 delta-y delta-x)\\r\\n        angle-degrees (Math/toDegrees angle-radians)\\r\\n        bound-0-360 (bind-0-359 angle-degrees)]\\r\\n     bound-0-360))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\n                                                       (if (neg? angle-diff)\\n                                                         (+ 360 angle-diff)\\n                                                         (- angle-diff 360))\\n                                                       angle-diff)\\n                                   ;'overflow' check\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\n                                                        raw-rotation-left\\n                                                        rot-speed)\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ns-unmap *ns* rotate)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\n                                                       (if (neg? angle-diff)\\n                                                         (+ 360 angle-diff)\\n                                                         (- angle-diff 360))\\n                                                       angle-diff)\\n                                   ;'overflow' check\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\n                                                        raw-rotation-left\\n                                                        rot-speed)\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(rotate ms/game)" "(get-in ms/game [\:ecs \:entities 0])" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] rotation-increment)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] raw-rotation-left)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (Math/abs (- raw-rotation-left rot-speed)))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] (Math/abs (- raw-rotation-left rot-speed)))]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (- (Math/abs raw-rotation-left) rot-speed))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] rotation-increment)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (- (Math/abs raw-rotation-left) rot-speed))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent [angle-diff raw-rotation-left rotation-increment rotation-direction updated-rotation]]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= 0 (- (Math/abs raw-rotation-left) rot-speed))\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (- (Math/abs raw-rotation-left) rot-speed)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(app)" "(ns basic-combat-ai.main-screen)" "(get-in game [\:ecs \:entities 0])" "(require '[basic-combat-ai.components \:as comps])" "(update-game\! \#(assoc-in game [\:ecs \:entities 0 \:move-to] (comps/move-to 2 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 2 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 1 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 3)))" "(get-in game [\:ecs \:entities 0])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 1 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 2)))" "(get-in game [\:ecs \:entities 0])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 3)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 1 2)))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 2)))" "(rotate ms/game)" "(rotate (assoc-in ms/game [\:ecs \:entities 0 \:target-rotation] 0))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> angle-diff 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             [angle-diff raw-rotation-left rotation-increment updated-rotation] \\n                               ))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate (assoc-in ms/game [\:ecs \:entities 0 \:target-rotation] 0))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             [angle-diff raw-rotation-left rotation-increment updated-rotation] \\n                               ))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate (assoc-in ms/game [\:ecs \:entities 0 \:target-rotation] 0))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(app)" "(ns basic-combat-ai.main-screen)" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 0}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 1 \:y 1}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 0}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 1 \:y 1}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 1}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 2}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 0 \:y 3}))" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] {\:x 1 \:y 3}))" "(get-in game [\:ecs \:entities 0])" "(require '[basic-combat-ai.main-screen \:as ms])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             [angle-diff raw-rotation-left rotation-increment updated-rotation]\\n                               ))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(get-in game [\:ecs \:entities 0])" "(get-in ms/game [\:ecs \:entities 0])" "(math-utils/bind-0-359 360)" "(math-utils/bind-0-359 359)" "(math-utils/bind-0-359 0)" "(math-utils/bind-0-359 -1)" "(math-utils/bind-0-359 -2)" "(math-utils/bind-0-359 -360)" "(math-utils/bind-0-359 -540)" "(defn bind-0-359 [angle-degrees]\\r\\n  (cond \\r\\n    (neg? angle-degrees) \\r\\n      (+ 360 angle-degrees)\\r\\n      \\r\\n    (> angle-degrees 359) \\r\\n      (- angle-degrees 360)\\r\\n      \\r\\n    \:else \\r\\n      angle-degrees))" "(math-utils/bind-0-359 -360)" "(get-in ms/game [\:ecs \:entities 0])" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord FollowPath [status]\\r\\n  bt/NodeBehavior\\r\\n  (bt/reset [node] \\r\\n    (assoc node \:status \:fresh))\\r\\n  (bt/run [node main-ent-id entities curr-tile-map]\\r\\n    (let [main-ent (main-ent-id entities)\\r\\n          curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n          curr-path (get-in main-ent [\:path \:a-path])\\r\\n          target-node (nth curr-path curr-path-idx nil)]\\r\\n      (if (nil? target-node)\\r\\n        (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n        (if (and \\r\\n              (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n              (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n          (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n          (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                      [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n            (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n              ;walk towards it\\r\\n              (bt/make-return-map node\\r\\n                                  (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                  curr-tile-map)\\r\\n              ;create component that will get picked up by a system to make us turn towards it.\\r\\n              ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n               (bt/make-return-map node\\r\\n                                   (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                   curr-tile-map))))))))" "(require '[basic-combat-ai.components \:as comps])" "(update-game\! \#(assoc-in % [\:ecs \:entities \:move-to] (comps/move-to 0 0)))" "game" "(update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 0)))" "(assoc-in ms/game [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:fresh))" "(require '[basic-combat-ai.components \:as comps])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 1 1)))" "(defrecord FollowPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n             curr-path (get-in main-ent [\:path \:a-path])\\r\\n             target-node (nth curr-path curr-path-idx nil)]\\r\\n         (if (nil? target-node)\\r\\n           (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n           (if (and \\r\\n                 (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n                 (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n             (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n             (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                         [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n               (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n                 ;walk towards it\\r\\n                 (bt/make-return-map node\\r\\n                                     (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                     curr-tile-map)\\r\\n                 ;create component that will get picked up by a system to make us turn towards it.\\r\\n                 ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n                  (bt/make-return-map node\\r\\n                                      (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                      curr-tile-map))))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:fresh)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 2 2)))" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))]\\n    qualifying-ents))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\n        update-ent (fn [e]\\n                     (let [x-inc-dir (if (> (\:x (\:target-location e)) (\:x (\:transform e))) + -)\\n                           y-inc-dir (if (> (\:y (\:target-location e)) (\:y (\:transform e))) + -)]\\n                       [x-inc-dir y-inc-dir]))]\\n    (update-ent (first ents))))" "(move ms/game)" "(type +)" "(defn move [{{ents \:entities} \:ecs}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\n        update-ent (fn [e]\\n                     (let [x-inc-dir (if (> (\:x (\:target-location e)) (\:x (\:transform e))) + -)\\n                           y-inc-dir (if (> (\:y (\:target-location e)) (\:y (\:transform e))) + -)]\\n                       [(type x-inc-dir) (type y-inc-dir)]))]\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\n        update-ent (fn [e]\\n                     (let [x-inc-dir (if (> (\:x (\:target-location e)) (\:x (\:transform e))) + -)\\n                           y-inc-dir (if (> (\:y (\:target-location e)) (\:y (\:transform e))) + -)]\\n                       [x-inc-dir y-inc-dir]))]\\n    (update-ent (first ents))))" "((first (move ms/game)) 1 1)" "((second (move ms/game)) 1 1)" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        update-ent (fn [e]\\r\\n                     (let [x-inc-dir (if (> (\:x (\:target-location e)) (tile-map/world-coord->grid (\:x (\:transform e)))) + -)\\r\\n                           y-inc-dir (if (> (\:y (\:target-location e)) (tile-map/world-coord->grid (\:y (\:transform e)))) + -)]\\r\\n                       [x-inc-dir y-inc-dir]))]\\r\\n    (update-ent (first ents))))" "((first (move ms/game)) 1 1)" "((second (move ms/game)) 1 1)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec [(Math/sin (Math/toRadians (\:rotation (\:transform e)))) (* -1 (Math/cos (Math/toRadians (\:rotation (\:transform e)))))]\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\n;                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (\:\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       dir-vec))]\\r\\n    (update-ent (first ents))))" "(move ms/game)" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec [(Math/sin (Math/toRadians (\:rotation (\:transform e)))) (Math/cos (Math/toRadians (\:rotation (\:transform e))))]\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\n;                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (\:\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       dir-vec))]\\r\\n    (update-ent (first ents))))" "(move ms/game)" "(let [rotation 45]\\n      [(Math/sin (Math/toRadians rotation)) (Math/cos (Math/toRadians rotation))])" "(let [rotation 180]\\n      [(Math/sin (Math/toRadians rotation)) (Math/cos (Math/toRadians rotation))])" "(let [rotation 180]\\n      [(int (Math/sin (Math/toRadians rotation))) (Math/cos (Math/toRadians rotation))])" "(use 'clojure.repl)" "(source Math/round)" "(format \\"%.2f\\" 0.019)" "(let [rotation 180\\n      round \#(format \\"%.2f\\" %)]\\n      [(round (Math/sin (Math/toRadians rotation)) 2) (Math/cos (Math/toRadians rotation))])" "(let [rotation 180\\n      round \#(format \\"%.2f\\" %)]\\n      [(round (Math/sin (Math/toRadians rotation))) (Math/cos (Math/toRadians rotation))])" "(let [rotation 180\\n      round \#(format \\"%.1f\\" %)]\\n      [(double (round (Math/sin (Math/toRadians rotation)))) (Math/cos (Math/toRadians rotation))])" "(let [rotation 180\\n      round \#(format \\"%.2f\\" %)]\\n      [(Double/parseDouble (round (Math/sin (Math/toRadians rotation)))) (Math/cos (Math/toRadians rotation))])" "(type 1.0)" "(type 1.0f)" "(let [rotation 45\\n      round \#(format \\"%.1f\\" %)]\\n      [(double (round (Math/sin (Math/toRadians rotation)))) (Math/cos (Math/toRadians rotation))])" "(let [rotation 45\\n      round \#(format \\"%.1f\\" %)]\\n      [(Double/parseDouble (round (Math/sin (Math/toRadians rotation)))) (Math/cos (Math/toRadians rotation))])" "(let [rotation 45\\n      round \#(format \\"%.1f\\" %)]\\n      [(Double/parseDouble (round (Math/sin (Math/toRadians rotation)))) (Double/parseDouble (Math/cos (Math/toRadians rotation)))])" "(let [rotation 45\\n      round \#(format \\"%.1f\\" %)]\\n      [(Double/parseDouble (round (Math/sin (Math/toRadians rotation)))) (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))])" "(let [rotation 45\\n      round \#(format \\"%.1f\\" %)\\n      x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\n      y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\n      [ ])" ";double length \= Math.sqrt( this.dX*this.dX + this.dY*this.dY );\\r\\n;      if (length \!\= 0) {\\r\\n;        v2.dX \= this.dX/length;\\r\\n;        v2.dY \= this.dY/length;\\r\\n;      }" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n         y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n         [ ])" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n         y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)]))" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n         y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         length)" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)]))" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)])\\n         [x y])" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)])\\n         [x 1])" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)])\\n         [x y])" "(* 0.7 5)" "(let [rotation 45\\r\\n         round \#(format \\"%.2f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)]))" "(let [rotation 45\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)])\\n         [x y])" "(let [rotation 90\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)])\\n         [x y])" "(let [rotation 90\\r\\n         round \#(format \\"%.1f\\" %)\\r\\n         x (Math/sin (Math/toRadians rotation))\\r\\n         y (Math/cos (Math/toRadians rotation))\\n         length (Math/sqrt (+ (* x x) (* y y)))]\\r\\n         (if (zero? length)\\n           0\\n           [(/ x length) (/ y length)]))" "(let [rotation 90\\r\\n      round \#(format \\"%.2f\\" %)\\r\\n      x (round (Math/sin (Math/toRadians rotation)))\\r\\n      y (round (Math/cos (Math/toRadians rotation)))]\\n  [x y])" "(let [rotation 90\\r\\n      round \#(format \\"%.2f\\" %)\\r\\n      x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n      y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\n  [x y])" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entitites 0])" "ms/ game" "ms/game" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-speed))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(get-in ms/game [\:ecs \:entities 0])" "(app)" "(require '[basic-combat-ai.main-screen \:as ms])" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-speed))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       y-speed))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 0.5 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(0.5 - -.71)" "(0.5 - -0.71)" "(- 0.5 -0.71)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       tar-loc-x))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(- 0.5 -0.71)" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       (\:x (\:transform e))))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) x-speed)\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       [tar-loc-x (\:x (\:transform e)) x-speed] ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\n                                   tar-loc-x\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\n                                   (- tar-loc-x (\:x (\:transform e)))\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [round \#(format \\"%.2f\\" %)\\r\\n                                x (Double/parseDouble (round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\n                                   (- tar-loc-x (\:x (\:transform e)))\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(defn round-to-decimal [number decimal]\\r\\n  (format (str \\"%.\\" decimal \\"f\\") number))" "(round-to-decimal 0.888 2)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (math-utils/round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\n                                   (- tar-loc-x (\:x (\:transform e)))\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(ns basic-combat-ai.main-screen)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (math-utils/round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(ns basic-combat-ai.systems)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (math-utils/round (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x 63.9 ;(tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           ;also calc shit for y\\r\\n                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       x-inc ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation))))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation))))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\n                                   (- tar-loc-y (\:y (\:transform e)))\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       [x-inc y-inc] ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation) 2)))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation) 2)))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (Math-utils/round-to-decimal (- tar-loc-x (\:x (\:transform e))) 2)\\r\\n                                   x-speed)\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\n                                   (Math-utils/round-to-decimal (- tar-loc-y (\:y (\:transform e))) 2)\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       [x-inc y-inc] ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (Math-utils/round-to-decimal (- tar-loc-x (\:x (\:transform e))) 2)\\r\\n                                   x-speed)\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\n                                   (Math-utils/round-to-decimal (- tar-loc-y (\:y (\:transform e))) 2)\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       [x-inc y-inc] ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (math-utils/round-to-decimal (- tar-loc-x (\:x (\:transform e))) 2)\\r\\n                                   x-speed)\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\n                                   (math-utils/round-to-decimal (- tar-loc-y (\:y (\:transform e))) 2)\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       [x-inc y-inc] ))]\\r\\n                       \\r\\n    (update-ent (first ents))))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (math-utils/round-to-decimal (- tar-loc-x (\:x (\:transform e))) 2)\\r\\n                                   x-speed)\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\n                                   (math-utils/round-to-decimal (- tar-loc-y (\:y (\:transform e))) 2)\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\n                         (dissoc e \:target-location)\\n                         (-> e\\n                           (update-in [\:transform \:x] (fn [x] (+ x x-inc)))\\n                           (update-in [\:transform \:y] (fn [y] (+ y y-inc)))))))\\n        modified-ents (mapv update-ent qualifying-ents)]\\n    (into modified-ents rest-ents)))" "(move ms/game)" "(loop [counter 0]\\n  (if (\=\= counter 3)\\n    nil\\n    (do\\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (move %)))\\n      (recur (inc counter)))))" "(get-in ms/game [\:ecs \:entities 0])" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (math-utils/round-to-decimal (+ x x-inc) 2)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 2)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (math-utils/round-to-decimal (+ x x-inc) 1)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/round (math-utils/bind-0-359 (rotation-direction rot rotation-increment)) 1)\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/round-to-decimal (math-utils/bind-0-359 (rotation-direction rot rotation-increment)) 1)\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              (if (\=\= updated-rotation target-rot)\\r\\n                                  (dissoc rotated-ent \:target-rotation)\\r\\n\\t                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(get-in ms/game [\:ecs \:systems])" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [os] (vector render animate rotate tick-behavior-tree))))" "(vector 1 2 3)" "(app)" "(ns basic-combat-ai.systems)" "(require '[basic-combat-ai.main-screen \:as ms])" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              updated-rotation))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              1))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t1)" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (math-utils/bind-0-359 (rotation-direction rot rotation-increment))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              updated-rotation))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate (assoc-in ms/game [\:ecs \:entities 0 \:target-rotation] 90))" "(math-utils/round-to-decimal 222 1)" "(type 222)" "(isa? 222 java.lang.Long)" "(isa? 222 Long)" "(instance? Long 222)" "(defn round-to-decimal [number decimal]\\r\\n  (if (instance? Long number)\\r\\n    number\\r\\n    (format (str \\"%.\\" decimal \\"f\\") number)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\n                                                      (math-utils/bind-0-359)\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              updated-rotation))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate (assoc-in ms/game [\:ecs \:entities 0 \:target-rotation] 90))" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 2] rotate))" "(move ms/game)" "(defn round-to-decimal [number decimal]\\r\\n  (if (instance? Long number)\\r\\n    number\\r\\n    (Double/parseDouble (format (str \\"%.\\" decimal \\"f\\") number))))" "(move ms/game)" "(format (str \\"%.\\" 1 \\"f\\") 11.2)" "(defn round-to-decimal [number decimal]\\r\\n  (if (instance? Long number)\\r\\n    number\\r\\n    (format (str \\"%.\\" decimal \\"f\\") number)))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (+ x x-inc) 1))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (+ x x-inc)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (Double/parseDouble (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2))\\r\\n                                y (Double/parseDouble (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2))]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (math-utils/round-to-decimal (+ x x-inc) 1)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(ns basic-combat-ai.math-utils)" "(defn round-to-decimal [number decimal]\\r\\n  (if (instance? Long number)\\r\\n    number\\r\\n    (let [formatted (format (str \\"%.\\" decimal \\"f\\") number)]\\r\\n      (if (instance? String formatted)\\r\\n        (Double/parseDouble formatted)\\r\\n        formatted))))" "(ns basic-combat-ai.systems)" "(move ms/game)" "(round-to-decimal 123 1)" "(round-to-decimal 123.1 1)" "(round-to-decimal 123.12 1)" "(use 'clojure.stacktrace)" "(print-stack-trace *e)" "(ns basic-combat-ai.systems)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 2)\\r\\n                                y (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 2)]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (math-utils/round-to-decimal (+ x x-inc) 1)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(move ms/game)" "(defn move [{{ents \:entities} \:ecs}]\\r\\n  (let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-location %) (\:movespeed %) (\:transform %)))\\r\\n        degrees->vector (fn [rotation]\\r\\n                          (let [x (math-utils/round-to-decimal (Math/sin (Math/toRadians rotation)) 1)\\r\\n                                y (math-utils/round-to-decimal (Math/cos (Math/toRadians rotation)) 1)]\\r\\n                            [x y]))\\r\\n        update-ent (fn [e]\\r\\n                     (let [dir-vec (degrees->vector (\:rotation (\:transform e)))\\r\\n                           x-speed (* (nth dir-vec 0) (\:movespeed (\:movespeed e)))\\r\\n                           y-speed (* (nth dir-vec 1) (\:movespeed (\:movespeed e)))\\r\\n                           tar-loc-x (tile-map/grid->world-coord (\:x (\:target-location e)))\\r\\n                           x-inc (if (< (Math/abs (- tar-loc-x (\:x (\:transform e)))) (Math/abs x-speed))\\r\\n                                   (- tar-loc-x (\:x (\:transform e)))\\r\\n                                   x-speed)\\r\\n                           tar-loc-y (tile-map/grid->world-coord (\:y (\:target-location e)))\\r\\n                           y-inc (if (< (Math/abs (- tar-loc-y (\:y (\:transform e)))) (Math/abs y-speed))\\r\\n                                   (- tar-loc-y (\:y (\:transform e)))\\r\\n                                   y-speed)]\\r\\n;                           x-inc-dir (if (> tar-loc-x (\:x (\:transform e))) + -)\\r\\n;                           y-inc-dir (if (> (tile-map/grid->world-coord (\:y (\:target-location e))) (\:y (\:transform e))) + -)]\\r\\n                       ;if the x and y transforms are equal to the x and y in the target location, then remove the target-location component from the entity and return it.\\r\\n                       ;else, apply the x increment and the y increment to the transform and return the entity.\\r\\n                       (if (and (\=\= tar-loc-x (\:x (\:transform e))) (\=\= tar-loc-y (\:y (\:transform e))))\\r\\n                         (dissoc e \:target-location)\\r\\n                         (-> e\\r\\n                           (update-in [\:transform \:x] (fn [x] (math-utils/round-to-decimal (+ x x-inc) 1)))\\r\\n                           (update-in [\:transform \:y] (fn [y] (math-utils/round-to-decimal (+ y y-inc) 1)))))))\\r\\n        modified-ents (mapv update-ent qualifying-ents)]\\r\\n    (into modified-ents rest-ents)))" "(move ms/game)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities] (move %)))" "(loop [c 10]\\n  (if (zero? c)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (move %)))\\n      (recur (dec c)))))" "(get-in ms/game [\:ecs \:entities])" "(basic-combat-ai.desktop-launcher/reset)" "(get-in ms/game [\:ecs \:entities])" "(get-in ms/game [\:ecs \:systems])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                              rotated-ent))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 2] rotate))" "(basic-combat-ai.desktop-launcher/reset)" "(loop [c 30]\\n  (if (zero? c)\\n    nil\\n    (do \\n      (ms/update-game\! \#(assoc-in % [\:ecs \:entities] (move %)))\\n      (recur (dec c)))))" "(ms/update-game\! \#(update-in % [\:ecs \:systems] (fn [s] (conj s move))))" "(get-in ms/game [\:ecs \:systems])" "(require '[basic-combat-ai.components \:as comps])" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 0)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0 1)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 4 4)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 8 1)))" "(get-in ms/game [\:ecs \:entities])" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 2] rotate))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 4 4)))" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 0))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot (\:rotation (\:transform q-ent)))\\r\\n                                (dissoc q-ent \:target-location)\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot (\:rotation (\:transform q-ent)))\\r\\n                                (dissoc q-ent \:target-location)\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 8\\n                                                                         4)))" "(/ 32 1)" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 4\\n                                                                         4)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 8\\n                                                                         4)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0\\n                                                                         4)))" "(get-in ms/game [\:ecs \:entities 0])" "(\=\= 270.0 270.0)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot updated-rotation)\\r\\n                                (dissoc rotated-ent \:target-location)\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 2] rotate))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot updated-rotation)\\r\\n                                \\"removed\\"\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(rotate ms/game)" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot updated-rotation)\\r\\n                                (dissoc rotated-ent \:target-location)\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(require '[basic-combat-ai.main-screen \:as ms])" "(defrecord FollowPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n             curr-path (get-in main-ent [\:path \:a-path])\\r\\n             target-node (nth curr-path curr-path-idx nil)]\\r\\n         (if (nil? target-node)\\r\\n           (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n           (if (and \\r\\n                 (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n                 (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n             (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n             (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                         [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n               ent-target-angle))))))" "(\:entities (bt/run (->FollowPath \:running)\\n                   \:4\\n                   {\:4 (get-in ms/game [\:ecs \:entities 0])}\\n                   (\:tile-map ms/game)))" "(bt/run (->FollowPath \:running)\\n        \:4\\n        {\:4 (get-in ms/game [\:ecs \:entities 0])}\\n        (\:tile-map ms/game))" "(get-in ms/game [\:ecs \:entities])" "(defn rotate [{{ents \:entities} \:ecs}]\\r\\n\\t(let [[qualifying-ents rest-ents] (filter-ents ents \#(and (\:target-rotation %) \\r\\n\\t                                                          (\:movespeed %)\\r\\n\\t                                                          (\:transform %)))\\r\\n\\t      modified-ents (mapv (fn [q-ent]\\r\\n\\t                            (let [rot (\:rotation (\:transform q-ent))\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     target-rot (\:target-rotation q-ent)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     rot-speed (\:rotation-speed (\:movespeed q-ent))\\r\\n                                   angle-diff (- target-rot rot)\\r\\n                                   raw-rotation-left (if (> (Math/abs angle-diff) 180)\\r\\n                                                       (if (neg? angle-diff)\\r\\n                                                         (+ 360 angle-diff)\\r\\n                                                         (- angle-diff 360))\\r\\n                                                       angle-diff)\\r\\n                                   ;'overflow' check\\r\\n                                   rotation-increment (if (<\= (Math/abs (- raw-rotation-left rot-speed)) 0)\\r\\n                                                        raw-rotation-left\\r\\n                                                        rot-speed)\\r\\n                                   rotation-direction (if (neg? raw-rotation-left) - +)\\r\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t     updated-rotation (-> (rotation-direction rot rotation-increment)\\r\\n                                                      (math-utils/bind-0-359)\\r\\n                                                      (math-utils/round-to-decimal 1))\\r\\n                                   rotated-ent (assoc-in q-ent [\:transform \:rotation] updated-rotation)]\\r\\n\\t                             (if  (\=\= target-rot updated-rotation)\\r\\n                                (dissoc rotated-ent \:target-rotation)\\r\\n                                rotated-ent)))\\r\\n\\t                          qualifying-ents)]\\r\\n\\t  (into modified-ents rest-ents)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:systems 2] rotate))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 8\\n                                                                         4)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0\\n                                                                         0)))" "(defrecord FollowPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n             curr-path (get-in main-ent [\:path \:a-path])\\r\\n             target-node (nth curr-path curr-path-idx nil)]\\r\\n         (if (nil? target-node)\\r\\n           (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n           (if (and \\r\\n                 (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n                 (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n             (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n             (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                         [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n               (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n                 ;walk towards it\\r\\n                 (bt/make-return-map node\\r\\n                                     (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                     curr-tile-map)\\r\\n                 ;create component that will get picked up by a system to make us turn towards it.\\r\\n                 ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n                  (if (\:target-rotation main-ent)\\r\\n                    (bt/make-return-map node entities curr-tile-map)\\r\\n                    (bt/make-return-map node\\r\\n                                      (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                      curr-tile-map)))))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:fresh)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 4\\r\\n                                                                         4)))" "(defrecord FollowPath [status]\\r\\n     bt/NodeBehavior\\r\\n     (bt/reset [node] \\r\\n       (assoc node \:status \:fresh))\\r\\n     (bt/run [node main-ent-id entities curr-tile-map]\\r\\n       (let [main-ent (main-ent-id entities)\\r\\n             curr-path-idx (get-in main-ent [\:path \:curr-path-idx])\\r\\n             curr-path (get-in main-ent [\:path \:a-path])\\r\\n             target-node (nth curr-path curr-path-idx nil)]\\r\\n         (if (nil? target-node)\\r\\n           (bt/make-return-map (assoc node \:status \:success) (assoc entities main-ent-id (dissoc main-ent \:path)) curr-tile-map)\\r\\n           (if (and \\r\\n                 (\=\= (\:grid-x target-node) (tile-map/world-coord->grid (\:x (\:transform main-ent))))\\r\\n                 (\=\= (\:grid-y target-node) (tile-map/world-coord->grid (\:y (\:transform main-ent)))))\\r\\n             (bt/make-return-map node (update-in entities [main-ent-id \:path \:curr-path-idx] \#(inc %)) curr-tile-map)\\r\\n             (let [ent-target-angle (math-utils/angle-of [(\:x (\:transform main-ent)) (\:y (\:transform main-ent))] \\r\\n                                                         [(tile-map/grid->world-coord (\:grid-x target-node)) (tile-map/grid->world-coord (\:grid-y target-node))])]\\r\\n               (if (\=\= ent-target-angle (\:rotation (\:transform main-ent)))\\r\\n                 ;walk towards it\\n                 (if (\:target-location main-ent)\\n                   (bt/make-return-map node entities curr-tile-map)\\r\\n                   (bt/make-return-map node\\r\\n                                       (assoc-in entities [main-ent-id \:target-location] {\:x (\:grid-x target-node), \:y (\:grid-y target-node)})\\r\\n                                       curr-tile-map))\\r\\n                 ;create component that will get picked up by a system to make us turn towards it.\\r\\n                 ;if there is ever a conflict with something else setting the target-rotation within the same frame, there will be overwriting or something. hmm.. not sure how i want to handle this yet.\\r\\n                  (if (\:target-rotation main-ent)\\r\\n                    (bt/make-return-map node entities curr-tile-map)\\r\\n                    (bt/make-return-map node\\r\\n                                      (assoc-in entities [main-ent-id \:target-rotation] ent-target-angle)\\r\\n                                      curr-tile-map)))))))))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:behavior-tree \:tree \:children 2] (->FollowPath \:fresh)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 0\\r\\n                                                                         0)))" "(ms/update-game\! \#(assoc-in % [\:ecs \:entities 0 \:move-to] (comps/move-to 4\\r\\n                                                                         8)))"]
eclipse.preferences.version=1
